import re
import tkinter as tk
from tkinter import LEFT, messagebox,Entry,Text,DISABLED
from tkinter import Frame, LabelFrame,Label,Checkbutton,Button,HORIZONTAL,VERTICAL,BOTTOM,RIGHT,X,Y,BOTH
from tkinter import font
from PIL import Image, ImageTk
from tkinter import ttk 
from tkcalendar import DateEntry
from getpass import getuser
import datetime
from datetime import date, datetime, timedelta
import webbrowser
import KBACKEND

class ToolTip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tooltip_window = None
        self.widget.bind("<Enter>", self.show_tooltip)
        self.widget.bind("<Leave>", self.hide_tooltip)

    def show_tooltip(self, event):
        if self.tooltip_window or not self.text:
            return
        x, y, cx, cy = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 25
        self.tooltip_window = tw = tk.Toplevel(self.widget)
        tw.wm_overrideredirect(True)  # No window decorations (border, title, etc.)
        tw.wm_geometry(f"+{x}+{y}")
        label = tk.Label(tw, text=self.text, justify='left',
                         background="#ffffe0", relief='solid', borderwidth=1,
                         font=("tahoma", "8", "normal"))
        label.pack(ipadx=1)

    def hide_tooltip(self, event):
        if self.tooltip_window:
            self.tooltip_window.destroy()
            self.tooltip_window = None


class KerridgeReplacement:
    
    current_user=getuser()
    KBACKEND.adduser_or_justleave(current_user)
    def __init__(self, root):
        self.root = root
        self.root.title("IMPO VERSION 1.0")
        self.root.geometry("800x630")
        #self.root.resizable(False, False)

        self.form_window = None
      
        # Initialize your UI
         
        # Add icons within a box
        self.add_icon_box()

        # Add a DataFrame below the icons
        self.add_data_frame()

        self.undo_stack = []
        
        self.incieve=False
        self.incieveone=False

        self.original_uplift_percentage = 0 

        
         
    #Creating the top 13 icons with images
    def add_icon_box(self):
        # Create a container (Frame) for the icons with a border
        icon_box = tk.Frame(self.root, relief=tk.RIDGE, borderwidth=1)
        icon_box.pack(side=tk.TOP, fill=tk.X, padx=8, pady=2)  # Fill horizontally

        # Frame for left-aligned icons
        left_frame = tk.Frame(icon_box)
        left_frame.pack(side=tk.LEFT, fill=tk.Y)  # Pack left-aligned frame

        # Frame for right-aligned icons
        right_frame = tk.Frame(icon_box)
        right_frame.pack(side=tk.RIGHT, fill=tk.Y)  # Pack right-aligned frame

        # Add left-aligned icons
        image_paths = ["icon1.png", "icon2.png", "extract.png","Purchase History.png"]
        tooltips = ["Exit the application", "Create an Incident", "Create Purchase Orders without Incident Linked","Open Purchase History"]

        for ida, (path, tooltip_text) in enumerate(zip(image_paths, tooltips), start=1):
            image = Image.open(path)
            image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
            photo = ImageTk.PhotoImage(image)
            icon_button = tk.Button(left_frame, image=photo, command=lambda index=ida: self.open_icon_window(index))
            icon_button.image = photo
            icon_button.pack(side=tk.LEFT, padx=5, pady=2)  # Reduce pady value

            ToolTip(icon_button, tooltip_text)

        # Add right-aligned icons
        image_paths_two = ["suggestion.png", "feedback.png"]
        tooltips_two = ["IMPO FEATURES REQUEST", "IMPO FEEDBACK"]

        for idfeedback, (path, tooltip_text) in enumerate(zip(image_paths_two, tooltips_two), start=1):
            image = Image.open(path)
            image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
            photo = ImageTk.PhotoImage(image)
            icon_button = tk.Button(right_frame, image=photo, command=lambda index=idfeedback: self.open_links(index))
            icon_button.image = photo
            icon_button.pack(side=tk.RIGHT, padx=5, pady=2)  # Align to the right

            ToolTip(icon_button, tooltip_text)
    def open_links(self,index):
       if index==1:
          self.open_feedback()
       if index==2:
          self.open_features()
    def open_feedback(self):
       feedbackurl="https://forms.office.com/e/iF86PcyJaC"
       webbrowser.open(feedbackurl)
    def open_features(self):
       featuresurl="https://forms.office.com/e/VyBH9YMtYN"
       webbrowser.open(featuresurl)   
    #Creating all the dataframes for the first page 
    def add_data_frame(self):
        self.widgetsonetab=[]
        # Create a DataFrame below the icons
        dataframe = LabelFrame(self.root, bd=3, relief=tk.RIDGE,text="Filter forwards")
        dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
        dataframe.place(x=0, y=40, width=780, height=128) 

        #================Legend frame================================#

        Legendframe= LabelFrame(self.root, relief=tk.RIDGE, text="Legend")
        Legendframe.place(x=0,y=168,width=780,height=80)

        #=================Details Frame===============================#

        Detailsframe= LabelFrame(self.root, relief=tk.RIDGE,text="Details")
        Detailsframe.place(x=0,y=248,width=780,height=380)

       #===================Creating Lables and Text Fields=============================#
        self.Regfetch=KBACKEND.fetch_registration_number_for_first_page()
        self.onlyreg=[row[0] for row in self.Regfetch]
        lb1 = Label(dataframe, text="Registration", padx=10)
        lb1.grid(row=0, column=0)
        self.Regtext1 = ttk.Combobox(dataframe, width=15,values=self.onlyreg)
        self.Regtext1.grid(row=0, column=1)
        self.Regtext1.bind("<KeyRelease>", self.filter_reg_list)
        self.widgetsonetab.append(self.Regtext1)
        self.attach_context_menu(self.Regtext1)
        
        self.Customer_details=KBACKEND.fetch_customer_number_for_first_page()
        self.Customer_detailsonly= [row[0] for row in self.Customer_details]
        lb2 = Label(dataframe, text="Customer", padx=10)
        lb2.grid(row=0, column=2)
        self.custext2 = ttk.Combobox(dataframe, width=16,values=self.Customer_detailsonly)
        self.custext2.grid(row=0, column=3)
        self.custext2.bind("<KeyRelease>", self.filter_customer_list)
        self.widgetsonetab.append(self.custext2)
        self.attach_context_menu(self.custext2)
        
        lb3 = Label(dataframe, text="Owner", padx=5)
        lb3.grid(row=0, column=4)
        self.text3 = Entry(dataframe, width=16)
        self.text3.grid(row=0, column=5)
        self.widgetsonetab.append(self.text3)
        self.attach_context_menu(self.text3)

        lb4 = Label(dataframe, text="Creator", padx=5)
        lb4.grid(row=0, column=6)
        self.text4 = Entry(dataframe, width=16)
        self.text4.grid(row=0, column=7)
        self.widgetsonetab.append(self.text4)
        self.attach_context_menu(self.text4)

        # Incident Type-Cat
        catdetails=KBACKEND.fetch_cat_details()
        self.catdetails= [row[1] for row in catdetails]
        lb5 = Label(dataframe, text="Defect Cat", padx=5,pady=5)
        lb5.grid(row=1, column=0)
        self.text5 = ttk.Combobox(dataframe, values= self.catdetails, width=15)
        self.text5.grid(row=1, column=1)
        self.widgetsonetab.append(self.text5)
        self.attach_context_menu(self.text5)
        
        #Incident Type- Loc
        locationdetails= KBACKEND.fetch_Location_details()
        self.locationdetails= [row[1] for row in locationdetails]
        locationlabel= Label(dataframe,text="Location", padx=5)
        locationlabel.grid(row=1,column=2)
        self.I_location=ttk.Combobox(dataframe,values=self.locationdetails,width=15)
        self.I_location.grid(row=1,column=3)
        self.widgetsonetab.append(self.I_location)
        self.attach_context_menu(self.I_location)

        #Incident Type- Charge
        Chargedetails=KBACKEND.fetch_charge_details()
        self.chargedetails=[row[1] for row in Chargedetails]
        chargelabel=Label(dataframe,text="Recharge",padx=5)
        chargelabel.grid(row=1,column=4)
        self.I_charge=ttk.Combobox(dataframe,values=self.chargedetails,width=14)
        self.I_charge.grid(row=1,column=5)
        self.attach_context_menu(self.I_charge)
        self.widgetsonetab.append(self.I_charge)
        # Incident date
        lb6 = Label(dataframe, text="Incident date", padx=5)
        lb6.grid(row=1, column=6)
        self.text6 = DateEntry(dataframe, width=13, background='darkblue', foreground='white', borderwidth=2, date_pattern='yyyy-mm-dd')
        self.text6.grid(row=1, column=7)
        #self.text6.set_date(None)
        self.text6.delete(0, "end")
        self.widgetsonetab.append(self.text6)
        self.attach_context_menu(self.text6)

        #status
        self.Statusdetails= KBACKEND.fetch_status_details()
        self.stats= [row[1] for row in self.Statusdetails]
        lb7=Label(dataframe,text="Status",padx=5)
        lb7.grid(row=2, column=0)
        self.text7= ttk.Combobox(dataframe,values=self.stats,width=15)
        self.text7.grid(row=2,column=1,padx=5,pady=5)
        self.widgetsonetab.append(self.text7)
        self.attach_context_menu(self.text7)
        

        #closed
        self.is_closed= tk.BooleanVar()
        self.text11= Checkbutton(dataframe,variable=self.is_closed,width=2,command=self.filter_kerride_table)
        self.text11.grid(row=2,column=2)
        self.widgetsonetab.append(self.text11)
        self.lb8=Label(dataframe,text="Closed")
        self.lb8.grid(row=2, column=3)
        self.attach_context_menu(self.text11)

        #Locations
        rowss = KBACKEND.fetch_locations_and_descriptions()
        self.depotdetailstoppage = [row[1] for row in rowss]
        lb8= Label(dataframe,text="PF Depot")
        lb8.grid(row=2,column=4)
        self.text12=ttk.Combobox(dataframe,width=14,values=self.depotdetailstoppage)
        self.text12.grid(row=2,column=5)
        self.widgetsonetab.append(self.text12)
        self.attach_context_menu(self.text12)

        lb9= Label(dataframe,text="Incident No")
        lb9.grid(row=2,column=6)
        self.text13=Entry(dataframe,width=15)
        self.text13.grid(row=2,column=7)
        self.attach_context_menu(self.text12)
        self.widgetsonetab.append(self.text13)
        
        
        self.attach_events()

        
        self.clear_button = ttk.Button(dataframe, text="Clear All",width=10,command=self.clear_filters)
        self.clear_button.grid(row=3, column=7)
        self.widgetsonetab.append(self.clear_button)

        style = ttk.Style()
        style.configure("Bold.TEntry", foreground="black", font=("Helvetica", 10, "bold"))
        self.bold_font = font.Font(family="Helvetica", size=10, weight="bold")
        btnoverdue = Button(Legendframe, text="Overdue", fg="White", bg="red", width=11, height=1, padx=2, pady=6,
                    command=lambda: self.populate_kerride_table(filter_type="overdue"))
        btnoverdue.grid(row=0, column=0)
        self.widgetsonetab.append(btnoverdue)
        self.entry_red_count = ttk.Entry(Legendframe, width=10,style="Bold.TEntry")
        self.entry_red_count.grid(row=1, column=0)
        self.entry_red_count.configure(foreground="black", font=self.bold_font)
        self.widgetsonetab.append(self.entry_red_count)

# Half Hour Button
        bthalfhour = Button(Legendframe, text="1/2 Hour", fg="White", bg="Fuchsia", width=10, height=1, padx=2, pady=6,
                    command=lambda: self.populate_kerride_table(filter_type="half_hour"))
        bthalfhour.grid(row=0, column=1)
        self.widgetsonetab.append(bthalfhour)
        self.entry_fuchsia_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_fuchsia_count.grid(row=1, column=1)
        self.widgetsonetab.append(self.entry_fuchsia_count)
        self.entry_fuchsia_count.configure(foreground="black", font=self.bold_font)

# One Hour Button
        btnonehour = Button(Legendframe, text="1 Hour", fg="White", bg="Dark Green", width=10, height=1, padx=2, pady=6,
                    command=lambda: self.populate_kerride_table(filter_type="one_hour"))
        btnonehour.grid(row=0, column=2)
        self.widgetsonetab.append(btnonehour)
        self.entry_dark_green_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_dark_green_count.grid(row=1, column=2)
        self.entry_dark_green_count.configure(foreground="black", font=self.bold_font)
        self.widgetsonetab.append(self.entry_dark_green_count)

# Four Hours Button
        btnfourhours = Button(Legendframe, text="4 Hours", fg="White", bg="Black", width=10, height=1, padx=2, pady=6,
                      command=lambda: self.populate_kerride_table(filter_type="four_hours"))
        btnfourhours.grid(row=0, column=3)
        self.widgetsonetab.append(btnfourhours)
        self.entry_black_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_black_count.grid(row=1, column=3)
        self.entry_black_count.configure(foreground="black", font=self.bold_font)
        self.widgetsonetab.append(self.entry_black_count)

# One Day Button
        btnOneday = Button(Legendframe, text="1 day", fg="White", bg="Green", width=10, height=1, padx=2, pady=6,
                   command=lambda: self.populate_kerride_table(filter_type="one_day"))
        btnOneday.grid(row=0, column=4)
        self.widgetsonetab.append(btnOneday)
        self.entry_green_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_green_count.grid(row=1, column=4)
        self.entry_green_count.configure(foreground="black", font=self.bold_font)
        self.widgetsonetab.append(self.entry_green_count)

# Over One Day Button
        btnOverOneday = Button(Legendframe, text="Over 1 day", fg="White", bg="Blue", width=10, height=1, padx=2, pady=6,
                       command=lambda: self.populate_kerride_table(filter_type="over_one_day"))
        btnOverOneday.grid(row=0, column=5)
        self.widgetsonetab.append(btnOverOneday)
        self.entry_blue_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_blue_count.grid(row=1, column=5)
        self.entry_blue_count.configure(foreground="black", font=self.bold_font)
        self.widgetsonetab.append(self.entry_blue_count)

# Closed Button
        btnClosed = Button(Legendframe, text="Closed", fg="White", bg="Dark Grey", width=10, height=1, padx=2, pady=6,
                   command=lambda: self.populate_kerride_table(filter_type="closed"))
        btnClosed.grid(row=0, column=6)
        self.widgetsonetab.append(btnClosed)
        self.entry_dark_grey_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_dark_grey_count.grid(row=1, column=6)
        self.entry_dark_grey_count.configure(foreground="black", font=self.bold_font)
        self.widgetsonetab.append(self.entry_dark_grey_count) 

        btnClearFilters = Button(Legendframe, text="Clear Filters", fg="White", bg="Purple", width=10, height=1, padx=2, pady=6,
                         command=lambda: self.populate_kerride_table(filter_type=None))
        btnClearFilters.grid(row=0, column=8)
        self.widgetsonetab.append(btnClearFilters)

       

        for widget in self.widgetsonetab:
            widget.bind("<Tab>", self.focus_next_widget)
            widget.bind("<Shift-Tab>", self.focus_previous_widget)
        
        #==================================Table==================================================#
        #==================Scrollbar==================#
        
        # Create the scrollbars
       # Create the scrollbars
        scrollbar_x = ttk.Scrollbar(Detailsframe, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(Detailsframe, orient=VERTICAL)

        # Create the Treeview widget
        self.root.Kerride_table = ttk.Treeview(Detailsframe, column=("Incident Date", "Customer", "Location",
                                                            "Registration", "Incident No", "Cat", "Loca", 
                                                            "Rech", "Status", "Owner", "Creator", "Due Date", "Time"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
    
        self.root.Kerride_table.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        # Attach the scrollbar commands to the scrollbar widgets
        scrollbar_x.config(command=self.root.Kerride_table.xview)
        scrollbar_y.config(command=self.root.Kerride_table.yview)

        # Set column headings
        self.root.Kerride_table.heading("Incident Date", text="Incident Date")
        self.root.Kerride_table.heading("Customer", text="Customer")
        self.root.Kerride_table.heading("Location", text="Location")
        self.root.Kerride_table.heading("Registration", text="Registration")
        self.root.Kerride_table.heading("Incident No", text="Incident no")
        self.root.Kerride_table.heading("Cat", text="Cat")
        self.root.Kerride_table.heading("Loca", text="Loca")
        self.root.Kerride_table.heading("Rech", text="Rech")
        self.root.Kerride_table.heading("Status", text="Status")
        self.root.Kerride_table.heading("Owner", text="Owner")
        self.root.Kerride_table.heading("Creator", text="Creator")
        self.root.Kerride_table.heading("Due Date", text="Due Date")
        self.root.Kerride_table.heading("Time", text="Time")

        # Set Treeview to display column headings only
        self.root.Kerride_table["show"] = "headings"

        # Set column widths
        self.root.Kerride_table.column("Incident Date", width=76)
        self.root.Kerride_table.column("Customer", width=160)
        self.root.Kerride_table.column("Location", width=100)
        self.root.Kerride_table.column("Registration", width=90)
        self.root.Kerride_table.column("Incident No", width=73)
        self.root.Kerride_table.column("Cat", width=48)
        self.root.Kerride_table.column("Loca", width=48)
        self.root.Kerride_table.column("Rech", width=48)
        self.root.Kerride_table.column("Status", width=45)
        self.root.Kerride_table.column("Owner", width=70)
        self.root.Kerride_table.column("Creator", width=70)
        self.root.Kerride_table.column("Due Date", width=95)
        self.root.Kerride_table.column("Time", width=70)
        
        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.root.Kerride_table.pack(side=LEFT, fill=BOTH, expand=True)

        # Bind the function to the Treeview widget after table creation
        self.root.Kerride_table.bind("<ButtonRelease-1>", self.change_row_color)

        
        self.populate_kerride_table()
    def focus_next_widget(self, event):
        """Move focus to the next widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetsonetab.index(widget)
        next_index = (current_index + 1) % len(self.widgetsonetab)
        self.widgetsonetab[next_index].focus_set()
        return "break"  # Prevent default behavior

    def focus_previous_widget(self, event):
        """Move focus to the previous widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetsonetab.index(widget)
        previous_index = (current_index - 1) % len(self.widgetsonetab)
        self.widgetsonetab[previous_index].focus_set()
        return "break" 
    
                

    def attach_events(self):
        self.Regtext1.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.custext2.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.text3.bind("<KeyRelease>", self.filter_kerride_table)
        self.text4.bind("<KeyRelease>", self.filter_kerride_table)
        self.text5.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.I_location.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.I_charge.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.text6.bind("<<DateEntrySelected>>", self.filter_kerride_table)
        self.text7.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.text12.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.text13.bind("<KeyRelease>", self.filter_kerride_table)

    def filter_reg_list(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Regtext1.get()
        if current_text == '':
            self.Regtext1['values'] = self.onlyreg
        else:
            filtered_suppliers = [supplier for supplier in self.onlyreg if current_text.lower() in supplier.lower()]
            self.Regtext1['values'] = filtered_suppliers
    def filter_customer_list(self,event):
       # Function to filter supplier list based on user input
        current_text = self.custext2.get()
        if current_text == '':
            self.custext2['values'] = self.Customer_detailsonly
        else:
            filtered_suppliers = [supplier for supplier in self.Customer_detailsonly if current_text.lower() in supplier.lower()]
            self.custext2['values'] = filtered_suppliers
       

    

    #opening an another window from first page icons 
    def open_icon_window(self, index):
        if index == 2:
            self.open_registration_window()
        elif index == 1:
            self.close_the_window()
        elif index==3:
           username=getuser()
           if KBACKEND.is_authority_level_sufficienttwo(username):
            self.open_costlines_without_incidents()
            self.root.iconify()
           else:
              messagebox.showwarning("Warning","The user is unable to create purchase orders unless an incident is linked.")
        elif index==4:
           self.open_purchase_history_page()
           self.root.iconify()
    
    
        # Add more conditions for other icons as needed
    
    #=======================Second page which is icon_2 window starts=====================#
    #Creating a registration window
    def open_registration_window(self):
     self.registration_window = tk.Toplevel(self.root)
     self.registration_window.title("Find Customer")
     self.registration_window.geometry("300x70")
     self.registration_window.resizable(False, False)

      # Get the dimensions of the main window
     main_window_width = self.root.winfo_width()
     main_window_height = self.root.winfo_height()

     # Calculate the center coordinates
     x = self.root.winfo_rootx() + main_window_width // 2 - 150
     y = self.root.winfo_rooty() + main_window_height // 2 - 35

     # Set the registration window's geometry to be positioned at the center
     self.registration_window.geometry(f"+{x}+{y}")

    # Create label and entry field for registration number
     label = Label(self.registration_window, text="Enter Registration No:")
     label.grid(row=0, column=0)

     self.entry = Entry(self.registration_window)
     self.entry.grid(row=0, column=1)
     self.entry.focus_set()

        # Create buttons
     ok_button = Button(self.registration_window, text="OK", command= self.populate_registration)
     ok_button.grid(row=1, column=0)
     self.registration_window.bind('<Return>', self.on_enter_pressed)

     cancel_button = Button(self.registration_window, text="Cancel", command=self.registration_window.destroy)
     cancel_button.grid(row=1, column=1)

    def on_enter_pressed(self, event):
        self.populate_registration()
    
    #Making the entered registration number to populate in my registration number field in incident form
    def populate_registration(self):
        reg_no=self.entry.get()
        if reg_no:
         result = KBACKEND.fetch_details_from_database(reg_no)
        if result:
            self.registration_window.destroy()
            self.root.iconify()
            self.open_icon1_window(reg_no)  
        # Populate Entry widgets with fetched details
            self.text1.delete(0, tk.END)
            self.text2.delete(0,tk.END)
            self.Fleet_entry.delete(0, tk.END)
            self.Customer_Identry.delete(0, tk.END)
            self.Cust_Name_Entry.delete(0, tk.END)
            self.Contract_No_Entry.delete(0, tk.END)
            self.location_1.delete(0, tk.END)
            self.Depotentry.delete(0, tk.END)

            self.text1.insert(0, result[0])
            self.text1.state(['disabled'])
            self.Fleet_entry.insert(0, result[1])
            self.Fleet_entry.state(['disabled'])
            self.text2.insert(0,result[2])
            self.text2.state(['disabled'])
            self.location_1.insert(0,result[8])
            self.populate_location_description()

            self.Customer_Identry.insert(0, result[4] if result[4] is not None else"")
            
            self.Cust_Name_Entry.insert(0,result[7] if result[7] is not None else "") 
            self.Contract_No_Entry.insert(0,result[3] if result[3] is not None else"")
            self.Depotentry.insert(0,result[9] if result[9] is not None else"")

            fleetno= self.Fleet_entry.get()
            result=KBACKEND.getmileage(fleetno)

            self.Odo.delete(0, tk.END)

            self.Odo.insert(0, result[0] )

            self.Initial_Odo_Value= result[0]
            #self.Odo.state(['disabled'])
            
            
            result=KBACKEND.generate_new_i_number()

            KBACKEND.save_the_incidentnumber(result,reg_no)

            

        else:
            messagebox.showwarning("Warning", "Invalid registration number.")
            #self.registration_window.destroy()

        #else:
            #messagebox.showwarning("Warning", "Please enter a registration number.")

    
    def open_icon1_window(self, reg_no):
     
     self.widgetstwotab=[]
     self.icon1_window= tk.Toplevel(self.root)
     self.icon1_window.title("Incident Detail Form")
     self.icon1_window.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

     # Set the position of the registration window to be relative to the main window
     self.icon1_window.geometry(f"800x660+{offset_x}+{offset_y}")
 
    #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.icon1_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

    # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon14.png", "icon15.png", "icon16.png","icon17.png"]
     tooltips = ["Exit the window", "Save","Create an Event","Open Purchase History"]
     for idb, (path, tooltip_text) in enumerate(zip(image_paths,tooltips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idb: self.open_icon_windowsecond(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)
    
    
    # Create frames for each page
         self.main_page = Frame(self.icon1_window)
         self.events_page = Frame(self.icon1_window)
         self.postincident_page = Frame(self.icon1_window)

    # Function to show main page
     def show_main_page():
        self.main_page.pack(fill="both", expand=True)
        self.events_page.pack_forget()
        self.postincident_page.pack_forget()

    # Function to show events page
     def show_events_page():
      self.main_page.pack_forget()
      self.postincident_page.pack_forget()
      self.open_next_window()
      result=KBACKEND.retrieve_last_incident_pks()
      if result[0] and result[1] and result[2] and result[3] and result[4] and result[5] is not None:
             self.events_page.pack(fill="both", expand=True)
      else:
               self.icon1_window.lift()  # Bring the main window to the top
               self.icon1_window.attributes('-topmost', True)
               messagebox.showwarning(
               "Missing Information", 
               "All required fields (Contact Method ID, Category, Incident Loc, Recharge and Type) must be entered before saving. Please complete all details.",
               parent=self.icon1_window                    )
               self.icon1_window.attributes('-topmost', False) 
               self.events_page.destroy()
               self.main_page.pack(fill="both", expand=True)

     def show_postincident_page():
      self.main_page.pack_forget()
      self.events_page.pack_forget()
      self.postincident_page.pack(fill="both",expand=True)
      self.open_next_window()
    
     show_main_page()

      #Creating Buttons Frame for second pagE
     Buttonframe= Frame(self.icon1_window, relief=tk.RIDGE,)
     Buttonframe.place(x=0,y=27,width=780,height=40)

    # Create buttons
     main_button = tk.Button(Buttonframe, text="MAIN", command=show_main_page)
     main_button.pack(side=tk.LEFT, padx=1, pady=2)

     events_button = tk.Button(Buttonframe, text="EVENTS", command=show_events_page)
     events_button.pack(side=tk.LEFT, padx=1, pady=2)

     Post_button = tk.Button(Buttonframe, text="VIEW POST REPORT", command=show_postincident_page)
     Post_button.pack(side=tk.LEFT, padx=1, pady=2)

     # Variable to track the state of the big button (NO VOR / IN VOR)
     self.big_button_var = tk.StringVar(value="N")  # Default to "N"

        # Create a big button that changes text and color when clicked
     self.big_button = tk.Button(Buttonframe, text="NO VOR", bg="green", fg="white", 
                                    command=self.toggle_vor_button,width=30,font=("Helvetica", 12, "bold"))
     self.big_button.pack(side=tk.LEFT, padx=50, pady=2)  

     self.post_incident_reports=tk.Button(Buttonframe, text="Post Incident Reports",command=self.post_incident_reports_action)
     #post_incident_reports.pack(side=tk.RIGHT,padx=1,pady=2)

    # Main page components
     #First Data Frame for Vehicle Details
     dataframe = LabelFrame(self.main_page, bd=3, relief=tk.RIDGE,text="Vehicle Details")
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=29, width=780, height=100) 

     # Assuming you have a list of registration numbers
     Reg_no = Label(dataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.text1 = ttk.Entry(dataframe,width=15)
     #self.text1.insert(0, reg_no)
     self.text1.grid(row=0, column=1)
     self.attach_context_menu(self.text1)
     
     #Creating an Entry for page 2
     self.text2 = ttk.Entry(dataframe, width=30)
     self.text2.grid(row=0, column=2,padx=70)
     self.attach_context_menu(self.text2)
     
     #Creating a Label and Entry for Driver name:

     self.lb3 = Label(dataframe, text="Driver name:",fg="Red")
     #self.lb3.grid(row=0, column=3)
     self.Driverentry = Entry(dataframe, width=18)
     #self.Driverentry.grid(row=0, column=4)
     self.attach_context_menu(self.Driverentry)

     #Creating a Label and Entry for Fleet No:
     Fleet_No=Label(dataframe, text="Fleet No:")
     Fleet_No.grid(row=1, column=0,pady=6)
     self.Fleet_entry=ttk.Entry(dataframe,width=15)
     self.Fleet_entry.grid(row=1,column=1)
     self.attach_context_menu(self.Fleet_entry)

     #Button to view fleet information.

     self.view_fleet = Button(dataframe, text="View fleet info",width=12,command=self.open_fleet_info)
     self.view_fleet.grid(row=2, column=0,padx=20)
     self.base_url = "http://igloouk/Igloo"

     #Creating a Label and Entry for Vehicle loaded:
     vehicle=Label(dataframe,text="Vehicle Loaded")
     vehicle.grid(row=2,column=1,padx=10) 
     self.Vehicle_loaded_var= tk.BooleanVar()
     self.Vehicle_loaded=Checkbutton(dataframe,width=2,variable=self.Vehicle_loaded_var)
     self.Vehicle_loaded.grid(row=2,column=2,sticky='w')
     

     
     
     #Creating a Label and Entry for Driver Phone:

     self.lb3phone = Label(dataframe, text="Phone:",fg="Red")
     #self.lb3phone.grid(row=1, column=3)
     self.Driverphone = Entry(dataframe, width=18)
     #self.Driverphone.grid(row=1, column=4)
     self.attach_context_menu(self.Driverphone)
    
     #Second Data Frame for Customer and Company Details 
     Customer= LabelFrame(self.main_page, bd=3, relief=tk.RIDGE,text="Customer/Company Details")
     Customer.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Customer.place(x=0,y=130,width=780,height=100)

     #Creating Label for ID and entry
     self.Custidandcustnameinfo=KBACKEND.fetch_all_the_cust_details()
     self.Custidonly=[row[0] for row in self.Custidandcustnameinfo]
     Customer_Id = Label(Customer, text="Customer ID:", padx=3, pady=3)
     Customer_Id.grid(row=0, column=0)
     self.Customer_Identry= ttk.Combobox(Customer, width=14,values=self.Custidonly)
     self.Customer_Identry.grid(row=0, column=1)
     self.Customer_Identry.focus_set()
     self.Customer_Identry.bind("<KeyRelease>", self.filter_custid_list)
     self.Customer_Identry.bind("<<ComboboxSelected>>", self.populate_custname_basedon_id)
     self.attach_context_menu(self.Customer_Identry)

     #Creating Label for Cust_Name and entry
    
     self.Custnameonly=[row[1] for row in self.Custidandcustnameinfo]
     Cust_Name = Label(Customer, text="Name:", padx=3, pady=3)
     Cust_Name.grid(row=0, column=2)
     self.Cust_Name_Entry= ttk.Combobox(Customer, width=14,values=self.Custnameonly)
     self.Cust_Name_Entry.grid(row=0, column=3)
     self.Cust_Name_Entry.bind("<KeyRelease>", self.filter_custname_list)
     self.Cust_Name_Entry.bind("<<ComboboxSelected>>", self.populate_custid_basedon_name)
     self.attach_context_menu(self.Cust_Name_Entry)   
     #Creating Label for Contract_No and Entry
     
     Contract_No = Label(Customer, text="Contract No:", padx=3, pady=3)
     Contract_No.grid(row=0, column=4)
     self.Contract_No_Entry= Entry(Customer, width=14)
     self.Contract_No_Entry.grid(row=0, column=5)
     self.attach_context_menu(self.Contract_No_Entry)
     
      #Creating Label for Contact_Tel and Entry

     self.Contact_Tel = Label(Customer, text="Contact Tel:", padx=3, pady=3,fg="red")
     self.Contact_Tel.grid(row=1, column=2)
     self.Contact_Tel_Entry= Entry(Customer, width=16)
     self.Contact_Tel_Entry.grid(row=1, column=3)
     self.attach_context_menu(self.Contact_Tel_Entry)

    #Creating Label for Contact_Email and Entry

     self.Contact_Email = Label(Customer, text="Contact Email:", padx=3, pady=3,fg="red")
     self.Contact_Email.grid(row=1, column=4)
     self.Contact_Email_Entry= Entry(Customer, width=14)
     self.Contact_Email_Entry.grid(row=1, column=5)
     self.attach_context_menu(self.Contact_Email_Entry)

      #Creating Label for Contact_Email and Entry

     Contact_Name_Label=Label(Customer, text="Contact Name:",fg='red', padx=3, pady=3)
     Contact_Name_Label.grid(row=0, column=6)
     self.Contact_Name_Entry= Entry(Customer, width=14)
     self.Contact_Name_Entry.grid(row=0, column=7)
     self.attach_context_menu(self.Contact_Name_Entry)

     #Creating Label for Customer_Defect_No and Entry

     Customer_DefNO=Label(Customer, text="Cust Def_No:", padx=3, pady=3)
     Customer_DefNO.grid(row=1, column=6)
     self.Customer_defno_Entry= Entry(Customer, width=14)
     self.Customer_defno_Entry.grid(row=1, column=7)
     self.attach_context_menu(self.Customer_defno_Entry)

      #Creating Label for Order_No and Entry

     #Creating Label for Contact_Method_ID AND Entry
     self.contactmeth= KBACKEND.fetch_contact_detais()
     self.contactdetails= [row[1] for row in self.contactmeth]
     Contact_Method_Id=Label(Customer,text="Contact Method ID*:",fg="red",padx=3,pady=3)
     Contact_Method_Id.grid(row=1,column=0)
     self.Contact_Method_Entry=ttk.Combobox(Customer,width=14,values=self.contactdetails)
     self.Contact_Method_Entry.grid(row=1,column=1)
     self.attach_context_menu(self.Contact_Method_Entry)
     #self.Contact_Method_Entry.bind("<<ComboboxSelected>>", self.on_contact_method_selected)

     #Creating Label for Depot
     Depot=Label(Customer,text="Customer Depot",padx=3,pady=3)
     Depot.grid(row=2,column=0)
     self.Depotentry=Entry(Customer,width=16)
     self.Depotentry.grid(row=2,column=1)
     self.attach_context_menu(self.Depotentry)

     #Creating a frame for incident details 
      
     Incident_details= LabelFrame(self.main_page, bd=3, relief=tk.RIDGE,text="Incident Details")
     Incident_details.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_details.place(x=0,y=230,width=780,height=345)

     #Creating a label and entry field for location
     Location= Label(Incident_details, text="Location:")
     Location.grid(row=0, column=0,pady=(0,25),sticky='w')
     self.locaentry= Text(Incident_details,width=40, height='3',wrap='word')
     self.locaentry.grid(row=0,column=1,columnspan=2,sticky='w')
     self.attach_context_menu(self.locaentry)
     
     self.view_map = Button(Incident_details, text="View map",width=12,command=self.open_map)
     self.view_map.grid(row=0, column=2,padx=3)
     self.home_url = "https://www.google.com/maps"
     #Creating a label and Entry for Number

     Number= Label(Incident_details,text="Number:")
     Number.grid(row=0,column=3,padx=1)
     self.Numberentry=Entry(Incident_details,width=15)
     gen_number=KBACKEND.generate_new_i_number()
     self.Numberentry.insert(0, gen_number)
     self.Numberentry.grid(row=0,column=4)
     self.attach_context_menu(self.Numberentry)
     
     #Creating Label and Entry for Date
     Date = Label(Incident_details, text="Date", padx=5)
     Date.grid(row=1, column=3,padx=20,pady=4)
     self.datee= DateEntry(Incident_details, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.datee.grid(row=1, column=4,sticky='w')
     self.attach_context_menu(self.datee)

     current_time = datetime.now().strftime("%H:%M")
     Time= Label(Incident_details,text= "Time",padx=5)
     Time.grid(row=2,column=3)
     self.modifiedtime= ttk.Entry(Incident_details,width=15)
     self.modifiedtime.grid(row=2, column=4,sticky='w')
     self.modifiedtime.insert(0,current_time)
     self.modifiedtime.config(state='readonly')  # Make the entry readonly
     # Bind the Entry widget to open time picker on click
     self.modifiedtime.bind("<Button-1>", self.open_time_picker)
     

     #Creating Label and Entry for Time 
     current_user=getuser()
     Created_by = Label(Incident_details, text="Created By", padx=5)
     Created_by.grid(row=3, column=3)
     self.Time= ttk.Entry(Incident_details, width=15)
     self.Time.grid(row=3, column=4,sticky='w')
     self.Time.insert(0,current_user)
     self.Time.state(['disabled'])
     self.attach_context_menu(self.Time)


     #Creating Label and Entry for Odometer

     Odo= Label(Incident_details, text="Odometer", padx=5)
     Odo.grid(row=4, column=3)
     self.Odo= ttk.Entry(Incident_details, width=13)
     self.Odo.grid(row=4, column=4,sticky='w')
     self.Odo.bind("<FocusOut>", self.validate_odo)
     self.Odo.bind("<Double-1>", self.reset_odo) 
     self.attach_context_menu(self.Odo)
     
     

     #Creating Lable and Entry for Location:
     # Define the label
     self.Loca = tk.Label(Incident_details, text="Depot Loc:", padx=5)
     self.Loca.grid(row=5, column=3)

    # Define locaentry
     # Fetch data from the database using backend function
     rows = KBACKEND.fetch_locations_and_descriptions()
     self.locations = [row[0] for row in rows]  # First column values for dropdown

        # Define loca label

        # Define loca combobox
     self.location_1 = ttk.Combobox(Incident_details, values=self.locations, width=15)
     self.location_1.grid(row=5, column=4, sticky='w')
     self.attach_context_menu(self.location_1)
     

        # Define loca entry
     self.location_2 = tk.Entry(Incident_details, width=15)
     self.location_2.grid(row=6, column=4, sticky='w', columnspan=4)
     self.attach_context_menu(self.location_2)

     self.location_1.bind("<<ComboboxSelected>>", self.populate_location_description)
     

     #Creating a Lable and Entry for Type

     self.Catdetails=KBACKEND.fetch_cat_details()
     self.catdesc=[row[1] for row in self.Catdetails]
     

     Type= Label(Incident_details, text="Category *:",fg="red")
     Type.grid(row=1,column=0,padx=5,pady=6)
     self.CatEntry= ttk.Combobox(Incident_details, values=self.catdesc, width=13)
     self.CatEntry.grid(row=1, column=1, pady=4, sticky='w')
     self.attach_context_menu(self.CatEntry)
     
     loctype= Label(Incident_details, text="Incident Loc *:",fg="red")
     loctype.grid(row=2,column=0,padx=5,pady=6)
     self.Locdetils=KBACKEND.fetch_Location_details()
     self.locdesc= [row[1] for row in self.Locdetils]
     self.LolEntry=ttk.Combobox(Incident_details,values=self.locdesc,width=13)
     self.LolEntry.grid(row=2,column=1,pady=4,sticky='w')
     self.LolEntry.bind("<<ComboboxSelected>>", self.on_location_selected)
     self.attach_context_menu(self.LolEntry)

     Chartype= Label(Incident_details, text="Recharge *:",fg="red")
     Chartype.grid(row=3,column=0,padx=5,pady=2)
     self.Chardetails=KBACKEND.fetch_charge_details()
     self.chardesc=[row[1] for row in self.Chardetails]
     self.Chargeentry=ttk.Combobox(Incident_details,values=self.chardesc,width=13)
     self.Chargeentry.grid(row=3,column=1,pady=2,sticky='w')
     self.Chargeentry.bind("<<ComboboxSelected>>", self.on_recharge_selected)
     self.attach_context_menu(self.Chargeentry)
     
     Incidenttype= Label(Incident_details, text="Type *:",fg="red")
     Incidenttype.grid(row=4,column=0,padx=5,pady=2)
     self.Typedetails=KBACKEND.fetch_Incidenttype_details()
     self.Typedetailsdesc=[row[1] for row in self.Typedetails]
     self.Incitypeentry=ttk.Combobox(Incident_details,values=self.Typedetailsdesc,width=13)
     self.Incitypeentry.grid(row=4,column=1,pady=2,sticky='w')


     #Creating a Label and Entry for Fault Description
     Fault= Label(Incident_details, text="Fault Desription:")
     Fault.grid(row=5, column=0, pady=(0,25),sticky='w')
     self.Faultentry= Text(Incident_details,width=40, height='3',wrap='word')
     self.Faultentry.grid(row=5,column=1,sticky='w')
     self.attach_context_menu(self.Faultentry)
     

     #Creating a Lable and Entry for Status
     self.statrows=KBACKEND.fetch_status_details()
     self.statusdescription= [row[1] for row in self.statrows]
     Statuss= Label(Incident_details, text="Status *:",fg="red")
     Statuss.grid(row=6,column=0,padx=2)
     self.StatussEntry= ttk.Combobox(Incident_details, values=self.statusdescription, width=25)
     self.StatussEntry.grid(row=6, column=1, padx=2,pady=2, sticky='w')
     self.StatussEntry.bind('<<ComboboxSelected>>', self.on_status_selected)
     self.on_status_selected()
     self.attach_context_menu(self.StatussEntry)


     #Creating Label and Entry for Attendance Deferred
     

     self.Attendance_Def= Label(Incident_details, text="Attendance_Deferred")
     #Attendance_Def.grid(row=6,column=0)
     self.attendance_var=tk.BooleanVar()
     self.AttendanceEntry= ttk.Checkbutton(Incident_details, variable=self.attendance_var)
     #self.AttendanceEntry.grid(row=6, column=1, sticky='w')
     
     self.Deff = Label(Incident_details, text='Deferred To')
     #Deff.grid(row=7, column=0, padx=2, sticky='w')
     today = datetime.today().date()
     self.Deferred_To = DateEntry(Incident_details, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy',mindate=today)
     #self.Deferred_To.grid(row=7, column=1, padx=2, sticky='w')
     self.attach_context_menu(self.Deferred_To)
     

     self.Deff_time=Label(Incident_details,text='Deferred To Time')
     #Deff_time.grid(row=8,column=0,padx=2, sticky='w')
     self.Deferred_Time= Entry(Incident_details,width=15)
     #self.Deferred_Time.grid(row=8,column=1,sticky='w')
     current_time = datetime.now().strftime("%H:%M")
     self.Deferred_Time.insert(0,current_time)
     self.Deferred_Time.bind("<Button-1>", self.open_time_picker_deff)
     self.attach_context_menu(self.Deferred_Time)

     whatwords = Label(Incident_details, text='Defect_loc_W3W')
     whatwords.grid(row=7, column=3 ,sticky='w')
     self.whatwordsentry = Entry(Incident_details, width=20)
     self.whatwordsentry.grid(row=7, column=4,sticky='w')  # Set columnspan to 2
     self.attach_context_menu(self.whatwordsentry)

     self.what= tk.Button(Incident_details, text="View map", width=12,command=self.open_what_map)
     self.what.grid(row=8, column=4, columnspan=2, pady=5)
     self.what_url = "https://what3words.com"

     self.on_location_selected()
   
    #Creating Frame for Supplier details
     Supplier_details=LabelFrame(self.main_page,bd=3,relief=tk.RIDGE,text="Supplier Details")
     Supplier_details.pack(side=tk.TOP,padx=8,pady=3, anchor="nw")
     Supplier_details.place(x=0,y=575,width=780,height=50)

     #Creating label and Entry for Name:
     sup=KBACKEND.fetch_supplier_details()
     self.supplier = [row[1] for row in sup]

     Namesup= Label(Supplier_details, text="Supplier No:")
     Namesup.grid(row=0,column=2,padx=5)
     self.nameentry= ttk.Entry(Supplier_details,width=30)
     self.nameentry.grid(row=0,column=3,padx=5)
     self.attach_context_menu(self.nameentry)
     
      #Creating label and Entry for Contat:
     Contactsup= Label(Supplier_details, text="Supplier Name:")
     Contactsup.grid(row=0,column=0,padx=5,pady=5)
     self.Contactentry= ttk.Combobox(Supplier_details,values=self.supplier,width=30)
     self.Contactentry.grid(row=0,column=1,padx=5,pady=5)
     self.attach_context_menu(self.Contactentry)
     self.Contactentry.bind("<KeyRelease>", self.filter_supplier_list)
     self.Contactentry.bind("<<ComboboxSelected>>", self.populate_supplier_details)

     #Creating Label and Entry for phone 

     Phonesup= Label(Supplier_details, text="Phone:")
     Phonesup.grid(row=0,column=4,padx=5)
     self.Phoneentry= ttk.Entry(Supplier_details,width=20)
     self.Phoneentry.grid(row=0,column=5,padx=5)
     self.attach_context_menu(self.Phoneentry)

     self.widgetstwotab.append(self.Customer_Identry)
     self.widgetstwotab.append(self.Cust_Name_Entry)
     self.widgetstwotab.append(self.Contract_No_Entry)
     self.widgetstwotab.append(self.Contact_Name_Entry)
     self.widgetstwotab.append(self.Contact_Method_Entry)
     self.widgetstwotab.append(self.Contact_Tel_Entry)
     self.widgetstwotab.append(self.Contact_Email_Entry)
     self.widgetstwotab.append(self.Customer_defno_Entry)
     self.widgetstwotab.append(self.Depotentry)
     self.widgetstwotab.append(self.locaentry)
     self.widgetstwotab.append(self.view_map)
     self.widgetstwotab.append(self.Numberentry)
     self.widgetstwotab.append(self.CatEntry)
     self.widgetstwotab.append(self.datee)
     self.widgetstwotab.append(self.LolEntry)
     self.widgetstwotab.append(self.modifiedtime)
     self.widgetstwotab.append(self.Chargeentry)
     self.widgetstwotab.append(self.Time)
     self.widgetstwotab.append(self.Incitypeentry)
     self.widgetstwotab.append(self.Odo)
     self.widgetstwotab.append(self.Faultentry)
     self.widgetstwotab.append(self.location_1)
     self.widgetstwotab.append(self.StatussEntry)
     self.widgetstwotab.append(self.location_2)
     self.widgetstwotab.append(self.Attendance_Def)
     self.widgetstwotab.append(self.whatwordsentry)
     self.widgetstwotab.append(self.what)
     self.widgetstwotab.append(self.Deferred_To)
     self.widgetstwotab.append(self.Deferred_Time)
     self.widgetstwotab.append(self.Contactentry)
     self.widgetstwotab.append(self.nameentry)
     self.widgetstwotab.append(self.Phoneentry)

     for widget in self.widgetstwotab:
            widget.bind("<Tab>", self.focus_next_widgetone)
            widget.bind("<Shift-Tab>", self.focus_previous_widgetone)

     
    # Events page components
     EventsFrame= LabelFrame(self.events_page, relief=tk.RIDGE,text="Events")
     EventsFrame.place(x=0,y=30,width=780,height=500)
    
     
     self.events_tree = ttk.Treeview(EventsFrame, columns=("Created", "Time1", "By1", "Event Type", "Event Action", "Notes", "Last Updated", "Time2","By2", "Follow-Up", "Time3","By3", "Action"),show="headings")
     self.events_tree.pack(fill="both", expand=True)

     self.events_tree.heading("Created", text="Created")
     self.events_tree.heading("Time1", text="Time1")
     self.events_tree.heading("By1", text="By1")
     self.events_tree.heading("Event Type", text="Event Type")
     self.events_tree.heading("Event Action", text="Event Action")
     self.events_tree.heading("Notes", text="Notes")
     self.events_tree.heading("Last Updated", text="Last Updated")
     self.events_tree.heading("Time2", text="Time2")
     self.events_tree.heading("By2",text="By2")
     self.events_tree.heading("Follow-Up", text="Follow-Up")
     self.events_tree.heading("Time3", text="Time3")
     self.events_tree.heading("By3",text="By3")
     self.events_tree.heading("Action", text="Action")

     self.events_tree.column("Created", width=90)
     self.events_tree.column("Time1", width=70)
     self.events_tree.column("By1", width=60)
     self.events_tree.column("Event Type", width=80)
     self.events_tree.column("Event Action", width=80)
     self.events_tree.column("Notes", width=200)
     self.events_tree.column("Last Updated", width=90)
     self.events_tree.column("Time2", width=70)
     self.events_tree.column("By2",width=60)
     self.events_tree.column("Follow-Up", width= 70)
     self.events_tree.column("Time3",width= 70)
     self.events_tree.column("By3",width= 60)
     self.events_tree.column("Action",width= 70)
     

     #Simulate adding some data to the tree
     self.scrollbar_y = ttk.Scrollbar(EventsFrame, orient="vertical", command=self.events_tree.yview)
     self.scrollbar_y.pack(side="right", fill="y")
     self.events_tree.configure(yscrollcommand=self.scrollbar_y.set)

     self.scrollbar_x = ttk.Scrollbar(EventsFrame, orient="horizontal", command=self.events_tree.xview)
     self.scrollbar_x.pack(side="bottom", fill="x")
     self.events_tree.configure(xscrollcommand=self.scrollbar_x.set)

     PostincidentFrame= LabelFrame(self.postincident_page, relief=tk.RIDGE,text="Post Incident Report")
     PostincidentFrame.place(x=0,y=30,width=780,height=300)

     self.Post_incident_tree = ttk.Treeview(PostincidentFrame, columns=("Incident_Number","Date","Time","Created By","Incident Category","Comments"),show="headings")
     self.Post_incident_tree.pack(fill="both", expand=True)

     self.Post_incident_tree.heading("Incident_Number", text="Incident_Number")
     self.Post_incident_tree.heading("Date", text="Date")
     self.Post_incident_tree.heading("Time", text="Time")
     self.Post_incident_tree.heading("Created By", text="Created By")
     self.Post_incident_tree.heading("Incident Category", text="Incident Category")
     self.Post_incident_tree.heading("Comments", text="Comments")
     

     self.Post_incident_tree.column("Incident_Number", width=90)
     self.Post_incident_tree.column("Date", width=70)
     self.Post_incident_tree.column("Time", width=60)
     self.Post_incident_tree.column("Created By", width=80)
     self.Post_incident_tree.column("Incident Category", width=80)
     self.Post_incident_tree.column("Comments", width=200)
     self.Post_incident_tree.bind("<<TreeviewSelect>>",self.clicking_the_postreportsone)
    
    def focus_next_widgetone(self, event):
        """Move focus to the next widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetstwotab.index(widget)
        next_index = (current_index + 1) % len(self.widgetstwotab)
        self.widgetstwotab[next_index].focus_set()
        return "break"  # Prevent default behavior

    def focus_previous_widgetone(self, event):
        """Move focus to the previous widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetstwotab.index(widget)
        previous_index = (current_index - 1) % len(self.widgetstwotab)
        self.widgetstwotab[previous_index].focus_set()
        return "break"
    
    def filter_custid_list(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Customer_Identry.get()
        if current_text == '':
            self.Customer_Identry['values'] = self.Custidonly
        else:
            filtered_suppliers = [supplier for supplier in self.Custidonly if current_text.lower() in supplier.lower()]
            self.Customer_Identry['values'] = filtered_suppliers

    def filter_custname_list(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Cust_Name_Entry.get()
        if current_text == '':
            self.Cust_Name_Entry['values'] = self.Custnameonly
        else:
            filtered_suppliers = [supplier for supplier in self.Custnameonly if current_text.lower() in supplier.lower()]
            self.Cust_Name_Entry['values'] = filtered_suppliers
    def populate_custname_basedon_id(self,event):
       selected_supplier= self.Customer_Identry.get()
       rows=KBACKEND.fetch_all_the_cust_details()
       for row in rows:
           if row[0]==selected_supplier:
              self.Cust_Name_Entry.delete(0,tk.END)
              self.Cust_Name_Entry.insert(0,row[1])
    def populate_custid_basedon_name(self,event):
       selected_supplier= self.Cust_Name_Entry.get()
       rows=KBACKEND.fetch_all_the_cust_details()
       for row in rows:
           if row[1]==selected_supplier:
              self.Customer_Identry.delete(0,tk.END)
              self.Customer_Identry.insert(0,row[0])
     
    def open_fleet_info(self):
            webbrowser.open(self.base_url)
    def open_map(self):
        address = self.locaentry.get("1.0", tk.END).strip()  # Get the text from the Text widget
        if not address:
            webbrowser.open(self.home_url)
        else:
            formatted_address = address.replace(" ", "+")
            map_url = f"https://www.google.com/maps/search/?api=1&query={formatted_address}"
            webbrowser.open(map_url)
    def open_what_map(self):
        address = self.whatwordsentry.get().strip()  # Get the text from the Entry widget
        if not address:
            webbrowser.open(self.what_url)
        else:
            formatted_address = address.replace(" ", ".")
            map_url = f"https://what3words.com/{formatted_address}"
            webbrowser.open(map_url)
    def filter_supplier_list(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Contactentry.get()
        if current_text == '':
            self.Contactentry['values'] = self.supplier
        else:
            filtered_suppliers = [supplier for supplier in self.supplier if current_text.lower() in supplier.lower()]
            self.Contactentry['values'] = filtered_suppliers
    def open_time_picker(self, event):
        # Create new window for time selection
        self.time_window = tk.Toplevel(self.root)
        self.time_window.title("Select Time")
        self.time_window.grab_set()  # Ensure the popup is modal (prevents interaction with the main window)

        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
        offset_x = root_x + 50  # You can adjust this offset value
        offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
        self.time_window.geometry(f"250x170+{offset_x}+{offset_y}")

        # Styling the popup window (Center alignment, padding)
        self.time_window.configure(bg="lightblue")
        frame = ttk.Frame(self.time_window, padding=10)
        frame.grid(row=0, column=0, padx=20, pady=20)

        # Hour and Minute selection
        hours = [f"{i:02}" for i in range(24)]  # Hours: 00 to 23
        minutes = [f"{i:02}" for i in range(0, 60, 5)]  # Minutes: 00, 05, 10, ..., 55

        # Dropdown for Hour
        ttk.Label(frame, text="Hour").grid(row=0, column=0, padx=5, pady=5, sticky='w')
        self.hour_combobox = ttk.Combobox(frame, values=hours, width=5)
        self.hour_combobox.grid(row=0, column=1, padx=5, pady=5)
        self.hour_combobox.set(datetime.now().strftime("%H"))

        # Dropdown for Minute
        ttk.Label(frame, text="Minute").grid(row=1, column=0, padx=5, pady=5, sticky='w')
        self.minute_combobox = ttk.Combobox(frame, values=minutes, width=5)
        self.minute_combobox.grid(row=1, column=1, padx=5, pady=5)
        self.minute_combobox.set(datetime.now().strftime("%M"))

        # Confirm Button to set the selected time
        confirm_button = ttk.Button(self.time_window, text="Set Time", command=self.set_time)
        confirm_button.grid(row=2, column=0, padx=10, pady=10)

        # Make the popup movable and independent
        
        self.time_window.grab_set()  # Prevent interaction with main window until popup is closed
        
    # Function to set the time in the entry box
    def set_time(self):
        selected_hour = self.hour_combobox.get()
        selected_minute = self.minute_combobox.get()

        # Format time as HH:MM
        formatted_time = f"{selected_hour}:{selected_minute}"

        # Set the formatted time in the modifiedtime entry and close the popup
        self.modifiedtime.config(state='normal')  # Allow editing temporarily
        self.modifiedtime.delete(0, tk.END)  # Clear current value
        self.modifiedtime.insert(0, formatted_time)  # Insert selected time
        self.modifiedtime.config(state='readonly')  # Make it readonly again

        # Close the popup window
        self.time_window.destroy()
      
    def open_time_picker_deff(self, event):
        # Create new window for time selection
        self.time_windowdeff = tk.Toplevel(self.root)
        self.time_windowdeff.title("Select Time")
        self.time_windowdeff.grab_set()

        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
        offset_x = root_x + 50  # You can adjust this offset value
        offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
        self.time_windowdeff.geometry(f"250x170+{offset_x}+{offset_y}")

        # Styling the popup window (Center alignment, padding)
        self.time_windowdeff.configure(bg="lightblue")
        frame = ttk.Frame(self.time_windowdeff, padding=10)
        frame.grid(row=0, column=0, padx=20, pady=20)

        # Hour and Minute selection
        hours = [f"{i:02}" for i in range(24)]  # Hours: 00 to 23
        minutes = [f"{i:02}" for i in range(0, 60, 5)]  # Minutes: 00, 05, 10, ..., 55

        # Dropdown for Hour
        ttk.Label(frame, text="Hour").grid(row=0, column=0, padx=5, pady=5, sticky='w')
        self.hour_comboboxdeff = ttk.Combobox(frame, values=hours, width=5)
        self.hour_comboboxdeff.grid(row=0, column=1, padx=5, pady=5)
        self.hour_comboboxdeff.set(datetime.now().strftime("%H"))

        # Dropdown for Minute
        ttk.Label(frame, text="Minute").grid(row=1, column=0, padx=5, pady=5, sticky='w')
        self.minute_comboboxdeff = ttk.Combobox(frame, values=minutes, width=5)
        self.minute_comboboxdeff.grid(row=1, column=1, padx=5, pady=5)
        self.minute_comboboxdeff.set(datetime.now().strftime("%M"))

        # Confirm Button to set the selected time
        confirm_button = ttk.Button(self.time_windowdeff, text="Set Time", command=self.set_timedeff)
        confirm_button.grid(row=2, column=0, padx=10, pady=10)

        # Make the popup movable and independent
        
        self.time_windowdeff.grab_set()  # Prevent interaction with main window until popup is closed
        
    # Function to set the time in the entry box
    def set_timedeff(self):
        selected_hour = self.hour_comboboxdeff.get()
        selected_minute = self.minute_comboboxdeff.get()

        # Format time as HH:MM
        formatted_time = f"{selected_hour}:{selected_minute}"

        # Set the formatted time in the modifiedtime entry and close the popup
        self.Deferred_Time.config(state='normal')  # Allow editing temporarily
        self.Deferred_Time.delete(0, tk.END)  # Clear current value
        self.Deferred_Time.insert(0, formatted_time)  # Insert selected time
        self.Deferred_Time.config(state='readonly')  # Make it readonly again

        # Close the popup window
        self.time_windowdeff.destroy()
    def toggle_vor_button(self):
     # Get the incident number from the entry field
     Incident_No = self.Numberentry.get()

     # Get the current state of the button and toggle it
     if self.big_button_var.get() == "N":
        # Button was in "NO VOR" state, change to "VOR" (red)
        self.big_button_var.set("Y")
        self.big_button.config(text="VOR", bg="red", fg="white",font=("Helvetica", 12, "bold"))
        
        # Create a new VOR event
        print("Creating a new VOR event...")
        self.create_event_listnew()
        KBACKEND.generate_event_number(Incident_No)

        # Date and time for event creation
        date_str = self.datee.get()  
        time_str = self.modifiedtime.get()
        datetime_str = f"{date_str} {time_str}"
        datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

        # Insert event details for VOR
        self.Event_type_entrynew.insert(0, "VOR")
        First_event_tostore = 13
        self.Event_details_entrynew.insert("1.0", "Vehicle VOR")
        Event_Notes = self.Event_details_entrynew.get("1.0", tk.END)

        # Set next event details
        self.Type_nextevent_entrynew.insert(0, "UPDATE")
        Second_event_tostore = 12

        # Handle follow-up datetime (add 30 minutes)
        datetime_objj = datetime.strptime(f"{self.datee.get()} {self.modifiedtime.get()}", "%d/%m/%Y %H:%M")
        datetime_objj_plus_30 = datetime_objj + timedelta(minutes=30)
        datetime_strr_plus_30 = datetime_objj_plus_30.strftime("%Y-%m-%d %H:%M:%S")

        # Get current user
        current_user = getuser()
        self.Action_required_entrynew.insert(0, current_user)
        Created_by = self.Action_required_entrynew.get()
        Ownerof = self.Owner_entrynew.get()

        # Store VOR event in the backend
        KBACKEND.store_event_detailstwoo(Incident_No, datetime_obj, First_event_tostore, Event_Notes,
                                         Second_event_tostore, datetime_strr_plus_30, Created_by, Ownerof)
        self.icon3_windownew.destroy()

     else:
        # Button was in "VOR" state, change to "NO VOR" (green)
        self.big_button_var.set("N")
        self.big_button.config(text="NOT VOR", bg="green", fg="white",font=("Helvetica", 12, "bold"))

        # Create a new NO VOR event
        print("Creating a new NO VOR event...")
        self.create_event_listnew()
        KBACKEND.generate_event_number(Incident_No)

        # Date and time for event creation
        date_str = self.datee.get()
        time_str = self.modifiedtime.get()
        datetime_str = f"{date_str} {time_str}"
        datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

        # Insert event details for NO VOR
        self.Event_type_entrynew.insert(0, "VOR")
        First_event_tostore = 13
        self.Event_details_entrynew.insert("1.0", "Vehicle NO VOR")
        Event_Notes = self.Event_details_entrynew.get("1.0", tk.END)

        # Set next event details
        self.Type_nextevent_entrynew.insert(0, "UPDATE")
        Second_event_tostore = 12

        # Handle follow-up datetime (add 30 minutes)
        datetime_objj = datetime.strptime(f"{self.datee.get()} {self.modifiedtime.get()}", "%d/%m/%Y %H:%M")
        datetime_objj_plus_30 = datetime_objj + timedelta(minutes=30)
        datetime_strr_plus_30 = datetime_objj_plus_30.strftime("%Y-%m-%d %H:%M:%S")

        # Get current user
        current_user = getuser()
        self.Action_required_entrynew.insert(0, current_user)
        Created_by = self.Action_required_entrynew.get()
        Ownerof = self.Owner_entrynew.get()

        # Store NO VOR event in the backend
        KBACKEND.store_event_detailstwoo(Incident_No, datetime_obj, First_event_tostore, Event_Notes,
                                         Second_event_tostore, datetime_strr_plus_30, Created_by, Ownerof)
        self.icon3_windownew.destroy()

    # Fetch and update event details in the tree
     event_details = KBACKEND.fetch_all_events(Incident_No)
     self.events_tree.delete(*self.events_tree.get_children())

     if event_details:
        for event in event_details:
            Event_created = event.get('Created')
            Created_date = Event_created.date()
            Created_time = Event_created.time()
            Notes = event.get('Notes')
            Last_updated = event.get('Last Updated')
            Last_updated_date = Last_updated.date()
            Last_updated_time = Last_updated.time()
            Follow_up = event.get('Follow up')
            Follow_up_date = Follow_up.date()
            follow_up_time = Follow_up.time()
            Event_Description = event.get('Event_Description')
            Next_Event_Description = event.get('Next_Event_Description')
            Created = event.get('Created_By')
            Own = event.get('Owner')

            self.events_tree.insert("", "end", values=(Created_date, Created_time, Created, Event_Description, "",
                Notes, Last_updated_date, Last_updated_time, Own, Follow_up_date, follow_up_time, Own, Next_Event_Description))
            
            self.events_tree.bind("<<TreeviewSelect>>", self.on_roww_selected)
        self.populate_eventstree_table()


    def post_incident_reports_action(self):
      self.open_next_window()
      self.post_window= tk.Toplevel(self.root)
      self.post_window.title("Post Incident Report Form")
      self.post_window.resizable(False,False)

      root_x = self.root.winfo_x()
      root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
      offset_x = root_x + 50  # You can adjust this offset value
      offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
      self.post_window.geometry(f"750x350+{offset_x}+{offset_y}")

      icon_box = tk.Frame(self.post_window, relief=tk.RIDGE, borderwidth=3)
      icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

      # You can add icons below menus using PhotoImage or other methods.
      # For demonstration purposes, let's create 13 small image icons.
      image_paths = ["icon14.png", "icon15.png"]
      tooltips = ["Exit the window", "Save"]
      for idpost, (path, tooltip_text) in enumerate(zip(image_paths,tooltips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idpost: self.postwindowfunctions(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)

      First_framepost= LabelFrame(self.post_window, bd=3, relief=tk.RIDGE,text="Post Incident Reports")
      First_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      First_framepost.place(x=0,y=30,width=700,height=120)
      
      Incident_Number=self.Numberentry.get()
      I_No=Label(First_framepost, text="Incident_Number:")
      I_No.grid(row=0, column=0,padx=5)
      self.Incidentnumber_entrypost=Entry(First_framepost,width=15)
      self.Incidentnumber_entrypost.grid(row=0,column=1,padx=5)
      self.Incidentnumber_entrypost.insert(0,Incident_Number)

      Date = Label(First_framepost, text="Date:")
      Date.grid(row=0, column=2,padx=5)
      self.datepost= DateEntry(First_framepost, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
      self.datepost.grid(row=0, column=3,sticky='w',padx=5)
      self.datepost.state(['disabled'])

      current_time = datetime.now().strftime("%H:%M")
      Time= Label(First_framepost,text= "Time:")
      Time.grid(row=0,column=4,padx=5)
      self.timepost= ttk.Entry(First_framepost,width=15)
      self.timepost.grid(row=0, column=5,sticky='w',padx=5,pady=8)
      self.timepost.insert(0,current_time)
      self.timepost.state(['disabled'])

      currentuser=getuser()
      Createdby= Label(First_framepost,text="Created By")
      Createdby.grid(row=1,column=0,padx=5)
      self.createdbypost= ttk.Entry(First_framepost)
      self.createdbypost.grid(row=1,column=1,padx=5)
      self.createdbypost.insert(0,currentuser)
      self.createdbypost.state(['disabled'])

      Inc= Label(First_framepost, text="Incident_Category:")
      Inc.grid(row=1, column=2,padx=5)
      self.Incpost= ttk.Entry(First_framepost, width=15)
      self.Incpost.grid(row=1, column=3,sticky='w')

      self.linked_postvar = tk.BooleanVar()
      self.linked_postvalue = tk.StringVar()
      self.Linkedpost=Checkbutton(First_framepost,width=2,variable=self.linked_postvar,command=self.toggle_post_entry)
      self.Linkedpost.grid(row=1,column=4,sticky='w',padx=3)
      Linked_Orders= Label(First_framepost,text="Final Costed")
      Linked_Orders.grid(row=1,column=5,padx=5,pady=5)

      self.catdetailsforpostincident=KBACKEND.fetch_cat_details()
      self.catdetailspost= [row[1] for row in self.catdetailsforpostincident]
      lb5 = Label(First_framepost, text="Defect Cat*",fg="red", padx=5,pady=5)
      lb5.grid(row=2, column=0)
      self.Categorypost = ttk.Combobox(First_framepost, values= self.catdetailspost, width=15)
      self.Categorypost.grid(row=2, column=1)

      self.verdictdetails=KBACKEND.fetch_verdict_details()
      self.verdictdetailspost=[row[1] for row in self.verdictdetails]
      lb6 = Label(First_framepost, text="PIR_Verdict*",fg="red", padx=5,pady=5)
      lb6.grid(row=2, column=2)
      self.PIR_verdict = ttk.Combobox(First_framepost, values= self.verdictdetailspost, width=15)
      self.PIR_verdict.grid(row=2, column=3)

      Second_framepost= Frame(self.post_window, bd=3, relief=tk.RIDGE)
      Second_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      Second_framepost.place(x=0,y=150,width=700,height=180)

      comments= Label(Second_framepost, text="Comments:")
      comments.grid(row=0, column=0,pady=5,sticky='w')
      self.commentspost= Text(Second_framepost,width=40, height='8',wrap='word')
      self.commentspost.grid(row=0,column=1,columnspan=2,sticky='w',pady=5)

      
    def toggle_post_entry(self):
        if self.linked_postvar.get():
            self.linked_postvalue.set("Y")
        else:
           self.linked_postvalue.set("N")



      
    
    def postwindowfunctions(self,index):
       if index==1:
          self.exit_the_post_incident_report()
       if index==2:
          self.save_the_post_incident_report()
    def exit_the_post_incident_report(self):
       self.post_window.destroy()
    def save_the_post_incident_report(self):
       Incident_Number=self.Incidentnumber_entrypost.get()
       date_str=self.datepost.get_date()
       time_str=self.timepost.get()

       current_time = datetime.strptime(time_str, "%H:%M").time()

       combined_datetime = datetime.combine(date_str, current_time)

       Created_By= self.createdbypost.get()

       Incident_cat=self.Incpost.get()

       Final_costed=self.linked_postvalue.get()

       Comments=self.commentspost.get("1.0", tk.END)

       category_post= self.Categorypost.get()
       if category_post is None or category_post == "":
          messagebox.showerror("Error", "Primary key attribute 'Defect_cat' requires a value.")
       else:
         for row in self.catdetailsforpostincident:
          if row[1] == category_post:
            category_post_value_to_store = row[0]
            break
       verdict_post=self.PIR_verdict.get()
       if verdict_post is None or verdict_post=="":
          messagebox.showerror("Error", "Primary key attribute 'PIR_Verdict' requires a value.")
       else:
          for row in self.verdictdetails:
             if row[1]== verdict_post:
               verdict_post_value_to_store=row[0]
               break

     

       KBACKEND.store_the_postincident_reports(Incident_Number,combined_datetime,Created_By,Incident_cat,
                                               Final_costed,Comments,category_post_value_to_store,verdict_post_value_to_store)
       
       Incident_Number= self.Numberentry.get()
       Post_incident_report=KBACKEND.fetch_lastpost_reports_and_insert(Incident_Number)

       self.Post_incident_tree.delete(*self.Post_incident_tree.get_children())

       if Post_incident_report:
          for post_details in Post_incident_report:
             #Inci_Number= post_details.get("I_number")
             Date_time= post_details.get("Report_Created")
             if Date_time is not None:
              Date = Date_time.date()
              Time = Date_time.time()
             else:
               Date = None  # or a default value
               Time = None
             Created= post_details.get("Created_By")
             Incident_Category= post_details.get("Inc_Category_ID")
             Commentss= post_details.get("Comments")

             self.Post_incident_tree.insert("", "end", values=(Incident_Number,Date,Time,Created,Incident_Category,Commentss))
             
             self.post_incident_reports.config(state=DISABLED)

    def on_status_selected(self, event=None):
        selected_status = self.StatussEntry.get()
        current_user=getuser()
        
        if selected_status == "Completed" and KBACKEND.is_authority_level_sufficient(current_user):
            self.post_incident_reports.pack(side=tk.RIGHT, padx=1, pady=2)
        else:
            self.post_incident_reports.pack_forget()
        if selected_status == "Closed": 
           Incident_Number = self.Numberentry.get()
           if not KBACKEND.fetch_postreports(Incident_Number):
                messagebox.showwarning("Warning", "Create a post incident report before closing the incident.")
                self.StatussEntry.set('')  # Clear the selection
           else:
               self.StatussEntry.set("Closed")
               #self.StatussEntry.state(['disabled'])
    def on_location_selected(self, event=None):
        selected_location = self.LolEntry.get()
        
        if selected_location == "Roadside":
            self.lb3.grid(row=0, column=3)
            self.Driverentry.grid(row=0, column=4)
            self.lb3phone.grid(row=1, column=3)
            self.Driverphone.grid(row=1, column=4)
            self.Attendance_Def.grid_remove()
            self.AttendanceEntry.grid_remove()
            self.Deff_time.grid_remove()
            self.Deferred_Time.grid_remove()
            self.Deff.grid_remove()
            self.Deferred_To.grid_forget()

        else:
            self.lb3.grid_remove()
            self.Driverentry.grid_remove()
            self.lb3phone.grid_remove()
            self.Driverphone.grid_remove()
            self.Attendance_Def.grid(row=7,column=0)
            self.AttendanceEntry.grid(row=7, column=1, sticky='w')
            self.Deff.grid(row=8, column=0, padx=2, sticky='w')
            self.Deferred_To.grid(row=8, column=1, padx=2, sticky='w')
            self.Deff_time.grid(row=9,column=0,padx=2, sticky='w')
            self.Deferred_Time.grid(row=9,column=1,sticky='w')
     

    def clicking_the_postreportsone(self,event):
       selected_item = self.Post_incident_tree.selection()
       if selected_item:
         # Extract the index of the selected item
         #item_index = self.Table_treep.index(selected_item[0])

         Incident_Number= self.Numberentry.get()

         open_post_report_details= KBACKEND.fetch_lastpost_reports_and_inserttwo(Incident_Number)

         self.open_postreports_with_clickedrowone(open_post_report_details)
    def open_postreports_with_clickedrowone(self,open_post_report_details):
      self.post_windowclick= tk.Toplevel(self.root)
      self.post_windowclick.title("Post Incident Report Form")
      self.post_windowclick.resizable(False,False)

      
      root_x = self.root.winfo_x()
      root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
      offset_x = root_x + 50  # You can adjust this offset value
      offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
      self.post_windowclick.geometry(f"750x350+{offset_x}+{offset_y}")

      First_framepost= LabelFrame(self.post_windowclick, bd=3, relief=tk.RIDGE,text="Post Incident Reports")
      First_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      First_framepost.place(x=0,y=30,width=700,height=120)
      
      Incident_Number=self.Numberentry.get()
      I_No=Label(First_framepost, text="Incident_Number:")
      I_No.grid(row=0, column=0,padx=5)
      self.Incidentnumber_entrypostclick=ttk.Entry(First_framepost,width=15)
      self.Incidentnumber_entrypostclick.grid(row=0,column=1,padx=5)
      self.Incidentnumber_entrypostclick.insert(0,Incident_Number)
      self.Incidentnumber_entrypostclick.state(['disabled'])

      Date = Label(First_framepost, text="Date:")
      Date.grid(row=0, column=2,padx=5)
      self.datepostclick= DateEntry(First_framepost, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
      self.datepostclick.grid(row=0, column=3,sticky='w',padx=5)
      if open_post_report_details is not None:
         self.datepostvalueclick= open_post_report_details.get("Report_Created")
      else:
         self.datepostvalueclick=None
      self.datevalueclick= self.datepostvalueclick.date()
      self.datepostclick.set_date(self.datevalueclick)
      self.datepostclick.state(['disabled'])

      Time= Label(First_framepost,text= "Time:")
      Time.grid(row=0,column=4,padx=5)
      self.timepostclick= ttk.Entry(First_framepost,width=15)
      self.timepostclick.grid(row=0, column=5,sticky='w',padx=5,pady=8)
      if open_post_report_details is not None:
         self.timepostclickvalue= open_post_report_details.get("Report_Created")
      else:
         self.timepostclickvalue= None
      self.timevalueclick= self.timepostclickvalue.time()
      self.timepostclick.insert(0,self.timevalueclick)
      self.timepostclick.state(['disabled'])

      
      Createdby= Label(First_framepost,text="Created By")
      Createdby.grid(row=1,column=0,padx=5)
      self.createdbypostclick= ttk.Entry(First_framepost)
      self.createdbypostclick.grid(row=1,column=1,padx=5)
      if open_post_report_details is not None:
       self.createdbypostclickvalue= open_post_report_details.get("Created_By")
      else:
         self.createdbypostclickvalue=None
      self.createdbypostclick.insert(0,self.createdbypostclickvalue)
      self.createdbypostclick.state(['disabled'])
      

      Inc= Label(First_framepost, text="Incident_Category:")
      Inc.grid(row=1, column=2,padx=5)
      self.Incpostclick= ttk.Entry(First_framepost, width=15)
      self.Incpostclick.grid(row=1, column=3,sticky='w')
      if open_post_report_details is not None:
         self.Incpostclickvalue=open_post_report_details.get("Inc_Category_ID")
      else:
         self.Incpostclickvalue= None
      self.Incpostclick.insert(0,self.Incpostclickvalue)
      self.Incpostclick.state(['disabled'])

      self.linked_postvarclick = tk.BooleanVar()
      self.Linkedpostclick=ttk.Checkbutton(First_framepost,width=2,variable=self.linked_postvarclick)
      self.Linkedpostclick.grid(row=1,column=4,sticky='w',padx=3)
      if open_post_report_details is not None:
         self.Linkedpostclickvalue= open_post_report_details.get("Linked_Orders")
      else:
         self.Linkedpostclickvalue= None
      if self.Linkedpostclickvalue=='Y':
         checkbox=True
      else:
         checkbox=False
      self.linked_postvarclick.set(checkbox)
      self.Linkedpostclick.state(['disabled'])
      Linked_Orders= Label(First_framepost,text="Final Costed")
      Linked_Orders.grid(row=1,column=5,padx=5,pady=5)

      self.catdetailsforpostincidentclick=KBACKEND.fetch_cat_details()
      self.catdetailspostclick= [row[1] for row in self.catdetailsforpostincidentclick]
      lb5 = Label(First_framepost, text="Defect Cat*",fg="red", padx=5,pady=5)
      lb5.grid(row=2, column=0)
      self.Categorypostclick = ttk.Combobox(First_framepost, values= self.catdetailspostclick, width=15)
      self.Categorypostclick.grid(row=2, column=1)
      if open_post_report_details is not None:
         self.Categorypostclickvalue= open_post_report_details.get("Category")
      else:
         self.Categorypostclickvalue= None
      self.Categorypostclick.insert(0,self.Categorypostclickvalue)
      self.Categorypostclick.state(['disabled'])

      self.verdictdetailsclick=KBACKEND.fetch_verdict_details()
      self.verdictdetailspostclick=[row[1] for row in self.verdictdetailsclick]
      lb6 = Label(First_framepost, text="PIR_Verdict*",fg="red", padx=5,pady=5)
      lb6.grid(row=2, column=2)
      self.PIR_verdictclick = ttk.Combobox(First_framepost, values= self.verdictdetailspostclick, width=13)
      self.PIR_verdictclick.grid(row=2, column=3)
      if open_post_report_details is not None:
         self.PIR_verdictclickvalue=open_post_report_details.get("Verdict")
      else:
         self.PIR_verdictclickvalue=None
      self.PIR_verdictclick.insert(0,self.PIR_verdictclickvalue)
      self.PIR_verdictclick.state(['disabled'])

      Second_framepost= Frame(self.post_windowclick, bd=3, relief=tk.RIDGE)
      Second_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      Second_framepost.place(x=0,y=150,width=700,height=180)

      comments= Label(Second_framepost, text="Comments:")
      comments.grid(row=0, column=0,pady=5,sticky='w')
      self.commentspostclick= tk.Text(Second_framepost,width=40, height='8',wrap='word')
      self.commentspostclick.grid(row=0,column=1,columnspan=2,sticky='w',pady=5)
      if open_post_report_details is not None:
         self.commentspostclickvalue= open_post_report_details.get("Comments")
      else:
         self.commentspostclickvalue=None
      self.commentspostclick.insert("1.0",self.commentspostclickvalue)
      self.commentspostclick['state']='disabled'

            
    #Creating Event list for the third icon
    def create_event_list(self):
     self.widgetseventtab=[]
     self.icon3_window= tk.Toplevel(self.root)
     self.icon3_window.title("Event Detail Form") 
     self.icon3_window.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.icon3_window.geometry(f"800x600+{offset_x}+{offset_y}")

     Incident_Event= Frame(self.icon3_window, bd=3, relief=tk.RIDGE)
     Incident_Event.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Event.place(x=0,y=30,width=600,height=100)
     
     #Creating Label and Entry for Event Type, Action required inside Incident Event frame
     self.event_typesinfo= KBACKEND.fetch_event_types()
     self.eventtypedetails= [row[1] for row in self.event_typesinfo]
     Event_type= Label(Incident_Event, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entry= ttk.Combobox(Incident_Event,values=self.eventtypedetails,width=20)
     self.Event_type_entry.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Event_type_entry)

     current_user=getuser()
     Action_required= Label(Incident_Event, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entry= ttk.Entry(Incident_Event,width=30)
     self.Action_required_entry.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entry.insert(0, current_user)
     self.Action_required_entry.state(['disabled'])
     self.attach_context_menu(self.Action_required_entry)
     

     Created= LabelFrame(self.icon3_window,bd=3, relief=tk.RIDGE,text="Created")
     Created.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Created.place(x=610,y=30,width=180,height=120)
     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Created, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entry= DateEntry(Created, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entry.grid(row=0, column=1,sticky='w')
     self.Date_created_Entry.state(['disabled'])
     self.attach_context_menu(self.Date_created_Entry)
     #Time
     Time_created= Label(Created,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entry= ttk.Entry(Created,width=9)
     current_time = datetime.now().strftime("%H:%M")
     self.Time_created_entry.grid(row=1,column=1,sticky="w")
     self.Time_created_entry.insert(0, current_time)
     self.Time_created_entry.state(['disabled'])
     self.attach_context_menu(self.Time_created_entry)


     Event_text=Frame(self.icon3_window,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entry= Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entry.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.attach_context_menu(self.Event_details_entry)



     


     Next_event= LabelFrame(self.icon3_window,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)
     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entry= DateEntry(Next_event, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_nextevent_Entry.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_nextevent_Entry)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entry= Entry(Next_event,width=9)
     self.Time_nextevent_entry.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Time_nextevent_entry)
     self.Time_nextevent_entry.bind("<Button-1>", self.open_time_picker_event)

     self.type=KBACKEND.fetch_event_types()
     self.typedetails= [row[1] for row in self.type]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entry= ttk.Combobox(Next_event,values=self.typedetails,width=20)
     self.Type_nextevent_entry.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Type_nextevent_entry)
     self.Event_type_entry.bind("<<ComboboxSelected>>", self.populate_next_event_details)
     self.populate_next_event_details()


     Owner= Label(Next_event, text="Owner")
     Owner.grid(row=4,column=0,padx=5,pady=5)
     self.allusers=KBACKEND.get_the_userdetails()
     self.onlyusers=[row[0] for row in self.allusers]
     self.Owner_entry= ttk.Combobox(Next_event,values=self.onlyusers,width=30)
     self.Owner_entry.grid(row=4,column=1,sticky="w",padx=5,pady=5)
     self.Owner_entry.insert(0,current_user)
     #self.Owner_entry.state(['disabled'])
     self.attach_context_menu(self.Owner_entry)

     #defining functionalities for icons in the event details page 
     icon_box = tk.Frame(self.icon3_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

    # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     images = ["icon 21.png","icon 22.png"]
     for idd, path in enumerate(images, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idd: self.event_functionality(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

     self.widgetseventtab.append(self.Event_type_entry)
     self.widgetseventtab.append(self.Action_required_entry)
     self.widgetseventtab.append(self.Date_created_Entry)
     self.widgetseventtab.append(self.Time_created_entry)
     self.widgetseventtab.append(self.Event_details_entry)
     self.widgetseventtab.append(self.Date_nextevent_Entry)
     self.widgetseventtab.append(self.Time_nextevent_entry)
     self.widgetseventtab.append(self.Type_nextevent_entry)
     self.widgetseventtab.append(self.Owner_entry)

     for widget in self.widgetseventtab:
            widget.bind("<Tab>", self.focus_next_widgetevent)
            widget.bind("<Shift-Tab>", self.focus_previous_widgetevent)
    def focus_next_widgetevent(self, event):
        """Move focus to the next widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetseventtab.index(widget)
        next_index = (current_index + 1) % len(self.widgetseventtab)
        self.widgetseventtab[next_index].focus_set()
        return "break"  # Prevent default behavior

    def focus_previous_widgetevent(self, event):
        """Move focus to the previous widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetseventtab.index(widget)
        previous_index = (current_index - 1) % len(self.widgetseventtab)
        self.widgetseventtab[previous_index].focus_set()
        return "break"
     
    
    def create_event_listnew(self):
     self.icon3_windownew= tk.Toplevel(self.root)
     self.icon3_windownew.title("Event Detail Form")
     self.icon3_windownew.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.icon3_windownew.geometry(f"800x600+{offset_x}+{offset_y}")

     Incident_Event= Frame(self.icon3_windownew, bd=3, relief=tk.RIDGE)
     Incident_Event.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Event.place(x=0,y=30,width=600,height=100)
     
     #Creating Label and Entry for Event Type, Action required inside Incident Event frame
     self.event_typesinfonew= KBACKEND.fetch_event_types()
     self.eventtypedetailsnew= [row[1] for row in self.event_typesinfonew]
     Event_type= Label(Incident_Event, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entrynew= ttk.Combobox(Incident_Event,values=self.eventtypedetailsnew,width=20)
     self.Event_type_entrynew.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Event_type_entrynew)

     current_user=getuser()
     Action_required= Label(Incident_Event, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entrynew= ttk.Entry(Incident_Event,width=30)
     self.Action_required_entrynew.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entrynew.insert(0, current_user)
     self.Action_required_entrynew.state(['disabled'])
     self.attach_context_menu(self.Action_required_entrynew)
     

     Created= LabelFrame(self.icon3_windownew,bd=3, relief=tk.RIDGE,text="Created")
     Created.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Created.place(x=610,y=30,width=180,height=120)
     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Created, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entrynew= DateEntry(Created, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entrynew.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_created_Entrynew)
     #Time
     Time_created= Label(Created,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entrynew= Entry(Created,width=9)
     current_time = datetime.now().strftime("%H:%M")
     self.Time_created_entrynew.grid(row=1,column=1,sticky="w")
     self.Time_created_entrynew.insert(0, current_time)
     self.attach_context_menu(self.Time_created_entrynew)


     Event_text=Frame(self.icon3_windownew,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entrynew= Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entrynew.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.attach_context_menu(self.Event_details_entrynew)



     


     Next_event= LabelFrame(self.icon3_windownew,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)
     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entrynew= DateEntry(Next_event, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_nextevent_Entrynew.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_nextevent_Entrynew)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entrynew= Entry(Next_event,width=9)
     self.Time_nextevent_entrynew.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Time_nextevent_entrynew)
     

     self.typenew=KBACKEND.fetch_event_types()
     self.typedetailsnew= [row[1] for row in self.typenew]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entrynew= ttk.Combobox(Next_event,values=self.typedetailsnew,width=20)
     self.Type_nextevent_entrynew.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Type_nextevent_entrynew)
   


     Owner= Label(Next_event, text="Owner")
     Owner.grid(row=4,column=0,padx=5,pady=5)
     self.allusersnew=KBACKEND.get_the_userdetails()
     self.onlyusersnew=[row[0] for row in self.allusersnew]
     self.Owner_entrynew= ttk.Combobox(Next_event,values=self.onlyusersnew,width=30)
     self.Owner_entrynew.grid(row=4,column=1,sticky="w",padx=5,pady=5)
     self.Owner_entrynew.insert(0,current_user)
     #self.Owner_entry.state(['disabled'])
     self.attach_context_menu(self.Owner_entrynew)


    def open_time_picker_event(self, event):
        # Create new window for time selection
        self.time_windowevent = tk.Toplevel(self.root)
        self.time_windowevent.title("Select Time")
        self.time_windowevent.grab_set() 
        
        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
        offset_x = root_x + 50  # You can adjust this offset value
        offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
        self.time_windowevent.geometry(f"250x170+{offset_x}+{offset_y}") # Ensure the popup is modal (prevents interaction with the main window)

        # Styling the popup window (Center alignment, padding)
        self.time_windowevent.configure(bg="lightblue")
        frame = ttk.Frame(self.time_windowevent, padding=10)
        frame.grid(row=0, column=0, padx=20, pady=20)

        # Hour and Minute selection
        hours = [f"{i:02}" for i in range(24)]  # Hours: 00 to 23
        minutes = [f"{i:02}" for i in range(0, 60, 5)]  # Minutes: 00, 05, 10, ..., 55

        # Dropdown for Hour
        ttk.Label(frame, text="Hour").grid(row=0, column=0, padx=5, pady=5, sticky='w')
        self.hour_comboboxevent = ttk.Combobox(frame, values=hours, width=5)
        self.hour_comboboxevent.grid(row=0, column=1, padx=5, pady=5)
        self.hour_comboboxevent.set(datetime.now().strftime("%H"))

        # Dropdown for Minute
        ttk.Label(frame, text="Minute").grid(row=1, column=0, padx=5, pady=5, sticky='w')
        self.minute_comboboxevent = ttk.Combobox(frame, values=minutes, width=5)
        self.minute_comboboxevent.grid(row=1, column=1, padx=5, pady=5)
        self.minute_comboboxevent.set(datetime.now().strftime("%M"))

        # Confirm Button to set the selected time
        confirm_button = ttk.Button(self.time_windowevent, text="Set Time", command=self.set_timeevent)
        confirm_button.grid(row=2, column=0, padx=10, pady=10)

        # Make the popup movable and independent
        
        self.time_windowevent.grab_set()  # Prevent interaction with main window until popup is closed
        
    # Function to set the time in the entry box
    def set_timeevent(self):
        selected_hour = self.hour_comboboxevent.get()
        selected_minute = self.minute_comboboxevent.get()

        # Format time as HH:MM
        formatted_time = f"{selected_hour}:{selected_minute}"

        # Set the formatted time in the modifiedtime entry and close the popup
        self.Time_nextevent_entry.config(state='normal')  # Allow editing temporarily
        self.Time_nextevent_entry.delete(0, tk.END)  # Clear current value
        self.Time_nextevent_entry.insert(0, formatted_time)  # Insert selected time
        self.Time_nextevent_entry.config(state='readonly')  # Make it readonly again

        # Close the popup window
        self.time_windowevent.destroy()

    def event_functionality(self,index):
        if index == 1:
            self.exit()
        elif index == 2:
            self.save()
    def exit(self):
         self.icon3_window.destroy()

    def save(self):
        
        Incident_No= self.Numberentry.get()
        KBACKEND.generate_event_number(Incident_No)
        date_str = self.Date_created_Entry.get()  # Get date as string
        time_str = self.Time_created_entry.get()  # Get time as string

        # Combine date and time strings into a single datetime string
        datetime_str = f"{date_str} {time_str}"

        # Convert the datetime string to a datetime object
        datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

        First_event=self.Event_type_entry.get()
        for row in self.event_typesinfo:    
         if row[1] == First_event:
            First_event_tostore = row[0]
            break
         
        Event_text=self.Event_details_entry.get("1.0", tk.END)
        second_event= self.Type_nextevent_entry.get()
        for row in self.type:    
         if row[1] == second_event:
            Second_event_tostore = row[0]
            break
        datee_str= self.Date_nextevent_Entry.get()
        timee_str=self.Time_nextevent_entry.get()
         # Combine date and time strings into a single datetime string
        datetime_strr = f"{datee_str} {timee_str}"
        # Convert the datetime string to a datetime object
        datetime_objj = datetime.strptime(datetime_strr, "%d/%m/%Y %H:%M")
        Created_by= self.Action_required_entry.get()
        Owner=self.Owner_entry.get()
        KBACKEND.store_event_details(Incident_No,datetime_obj,First_event_tostore,Event_text
                                     ,Second_event_tostore,datetime_objj,Created_by,Owner)
        self.icon3_window.destroy()
        getting_ino= KBACKEND.giving_i_no_to_events()
        if getting_ino:
           for incident_details in getting_ino:
              incident_no= incident_details.get("I_Number")
              if incident_no is not None:
               last_incievent= KBACKEND.retrievevents(incident_no)
               if last_incievent:
                for incidents in last_incievent:
                 print("Processing incident:", incidents)
       
                incident_date = incidents.get("Incident Date")
                Customer=incidents.get("Customer")
                registration = incidents.get("Registration")
                I_no=incidents.get("Incident No")
                Status=incidents.get("Status")
                Category=incidents.get("Category")
                loca=incidents.get("Location")
                Charg=incidents.get("Charge")
                Locat= incidents.get("Locationn")
                Owner=incidents.get("Owner")
                Creator=incidents.get("Creator")
                Next_Event_DT=incidents.get("Next_Event_DT")
                if Next_Event_DT is not None:
                 Next_Event_Date = Next_Event_DT.date()
                 Next_Event_Time = Next_Event_DT.time()
                else:
                 Next_Event_Date = None  # or a default value
                 Next_Event_Time = None
        # Insert the incident into Kerride_table
                 self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locat, registration,I_no,Category,loca,Charg,Status,Owner,Creator,Next_Event_Date,Next_Event_Time))
        self.clear_filters()
       
        
        
              
              
        event_details= KBACKEND.fetch_all_events(Incident_No)
        self.events_tree.delete(*self.events_tree.get_children())
        
       
        if event_details:
          for event in event_details:
             Event_created= event.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= event.get('Notes')
             Last_updated= event.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= event.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= event.get('Event_Description')
             Next_Event_Description= event.get('Next_Event_Description')
             Created= event.get('Created_By')
             Own= event.get('Owner')


             self.events_tree.insert("", "end", values=(Created_date,Created_time,Created,Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,Own,Follow_up_date,follow_up_time,Own,Next_Event_Description))
             
             self.events_tree.bind("<<TreeviewSelect>>", self.on_roww_selected)
        self.populate_eventstree_table()

    def on_roww_selected(self,event):
        selected_item = self.events_tree.selection()
        
        if selected_item:
         # Extract the index of the selected item
         item_index = self.events_tree.index(selected_item[0])

         # Event number is the index + 1 (since event numbers start from 1)
         event_no = item_index + 1

         # Get the incident number from the entry
         incident_no=self.Numberentry.get()

         fetch_event_detailsthree= KBACKEND.fetch_data_for_eventthree(incident_no,event_no)

         self.open_eventspagethree_with_clickedrow(fetch_event_detailsthree)        
        
    def open_eventspagethree_with_clickedrow(self,fetch_event_detailsthree):
     
     self.event_windows= tk.Toplevel(self.root)
     self.event_windows.title("Event Detail Form")
     self.event_windows.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.event_windows.geometry(f"800x600+{offset_x}+{offset_y}")

     Incident_Eventt= Frame(self.event_windows, bd=3, relief=tk.RIDGE)
     Incident_Eventt.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Eventt.place(x=0,y=30,width=600,height=100)

     self.eventsinfothree= KBACKEND.fetch_event_types()
     self.eventtypesinformationthree= [row[1] for row in self.eventsinfothree]
     Event_type= Label(Incident_Eventt, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entryythree= ttk.Combobox(Incident_Eventt,values=self.eventtypesinformationthree,width=20)
     self.Event_type_entryythree.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.Event_type_valuethree= fetch_event_detailsthree.get("Event_Type")
     self.Event_type_entryythree.set(self.Event_type_valuethree if self.Event_type_valuethree is not None else"")
     self.Event_type_entryythree.state(['disabled'])
     self.attach_context_menu(self.Event_type_entryythree)

     
     Action_required= Label(Incident_Eventt, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entryythree= ttk.Entry(Incident_Eventt,width=30)
     self.Action_required_entryythree.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entryyvaluethree=fetch_event_detailsthree.get("Createdby")
     self.Action_required_entryythree.insert(0,self.Action_required_entryyvaluethree if self.Action_required_entryyvaluethree
                                        is not None else"")
     self.Action_required_entryythree.state(['disabled'])
     self.attach_context_menu(self.Action_required_entryythree)
     
     

     Created= LabelFrame(self.event_windows,bd=3, relief=tk.RIDGE,text="Created")
     Created.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Created.place(x=610,y=30,width=180,height=120)

     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Created, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entryythree= DateEntry(Created, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entryythree.grid(row=0, column=1,sticky='w')
     self.Date_created_Entryyvaluethree= fetch_event_detailsthree.get("Createddate")
     self.Date_created_datethree= self.Date_created_Entryyvaluethree.date()
     self.Date_created_Entryythree.set_date(self.Date_created_datethree if self.Date_created_datethree is not None else"")
     self.Date_created_Entryythree.state(['disabled'])
     self.attach_context_menu(self.Date_created_Entryythree)
     #Time
     Time_created= Label(Created,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entryythree= ttk.Entry(Created,width=9)
     self.Time_created_entryythree.grid(row=1,column=1,sticky="w")
     self.Time_created_entryyvaluethree= fetch_event_detailsthree.get("Createddate")
     self.Time_created_timethree=self.Time_created_entryyvaluethree.time()
     self.Time_created_entryythree.insert(0,self.Time_created_timethree if self.Time_created_timethree is not None else"")
     self.Time_created_entryythree.state(['disabled'])
     self.attach_context_menu(self.Time_created_entryythree)
     


     Event_text=Frame(self.event_windows,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entryythree= tk.Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entryythree.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.Event_detailsvaluethree= fetch_event_detailsthree.get("Eventtext")
     self.Event_details_entryythree.insert("1.0",self.Event_detailsvaluethree if self.Event_detailsvaluethree is not None else"")
     self.Event_details_entryythree['state'] = 'disabled'
     self.attach_context_menu(self.Event_details_entryythree)

     

     


     Next_event= LabelFrame(self.event_windows,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)

     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entryythree= DateEntry(Next_event, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_nextevent_Entryythree.grid(row=0, column=1,sticky='w')
     self.Date_nextevent_Entryyvaluethree=fetch_event_detailsthree.get("Nexteventdate")
     self.Date_nextevent_datethree= self.Date_nextevent_Entryyvaluethree.date()
     self.Date_nextevent_Entryythree.set_date(self.Date_nextevent_datethree if self.Date_nextevent_datethree is not None else"")
     self.Date_nextevent_Entryythree.state(['disabled'])
     self.attach_context_menu(self.Date_nextevent_Entryythree)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entryythree= Entry(Next_event,width=9)
     self.Time_nextevent_entryythree.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Time_nextevent_entryyvaluethree= fetch_event_detailsthree.get("Nexteventdate")
     self.Time_nextevent_timethree= self.Time_nextevent_entryyvaluethree.time()
     self.Time_nextevent_entryythree.insert(0,self.Time_nextevent_timethree if self.Time_nextevent_timethree is not None else"")
     self.Time_nextevent_entryythree['state'] = 'disabled'
     self.attach_context_menu(self.Time_nextevent_entryythree)


     self.typethree=KBACKEND.fetch_event_types()
     self.typedetailsthree= [row[1] for row in self.typethree]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entryythree= ttk.Combobox(Next_event,values=self.typedetailsthree,width=20)
     self.Type_nextevent_entryythree.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.Typenextevent_valuethree= fetch_event_detailsthree.get("Nexteventtype")
     self.Type_nextevent_entryythree.state(['disabled'])
     self.Type_nextevent_entryythree.set(self.Typenextevent_valuethree if self.Typenextevent_valuethree is not None else"")
     self.attach_context_menu(self.Type_nextevent_entryythree)
     
    
   
     Owner= Label(Next_event, text="Owner")
     Owner.grid(row=4,column=0,padx=5,pady=5)
     self.Owner_entryythree= ttk.Entry(Next_event,width=30)
     self.Owner_entryythree.grid(row=4,column=1,sticky="w",padx=5,pady=5)
     self.Ownerentryyvaluethree= fetch_event_detailsthree.get("Owner")
     self.Owner_entryythree.insert(0,self.Ownerentryyvaluethree if self.Ownerentryyvaluethree is not None else"")
     self.Owner_entryythree.state(['disabled'])
     self.attach_context_menu(self.Owner_entryythree)

     
    




       

    #defining functionalities for the icons in the second page 
    def open_icon_windowsecond(self,index):
        if index == 2:
            self.open_next_window()
        elif index == 1:
            self.close_the_second_window()
        elif index==3:
            self.open_next_window()
            result=KBACKEND.retrieve_last_incident_pks()
            if result[0] and result[1] and result[2] and result[3] and result[4] and result[5] is not None:
             self.create_event_list()
            else:
               self.icon1_window.lift()  # Bring the main window to the top
               self.icon1_window.attributes('-topmost', True)
               messagebox.showwarning(
               "Missing Information", 
               "All required fields (Contact Method ID, Category, Incident Loc, Recharge and Type) must be entered before saving. Please complete all details.",
               parent=self.icon1_window
                                    )
               self.icon1_window.attributes('-topmost', False) 
       
        elif index==4:
            self.open_next_window()
            result=KBACKEND.retrieve_last_incident_pks()
            if result[0] and result[1] and result[2] and result[3] and result[4] and result[5] is not None:
             self.on_click_index_4()
            else:
               self.icon1_window.lift()  # Bring the main window to the top
               self.icon1_window.attributes('-topmost', True)
               messagebox.showwarning(
               "Missing Information", 
               "All required fields (Contact Method ID, Category, Incident Loc, Recharge and Type) must be entered before saving. Please complete all details.",
               parent=self.icon1_window
                                    )
               self.icon1_window.attributes('-topmost', False) 
   
        
    # Define a function to populate Kerride_table with all incidents from the database
    def populate_kerride_table(self,filter_criteria=None,filter_type=None,start=0, chunk_size=100):
     red_rows = []
     fuchsia_rows = []
     dark_green_rows = []
     black_rows = []
     green_rows = []
     blue_rows = []
     dark_grey_rows = []
     violet_rows=[]

     red_count = 0
     fuchsia_count = 0
     dark_green_count = 0
     black_count = 0
     green_count = 0
     blue_count = 0
     dark_grey_count = 0
     violet_count = 0

     if start == 0:
      self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())
    
     all_incidents = KBACKEND.retrieve_all_incidents()

     if filter_criteria is None:
            filter_criteria = self.get_filter_criteria()
     show_closed=self.is_closed.get()

     filtered_incidents = [incident for incident in all_incidents if self.passes_filter(incident, filter_criteria)]
     incidents_chunk = filtered_incidents[start:start + chunk_size]
     if incidents_chunk:
        for incident in incidents_chunk: 
         incident_datetime_s = incident.get("Incident Date")
         # Split the datetime string at the space character to extract the date part
         date_part = incident_datetime_s.date()
         registration = incident.get("Registration")
         Customer=incident.get("Customer")
         I_no=incident.get("Incident No")
         Status=incident.get("Status")
         Cat=incident.get("Category")
         loc=incident.get("Location")
         Char=incident.get("Charge")
         location=incident.get("Locationn")
         Owner= incident.get("Owner")
         Creator=incident.get("Creator")
         Next_Event_Datetime=incident.get("Next_Event_Date")
         incident_created=incident.get("Incident_Created")
         
         if Next_Event_Datetime is not None:
          Next_Event_Date = Next_Event_Datetime.date()
          Next_Event_Time = Next_Event_Datetime.time()
          time_difference = Next_Event_Datetime - datetime.now()

         else:
          Next_Event_Date = None
          Next_Event_Time= None  # or a default value
          #time_difference=None
          
          
         row_data = (incident_datetime_s, Customer, location, registration, I_no, Cat, loc, Char, Status, Owner, Creator, Next_Event_Date, Next_Event_Time)
         
         # Skip incidents with Status='X' unless show_closed (self.text11) is active
         if Status.lower() == 'x' and not show_closed:
                continue
        
         # Filter logic
         if self.passes_filter(incident, filter_criteria):
                if Status.lower() == 'x' and show_closed:
                    dark_grey_rows.append(row_data)
                elif Next_Event_Datetime is None:
                    violet_rows.append(row_data)
                elif Next_Event_Datetime < datetime.now() and Status.lower() != 'x':
                    red_rows.append(row_data)
                elif time_difference.total_seconds() <= 1800 and Status.lower() != 'x':
                    fuchsia_rows.append(row_data)
                elif -1800 <= time_difference.total_seconds() <= 3600 and Status.lower() != 'x':
                    dark_green_rows.append(row_data)
                elif 3600 <= time_difference.total_seconds() <= 14400 and Status.lower() != 'x':
                    black_rows.append(row_data)
                elif 14400 <= time_difference.total_seconds() <= 86400 and Status.lower() != 'x':
                    green_rows.append(row_data)
                elif time_difference.total_seconds() >= 86400 and Status.lower() != 'x':
                    blue_rows.append(row_data)

        # Update counts (excluding closed incidents unless show_closed is active)
        for row_data in red_rows:
            red_count += 1
        for row_data in fuchsia_rows:
            fuchsia_count += 1
        for row_data in dark_green_rows:
            dark_green_count += 1
        for row_data in black_rows:
            black_count += 1
        for row_data in green_rows:
            green_count += 1
        for row_data in blue_rows:
            blue_count += 1

        if show_closed:
            for row_data in dark_grey_rows:
                dark_grey_count += 1
        for row_data in violet_rows:
            violet_count += 1

        # Insert rows based on the selected filter or show all if no filter_type is specified
        if filter_type is None:
            for row_data in red_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("red",))
            for row_data in fuchsia_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Fuchsia",))
            for row_data in dark_green_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Dark Green",))
            for row_data in black_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Black",))
            for row_data in green_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Green",))
            for row_data in blue_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Blue",))
            if show_closed:
                for row_data in dark_grey_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Dark Grey",))
            for row_data in violet_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Violet",))
        else:
            # Only show rows based on specific filter
            if filter_type == "overdue":
                for row_data in red_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("red",))
            elif filter_type == "half_hour":
                for row_data in fuchsia_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Fuchsia",))
            elif filter_type == "one_hour":
                for row_data in dark_green_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Dark Green",))
            elif filter_type == "four_hours":
                for row_data in black_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Black",))
            elif filter_type == "one_day":
                for row_data in green_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Green",))
            elif filter_type == "over_one_day":
                for row_data in blue_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Blue",))
            elif filter_type == "closed" and show_closed:
                for row_data in dark_grey_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Dark Grey",))
            elif filter_type == "no_event":
                for row_data in violet_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Violet",))

     bold_font = font.Font(size=10,weight="bold")
     self.root.Kerride_table.tag_configure('red', background='white', foreground='red',font=bold_font)
     self.root.Kerride_table.tag_configure('Fuchsia', background='white', foreground='Fuchsia',font=bold_font)
     self.root.Kerride_table.tag_configure('Dark Green', background='white', foreground='Dark Green',font=bold_font)
     self.root.Kerride_table.tag_configure('Black', background='white', foreground='Black',font=bold_font)
     self.root.Kerride_table.tag_configure('Green', background='white', foreground='Green',font=bold_font)
     self.root.Kerride_table.tag_configure('Blue', background='white', foreground='Blue',font=bold_font)
     self.root.Kerride_table.tag_configure('Dark Grey', background='white', foreground='Dark Grey',font=bold_font)
     self.root.Kerride_table.tag_configure('Violet', background='white', foreground='Violet',font=bold_font)
     
     self.entry_red_count.config(state='normal')
     self.entry_red_count.delete(0, 'end')
     self.entry_red_count.insert('end', str(red_count))
     self.entry_red_count.config(state='disabled')

     self.entry_fuchsia_count.config(state='normal')
     self.entry_fuchsia_count.delete(0, 'end')
     self.entry_fuchsia_count.insert('end', str(fuchsia_count))
     self.entry_fuchsia_count.config(state='disabled')

     self.entry_dark_green_count.config(state='normal')
     self.entry_dark_green_count.delete(0, 'end')
     self.entry_dark_green_count.insert('end', str(dark_green_count))
     self.entry_dark_green_count.config(state='disabled')

     self.entry_black_count.config(state='normal')
     self.entry_black_count.delete(0, 'end')
     self.entry_black_count.insert('end', str(black_count))
     self.entry_black_count.config(state='disabled')

     self.entry_green_count.config(state='normal')
     self.entry_green_count.delete(0, 'end')
     self.entry_green_count.insert('end', str(green_count))
     self.entry_green_count.config(state='disabled')

     self.entry_blue_count.config(state='normal')
     self.entry_blue_count.delete(0, 'end')
     self.entry_blue_count.insert('end', str(blue_count))
     self.entry_blue_count.config(state='disabled')

     self.entry_dark_grey_count.config(state='normal')
     self.entry_dark_grey_count.delete(0, 'end')
     self.entry_dark_grey_count.insert('end', str(dark_grey_count))
     self.entry_dark_grey_count.config(state='disabled')
     return 
     #else:
      #print("No incidents found in the database.")
     
         
    def get_filter_criteria(self):
         return {
            "Registration": self.Regtext1.get(),
            "Customer": self.custext2.get(),
            "Owner": self.text3.get(),
            "Creator": self.text4.get(),
            "Category": self.text5.get(),
            "Location": self.I_location.get(),
            "Charge": self.I_charge.get(),
            "Incident Date": self.text6.get_date() if self.text6.get() else None,
            "Status": self.text7.get(),
            "Closed": self.is_closed.get(),
            "Locations": self.text12.get(),
            "I_Number": self.text13.get()
        }
    def passes_filter(self, incident, filter_criteria):
        incident_registration = incident.get("Registration", "")
        if filter_criteria["Registration"] and filter_criteria["Registration"].lower() not in (incident_registration.lower() if incident_registration else ""):
            return False

        incident_customer = incident.get("Customer", "")
        if filter_criteria["Customer"] and filter_criteria["Customer"].lower() not in (incident_customer.lower() if incident_customer else ""):
         return False

        incident_owner = incident.get("Owner", "")
        if filter_criteria["Owner"] and filter_criteria["Owner"].lower() not in (incident_owner.lower() if incident_owner else ""):
         return False

        incident_creator = incident.get("Creator", "")
        if filter_criteria["Creator"] and filter_criteria["Creator"].lower() not in (incident_creator.lower() if incident_creator else ""):
         return False

        incident_category = incident.get("Cat_Desc", "")
        if filter_criteria["Category"] and filter_criteria["Category"].lower() not in (incident_category.lower() if incident_category else ""):
         return False

        incident_location = incident.get("Loc_Desc", "")
        if filter_criteria["Location"] and filter_criteria["Location"].lower() not in (incident_location.lower() if incident_location else ""):
         return False

        incident_charge = incident.get("Char_Desc", "").strip().lower()
        selected_charge = filter_criteria["Charge"].strip().lower()

         # Split incident charge into words
        incident_charge_words = incident_charge.split()

         # Check for an exact match in the words
        if selected_charge and selected_charge not in incident_charge_words:
         return False

        incident_date = incident.get("Incident Date")
        if filter_criteria["Incident Date"] and filter_criteria["Incident Date"] != (incident_date.date() if incident_date else None):
         return False

        incident_status = incident.get("Status_Desc", "")
        if filter_criteria["Status"] and filter_criteria["Status"].lower() not in (incident_status.lower() if incident_status else ""):
         return False

        if filter_criteria["Closed"] and not (incident_status.lower() == "closed" if incident_status else False):
         return False

        incident_locationn = incident.get("Locationn", "")
        if filter_criteria["Locations"] and filter_criteria["Locations"].lower() not in (incident_locationn.lower() if incident_locationn else ""):
         return False

        incident_number = incident.get("Incident No")
        if filter_criteria["I_Number"] and filter_criteria["I_Number"].lower() not in (str(incident_number).lower() if incident_number else ""):
         return False


        return True 
    def filter_kerride_table(self, event=None):
        self.populate_kerride_table()
    
   
    def clear_filters(self):
     # Clear all filter inputs
     self.Regtext1.delete(0, "end")
     self.custext2.delete(0, "end")
     self.text3.delete(0, "end")
     self.text4.delete(0, "end")
     self.text5.set('')
     self.I_location.set('')
     self.I_charge.set('')
     self.text6.delete(0, "end")
     self.text7.delete(0, "end")
     self.text12.delete(0, "end")
     self.text13.delete(0, "end")
     self.is_closed.set(0)

     # Repopulate table with all data
     self.populate_kerride_table()
     self.Regtext1['values'] = self.onlyreg
     self.custext2['values'] = self.Customer_detailsonly
    
    
    def validate_odo(self, event):
      try:
        odo = float(self.Odo.get())
        
        # Retrieve mileage data directly as a single value
        fleet_no = self.Fleet_entry.get()
        mileage_data = KBACKEND.getmileage(fleet_no)
        
        if mileage_data is not None:
            # Extract the mileage value from the pyodbc.Row object
            mileage_value = float(mileage_data[0])  # Assuming mileage is the first column
            
            if odo < mileage_value:
                messagebox.showwarning("Invalid Odometer", "Odometer cannot be lesser than igloo.")
            else:
                print("Odometer is valid.")
        else:
            messagebox.showerror("Error", "Failed to retrieve mileage data.")
    
      except ValueError:
        messagebox.showerror("Invalid Input", "Please enter a valid number.")
        self.Odo.focus_set()

      except Exception as ex:
        messagebox.showerror("Error", f"An unexpected error occurred: {ex}")
        self.Odo.focus_set()
    
    def reset_odo(self,event):
        # Reset the Odo entry to the initial value
        if self.Initial_Odo_Value is not None:
            self.Odo.delete(0, tk.END)
            self.Odo.insert(0, self.Initial_Odo_Value)

    def open_next_window(self):
     reg_no = self.text1.get()
     I_number=self.Numberentry.get()
     driver_name = self.Driverentry.get()
     drivertel=self.Driverphone.get()
     created= self.Time.get()
     # Getting the selected date from the DateEntry widget
     selected_date = self.datee.get_date()
    
    # Getting the current time
     current_time_str = self.modifiedtime.get()

     current_time = datetime.strptime(current_time_str, "%H:%M").time()
    
    # Combining selected date and current time into a datetime object
     combined_datetime = datetime.combine(selected_date, current_time)
     
     contact_methodd=None
     contact_method= self.Contact_Method_Entry.get()
     if contact_method is None or contact_method == "":
      self.icon1_window.lift()  # Bring the main window to the top
      self.icon1_window.attributes('-topmost', True) 
      messagebox.showerror("Error", " 'Contact Method' requires a value.",parent=self.icon1_window)
      self.icon1_window.attributes('-topmost', False) 
     else:
         for row in self.contactmeth:
          if row[1] == contact_method:
            contact_methodd = row[0]
            break
     
     
     
     
     contactname=self.Contact_Name_Entry.get()
     if not contactname:
        self.icon1_window.lift()  # Bring the main window to the top
        self.icon1_window.attributes('-topmost', True) 
        messagebox.showerror("Error", "Contact Name is an Mandatory field",parent=self.icon1_window)
        self.icon1_window.attributes('-topmost', False) 

     contacttel=self.Contact_Tel_Entry.get()
     contactemail=self.Contact_Email_Entry.get()
     if contact_method == "Telephone" and (not contacttel):
            self.icon1_window.lift()  # Bring the main window to the top
            self.icon1_window.attributes('-topmost', True) 
            messagebox.showerror("Error", "Telephone is required for this incident.",parent=self.icon1_window)
            self.icon1_window.attributes('-topmost', False) 
     elif contact_method=="Email" and (not contactemail):
          self.icon1_window.lift()  # Bring the main window to the top
          self.icon1_window.attributes('-topmost', True) 
          messagebox.showerror("Error", "Email is required for this incident.",parent=self.icon1_window)
          self.icon1_window.attributes('-topmost', False) 

     Defect_loc= self.locaentry.get("1.0", tk.END)
     faultdesc=self.Faultentry.get("1.0", tk.END)
     
     cat_value_to_store=None
     cat_selected = self.CatEntry.get()
     if cat_selected is None or cat_selected == "":
      self.icon1_window.lift()  # Bring the main window to the top
      self.icon1_window.attributes('-topmost', True) 
      messagebox.showerror("Error", "'Category' requires a value.",parent=self.icon1_window)
      self.icon1_window.attributes('-topmost', False) 
     else:
        for row in self.Catdetails:
         if row[1] == cat_selected:
            cat_value_to_store = row[0]
            break
     
     lol_value_to_store=None
     lol = self.LolEntry.get()
     if lol is None or lol == "":
      self.icon1_window.lift()  # Bring the main window to the top
      self.icon1_window.attributes('-topmost', True) 
      messagebox.showerror("Error", "'Location' requires a value.",parent=self.icon1_window)
      self.icon1_window.attributes('-topmost', False) 

     else:
        for row in self.Locdetils:
         if row[1] == lol:
            lol_value_to_store = row[0]
            break
     if lol == "Roadside" and (not driver_name or not drivertel):
            self.icon1_window.lift()  # Bring the main window to the top
            self.icon1_window.attributes('-topmost', True)     
            messagebox.showerror("Error", "Driver name and phone are required for Roadside incidents.",parent=self.icon1_window)
            self.icon1_window.attributes('-topmost', False)
     
     char_value_to_store=None
     charge = self.Chargeentry.get()
     if charge is None or charge == "":
      self.icon1_window.lift()  # Bring the main window to the top
      self.icon1_window.attributes('-topmost', True) 
      messagebox.showerror("Error", "'Recharge' requires a value.",parent=self.icon1_window)
      self.icon1_window.attributes('-topmost', False)
     else:
        for row in self.Chardetails:
         if row[1] == charge:
            char_value_to_store = row[0]
            break
     stat_value_store=None
     status = self.StatussEntry.get()
     if status is None or status == "":
      self.icon1_window.lift()  # Bring the main window to the top
      self.icon1_window.attributes('-topmost', True)
      messagebox.showerror("Error", "'Status' requires a value.",parent=self.icon1_window)
      self.icon1_window.attributes('-topmost', False)
     else:
      for row in self.statrows:
        if row[1] == status:
            stat_value_store = row[0]
            break

     odo= self.Odo.get()

     
     attendance=self.attendance_var.get()

     Deferred_date = self.Deferred_To.get()

     Deferred_time=self.Deferred_Time.get()
    
    # Getting the current time
     datetime_str = f"{Deferred_date} {Deferred_time}"

    # Convert the datetime string to a datetime object
     combined_deferred = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")
    
    # Combining selected date and current time into a datetime object
     what3=self.whatwordsentry.get()

     vehicle_loaded= self.Vehicle_loaded_var.get()

     fleet= self.Fleet_entry.get()

     makemodel=self.text2.get()
     
     custid=self.Customer_Identry.get()
     custname=self.Cust_Name_Entry.get()
     contractno=self.Contract_No_Entry.get()
     locat= self.location_1.get()
     depo= self.Depotentry.get()
     defectno=self.Customer_defno_Entry.get()
     supplier_no= self.nameentry.get()
     customer_name=self.Cust_Name_Entry.get()
     depot_name=self.location_2.get()
     
     InciType_value_to_store=None
     InciType = self.Incitypeentry.get()
     if InciType is None or InciType == "":
      self.icon1_window.lift()  # Bring the main window to the top
      self.icon1_window.attributes('-topmost', True)
      messagebox.showerror("Error", "'Incident Type' requires a value.",parent=self.icon1_window)
      self.icon1_window.attributes('-topmost', False)
     else:
        for row in self.Typedetails:
         if row[1] == InciType:
            InciType_value_to_store = row[0]
            break
     
     Vor=self.big_button_var.get()
     
     if (contact_methodd is not None and cat_value_to_store is not None and lol_value_to_store is not None and  char_value_to_store is not None and 
         stat_value_store is not None and InciType_value_to_store is not None):
       print("This should not happen because some values are None:")
       print("contact_methodd:", contact_methodd)
       print("cat_value_to_store:", cat_value_to_store)
       print("lol_value_to_store:", lol_value_to_store)
       print("char_value_to_store:", char_value_to_store)
       print("stat_value_store:", stat_value_store)
       print("InciType_value_to_store:", InciType_value_to_store)
       KBACKEND.store_registration(reg_no, I_number, driver_name,created,combined_datetime,contact_methodd,contactname,
                                 contacttel,contactemail,drivertel,Defect_loc,faultdesc,cat_value_to_store,lol_value_to_store,
                                 char_value_to_store,stat_value_store,odo,attendance,combined_deferred,what3,fleet,custid,contractno,locat,defectno,supplier_no,vehicle_loaded,
                                 customer_name,depot_name,InciType_value_to_store,Vor)
       if self.attendance_var.get():
        result=KBACKEND.check_events(I_number)
        if result is None:
         self.create_event_listnew()
         Incident_No= self.Numberentry.get()
     
         KBACKEND.generate_event_number(Incident_No)
         date_str = self.datee.get()  # Get date as string
         time_str = self.modifiedtime.get()
         datetime_str = f"{date_str} {time_str}"

         # Convert the datetime string to a datetime object
         datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

         self.Event_type_entrynew.insert(0,"KPI INFO")

         First_event=self.Event_type_entrynew.get()
         First_event_tostore = 7
            
         self.Event_details_entrynew.insert("1.0","DEFERRED")
         Event_Notes=self.Event_details_entrynew.get("1.0", tk.END)
     
         self.Type_nextevent_entrynew.insert(0,"UPDATE")
         second_event= self.Type_nextevent_entrynew.get()
         Second_event_tostore = 12
     
         datee_str= self.Deferred_To.get()
         timee_str=self.Deferred_Time.get()

         datee_str_two=self.Deferred_To.get_date()


         # Combine date and time strings into a single datetime string
         datetime_strr = f"{datee_str} {timee_str}"
        # Convert the datetime string to a datetime object
         datetime_objj = datetime.strptime(datetime_strr, "%d/%m/%Y %H:%M")

         self.Date_nextevent_Entrynew.set_date(datee_str_two)
     
         self.Time_nextevent_entrynew.insert(0,timee_str)
     
         current_user=getuser()
         self.Action_required_entrynew.insert(0,current_user)
         Created_by= self.Action_required_entrynew.get()
         Ownerof=self.Owner_entrynew.get()

         KBACKEND.store_event_detailstwo(Incident_No,datetime_obj,First_event_tostore,Event_Notes
                                     ,Second_event_tostore,datetime_objj,Created_by,Ownerof)
     
        self.icon3_windownew.destroy()
     
        event_details= KBACKEND.fetch_all_events(Incident_No)
        self.events_tree.delete(*self.events_tree.get_children())
        
       
        if event_details:
          for event in event_details:
             Event_created= event.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= event.get('Notes')
             Last_updated= event.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= event.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= event.get('Event_Description')
             Next_Event_Description= event.get('Next_Event_Description')
             Created= event.get('Created_By')
             Own= event.get('Owner')


             self.events_tree.insert("", "end", values=(Created_date,Created_time,Created,Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,Own,Follow_up_date,follow_up_time,Own,Next_Event_Description))
             
             self.events_tree.bind("<<TreeviewSelect>>", self.on_roww_selected)
          self.populate_eventstree_table()
     
    
        last_incident = KBACKEND.retrieve_last_incident()
        print("last_incident:", last_incident)
     

        ## Clear existing data from Kerride_table
        self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())
     
        if last_incident:
         for incidents in last_incident:
          print("Processing incident:", incidents)
        # Retrieve attribute values for each incident
         #print("Last incident data:", last_incident)
         incident_date = incidents.get("Incident Date")
         Customer=incidents.get("Customer")
         registration = incidents.get("Registration")
         I_no=incidents.get("Incident No")
         Status=incidents.get("Status")
         Category=incidents.get("Category")
         loca=incidents.get("Location")
         Charg=incidents.get("Charge")
         Locat= incidents.get("Locationn")
         Owner=incidents.get("Owner")
         Next_Event_DT=incidents.get("Next_Event_DT")
         Incident_Created=incidents.get("Incident_Created")
         Creator=incidents.get("Creator")
         if Next_Event_DT is not None:
          Next_Event_Date = Next_Event_DT.date()
          Next_Event_Time = Next_Event_DT.time()
         else:
          Next_Event_Date = None  # or a default value
          Next_Event_Time = None
         
        # Insert the incident into Kerride_table
          self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locat, registration,I_no,Category,loca,Charg,Status,Owner,Creator,Next_Event_Date,Next_Event_Time))
         self.clear_filters()
       else:
        result=KBACKEND.check_eventstwo(I_number)
        if result is None:
         self.create_event_listnew()
         Incident_No= self.Numberentry.get()
     
         KBACKEND.generate_event_number(Incident_No)
         date_str = self.datee.get()  # Get date as string
         time_str = self.modifiedtime.get()
         datetime_str = f"{date_str} {time_str}"

         # Convert the datetime string to a datetime object
         datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

         self.Event_type_entrynew.insert(0,"UPDATE")

         First_event=self.Event_type_entrynew.get()
         First_event_tostore = 12
            
         self.Event_details_entrynew.insert("1.0","INCIDENT NOT DEFERRED")
         Event_Notes=self.Event_details_entrynew.get("1.0", tk.END)
     
         self.Type_nextevent_entrynew.insert(0,"UPDATE")
         second_event= self.Type_nextevent_entrynew.get()
         Second_event_tostore = 12
     
         datee_str= self.datee.get()
         timee_str=self.modifiedtime.get()

         datee_str_two=self.datee.get_date()


         # Combine date and time strings into a single datetime string
         datetime_strr = f"{datee_str} {timee_str}"
         # Convert the datetime string to a datetime object
         datetime_objj = datetime.strptime(datetime_strr, "%d/%m/%Y %H:%M")

         self.Date_nextevent_Entrynew.set_date(datee_str_two)
     
         self.Time_nextevent_entrynew.insert(0,timee_str)
     
         current_user=getuser()
         self.Action_required_entrynew.insert(0,current_user)
         Created_by= self.Action_required_entrynew.get()
         Ownerof=self.Owner_entrynew.get()

         KBACKEND.store_event_detailstwo(Incident_No,datetime_obj,First_event_tostore,Event_Notes
                                     ,Second_event_tostore,datetime_objj,Created_by,Ownerof)
     
         self.icon3_windownew.destroy()
     
         event_details= KBACKEND.fetch_all_events(Incident_No)
         self.events_tree.delete(*self.events_tree.get_children())
        
       
         if event_details:
          for event in event_details:
             Event_created= event.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= event.get('Notes')
             Last_updated= event.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= event.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= event.get('Event_Description')
             Next_Event_Description= event.get('Next_Event_Description')
             Created= event.get('Created_By')
             Own= event.get('Owner')


             self.events_tree.insert("", "end", values=(Created_date,Created_time,Created,Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,Own,Follow_up_date,follow_up_time,Own,Next_Event_Description))
             
             self.events_tree.bind("<<TreeviewSelect>>", self.on_roww_selected)
          self.populate_eventstree_table()
     
    
        last_incident = KBACKEND.retrieve_last_incident()
        print("last_incident:", last_incident)
     

        ## Clear existing data from Kerride_table
        self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())
     
        if last_incident:
         for incidents in last_incident:
          print("Processing incident:", incidents)
        # Retrieve attribute values for each incident
         #print("Last incident data:", last_incident)
         incident_date = incidents.get("Incident Date")
         Customer=incidents.get("Customer")
         registration = incidents.get("Registration")
         I_no=incidents.get("Incident No")
         Status=incidents.get("Status")
         Category=incidents.get("Category")
         loca=incidents.get("Location")
         Charg=incidents.get("Charge")
         Locat= incidents.get("Locationn")
         Owner=incidents.get("Owner")
         Next_Event_DT=incidents.get("Next_Event_DT")
         Incident_Created=incidents.get("Incident_Created")
         Creator=incidents.get("Creator")
         if Next_Event_DT is not None:
          Next_Event_Date = Next_Event_DT.date()
          Next_Event_Time = Next_Event_DT.time()
         else:
          Next_Event_Date = None  # or a default value
          Next_Event_Time = None
         
        # Insert the incident into Kerride_table
          self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locat, registration,I_no,Category,loca,Charg,Status,Owner,Creator,Next_Event_Date,Next_Event_Time))
         self.clear_filters()
        
        
     
   

    def populate_location_description(self, event=None):
        selected_location = self.location_1.get()
        rows = KBACKEND.fetch_locations_and_descriptions()
        for row in rows:
            if row[0] == selected_location:
                self.location_2.delete(0, tk.END)
                self.location_2.insert(0, row[1])
                break
    def populate_supplier_details(self,event=None):
        selected_supplier= self.Contactentry.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.nameentry.delete(0,tk.END)
              self.Phoneentry.delete(0,tk.END)
              self.nameentry.insert(0,row[0])
              self.Phoneentry.insert(0,row[2])

    def populate_eventstree_table(self):
      self.events_tree.delete(*self.events_tree.get_children())
      Incident_No=self.Numberentry.get()
      event_details= KBACKEND.fetch_all_events_oncemore(Incident_No)
      if event_details:
       for event in event_details:
             Event_created= event.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= event.get('Notes')
             Last_updated= event.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= event.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= event.get('Event_Description')
             Next_Event_Description= event.get('Next_Event_Description')
             Created= event.get('Created_By')
             Own= event.get('Owner')


             self.events_tree.insert("", "end", values=(Created_date,Created_time,Created,Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,Own,Follow_up_date,follow_up_time,Own,Next_Event_Description))
             
             
    
   
    def populate_next_event_details(self, event=None):
     selected_event_type = self.Event_type_entry.get()
    
     # Find the corresponding details for the selected event type
     for row in self.event_typesinfo:
        if row[1] == selected_event_type:
            next_event_id = row[2]
            if next_event_id is None:  # If there is no next_event_id
                # Set Type_nextevent_entry to the selected event type
                self.Type_nextevent_entry.set(selected_event_type)
                # Set Date_nextevent_Entry to the current date
                current_date = datetime.now().strftime("%d/%m/%Y")
                self.Date_nextevent_Entry.set_date(current_date)
                # Set Time_nextevent_entry to the current time
                current_time = datetime.now().strftime("%H:%M")
                self.Time_nextevent_entry.delete(0, 'end')  # Clear previous value
                self.Time_nextevent_entry.insert(0, current_time)
            else:
                # Find the corresponding description for the next_event_id
                for item in self.type:
                    if item[0] == next_event_id:
                        self.Type_nextevent_entry.set(item[1])
                        minutes = item[3]  # Use minutes from item[3]
                        if minutes > 1440:  # If duration exceeds one day
                            # Calculate the number of days and remaining minutes
                            days = minutes // 1440
                            remaining_minutes = minutes % 1440
                            # Calculate the adjusted date
                            next_date = datetime.now() +timedelta(days=days)
                            date_str = next_date.strftime("%d/%m/%Y")
                            # Populate Date_nextevent_Entry
                            self.Date_nextevent_Entry.set_date(date_str)
                            # Get the current time
                            current_time_str = self.Time_created_entry.get()
                            current_time = datetime.strptime(current_time_str, "%H:%M")
                            # Add remaining minutes to current time
                            adjusted_time = current_time + timedelta(minutes=remaining_minutes)
                        else:
                            # Get the current time
                            current_time_str = self.Time_created_entry.get()
                            current_time = datetime.strptime(current_time_str, "%H:%M")
                            # Add minutes to current time
                            adjusted_time = current_time + timedelta(minutes=minutes)
                        # Format adjusted time
                        adjusted_time_str = adjusted_time.strftime("%H:%M")
                        # Populate Time_nextevent_entry
                        self.Time_nextevent_entry.delete(0, 'end')  # Clear previous value
                        self.Time_nextevent_entry.insert(0, adjusted_time_str)
                        break
            break









    


     

    
        
            
    def close_the_second_window(self):
        self.icon1_window.destroy()
    



#==================================End of Second page except closing the window command================#
    
# Starting the third page which is the Purchase order form  
    
    def on_click_index_4(self):
     # Open the pop-up window (Toplevel)
     fleet_no = self.Fleet_entry.get()  # Get the fleet number from the entry widget

     # Fetch the service, compliance, and recall data using the backend functions
     service_data = KBACKEND.fetch_service_type_data(fleet_no)
     compliance_data = KBACKEND.fetch_compliance_data(fleet_no)
     recall_data = KBACKEND.fetch_recall_data(fleet_no)

     # Create a new pop-up window with a larger size
     self.purchasehistoryveh = tk.Toplevel(self.root)
     self.purchasehistoryveh.title("Vehicle Details")
     self.purchasehistoryveh.geometry("800x720")  # Expanded window size
     self.purchasehistoryveh.resizable(False, False)

     # Create a frame to hold all the tables and widgets
     main_frame = tk.Frame(self.purchasehistoryveh, bg="lightgray")
     main_frame.pack(pady=10, padx=10, fill="both", expand=True)

     style = ttk.Style()
     style.configure("Bold.Treeview", font=("Arial", 10, "bold"))


     # ---- Service Data Table ----
     service_label = tk.Label(main_frame, text="Service Data", font=("Arial", 14, "bold"), bg="lightgray")
     service_label.grid(row=0, column=0, pady=(0, 5), sticky="w")

     service_frame = tk.Frame(main_frame)
     service_frame.grid(row=1, column=0, pady=(0, 10))

     service_columns = ("service_type", "due_date")
     service_tree = ttk.Treeview(service_frame, columns=service_columns, show="headings", height=5,style="Bold.Treeview")

     # Define headings and column width
     service_tree.heading("service_type", text="Service Type")
     service_tree.heading("due_date", text="Due Date")
     service_tree.column("service_type", width=200)
     service_tree.column("due_date", width=200)

     # Insert service data
     for row in service_data:
        service_tree.insert("", "end", values=(row[0], row[1]))
      
     
     # Add vertical scrollbar for the service table
     service_scrollbar = ttk.Scrollbar(service_frame, orient="vertical", command=service_tree.yview)
     service_tree.configure(yscrollcommand=service_scrollbar.set)
     service_scrollbar.pack(side="right", fill="y")
     service_tree.pack(side="left")

     # ---- Compliance Data Table ----
     compliance_label = tk.Label(main_frame, text="Compliance Data", font=("Arial", 14, "bold"), bg="lightgray")
     compliance_label.grid(row=2, column=0, pady=(0, 5), sticky="w")

     compliance_frame = tk.Frame(main_frame)
     compliance_frame.grid(row=3, column=0, pady=(0, 10))

     compliance_columns = ("compliance_type", "due_date")
     compliance_tree = ttk.Treeview(compliance_frame, columns=compliance_columns, show="headings", height=5,style="Bold.Treeview")

     # Define headings and column width
     compliance_tree.heading("compliance_type", text="Compliance Type")
     compliance_tree.heading("due_date", text="Due Date")
     compliance_tree.column("compliance_type", width=200)
     compliance_tree.column("due_date", width=200)

     # Insert compliance data
     for row in compliance_data:
        compliance_tree.insert("", "end", values=(row[0], row[1]))

     # Add vertical scrollbar for the compliance table
     compliance_scrollbar = ttk.Scrollbar(compliance_frame, orient="vertical", command=compliance_tree.yview)
     compliance_tree.configure(yscrollcommand=compliance_scrollbar.set)
     compliance_scrollbar.pack(side="right", fill="y")
     compliance_tree.pack(side="left")

     # ---- Recall Data Table ----
     recall_label = tk.Label(main_frame, text="Recall Data", font=("Arial", 14, "bold"), bg="lightgray")
     recall_label.grid(row=4, column=0, pady=(0, 5), sticky="w")

     recall_frame = tk.Frame(main_frame)
     recall_frame.grid(row=5, column=0, pady=(0, 10))

     recall_columns = ("recall_number", "recall_description")
     recall_tree = ttk.Treeview(recall_frame, columns=recall_columns, show="headings", height=5,style="Bold.Treeview")

     # Define headings and column width
     recall_tree.heading("recall_number", text="Recall Number")
     recall_tree.heading("recall_description", text="Recall Description")
     recall_tree.column("recall_number", width=200)
     recall_tree.column("recall_description", width=200)

     # Insert recall data
     for row in recall_data:
        recall_tree.insert("", "end", values=(row[0], row[1]))

    # Add vertical scrollbar for the recall table
     recall_scrollbar = ttk.Scrollbar(recall_frame, orient="vertical", command=recall_tree.yview)
     recall_tree.configure(yscrollcommand=recall_scrollbar.set)
     recall_scrollbar.pack(side="right", fill="y")
     recall_tree.pack(side="left")

    # ---- Vehicle Notes Text Field ----
     notes_label = tk.Label(main_frame, text="Vehicle Notes", font=("Arial", 14, "bold"), bg="lightgray")
     notes_label.grid(row=6, column=0, pady=(0, 5), sticky="w")

     # Adjusted text field size
     vehicle_notes = tk.Text(main_frame, height=5, width=80, font=("Arial", 12))  # Increased width and slightly taller
     vehicle_notes.grid(row=7, column=0, pady=(0, 10))

     # ---- OK Button ----
     ok_button = tk.Button(main_frame, text="OK", font=("Arial", 14, "bold"), command=self.create_costandpurchaseorders)
     ok_button.grid(row=8, column=0, pady=10)



    


    def create_costandpurchaseorders(self):
        self.purchasehistoryveh.iconify()
        self.purchasehistory = tk.Toplevel(self.root)
        self.purchasehistory.title("Maintenance Control")
        self.purchasehistory.resizable(False, False)

        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
        offset_x = root_x + 50  # You can adjust this offset value
        offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
        self.purchasehistory.geometry(f"800x615+{offset_x}+{offset_y}")

        icon_box = tk.Frame(self.purchasehistory, relief=tk.RIDGE, borderwidth=3)
        icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

        image_paths = ["icon 18.png","icon 19.png","newicon.png"]
        tool_tips=["Exit the window","Save","Create new Purchase Order"]
        for idcost, (path,tooltip_text) in enumerate(zip(image_paths,tool_tips), start=1):
            image = Image.open(path)
            image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
            photo = ImageTk.PhotoImage(image)
            icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcost: self.initilisecostlinefunctionalities(index))
            icon_button.image = photo
            icon_button.pack(side=tk.LEFT, padx=5, pady=2)

            ToolTip(icon_button, tooltip_text)

        # Create frames for each page
        self.Historyp = Frame(self.purchasehistory)
        self.Maintenance_Controlp = Frame(self.purchasehistory)

        def show_History():
            self.Maintenance_Controlp.pack_forget()
            self.Historyp.pack(fill="both", expand=True)

        def show_maintenance():
            self.Maintenance_Controlp.pack(fill="both", expand=True)
            self.Historyp.pack_forget()

        show_History()

        # Creating Buttons Frame for second page
        Buttonframe = Frame(self.purchasehistory, relief=tk.RIDGE)
        Buttonframe.place(x=0, y=27, width=780, height=40)

        # Create buttons
        hist_button = tk.Button(Buttonframe, text="History", command=show_History)
        hist_button.pack(side=tk.LEFT, padx=1, pady=2)

        maintain_button = tk.Button(Buttonframe, text="Maintenance Control", command=show_maintenance)
        maintain_button.pack(side=tk.LEFT, padx=1, pady=2)

        dataframe = Label(self.Historyp, bd=3, relief=tk.RIDGE)
        dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
        dataframe.place(x=0, y=29, width=780, height=180) 

        scrollbar_x = ttk.Scrollbar(dataframe, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(dataframe, orient=VERTICAL)

        self.costlinestable = ttk.Treeview(dataframe, column=("Repaired", "Odometer", "Supplier_Name",
                                                             "Incident_Link", "Total_Parts_Cost", 
                                                            "Total_Recharge","Approval","Products"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        self.costlinestable.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.costlinestable.xview)
        scrollbar_y.config(command=self.costlinestable.yview)

        # Set column headings
        self.costlinestable.heading("Repaired", text="Repaired")
        self.costlinestable.heading("Odometer", text="Odometer")
        self.costlinestable.heading("Supplier_Name", text="Supplier_Name")
        self.costlinestable.heading("Incident_Link", text="Incident_Link")
        self.costlinestable.heading("Total_Parts_Cost", text="Total_Parts_Cost")
        self.costlinestable.heading("Total_Recharge", text="Total_Recharge")
        self.costlinestable.heading("Approval", text="Approval")
        self.costlinestable.heading("Products", text="Products")

        # Set Treeview to display column headings only
        self.costlinestable["show"] = "headings"

        # Set column widths
        self.costlinestable.column("Repaired", width=90)
        self.costlinestable.column("Odometer", width=80)
        self.costlinestable.column("Supplier_Name", width=90)
        self.costlinestable.column("Incident_Link", width=100)
        self.costlinestable.column("Total_Parts_Cost", width=100)
        self.costlinestable.column("Total_Recharge", width=100)
        self.costlinestable.column("Approval", width=90)
        self.costlinestable.column("Products",width=100)
        
        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.costlinestable.pack(side=LEFT, fill=BOTH, expand=True)
        
        self.populate_top_purchase_order()
        self.costlinestable.bind("<ButtonRelease-1>", self.onclick_for_purchaseorder_table)

        self.Approvalframep = tk.Frame(self.purchasehistory, bd=3, relief=tk.RIDGE)
        self.Approvalframep.place(x=0, y=250, width=780, height=150)

        # Creating frame for the 3 buttons
        self.Approval_Issuep = tk.Frame(self.Approvalframep)
        self.Invoice_Detailsp = tk.Frame(self.Approvalframep)
        self.Misccp = tk.Frame(self.Approvalframep)
        
        # Function to show approval page
        def show_Approval():
            self.Approval_Issuep.place(x=0, y=40, width=780, height=110)
            self.Invoice_Detailsp.place_forget()
            self.Misccp.place_forget()
        
        # Function to show invoice details page
        def show_Invoice_Details():
            self.Approval_Issuep.place_forget()
            self.Invoice_Detailsp.place(x=0, y=40, width=780, height=110)
            self.Misccp.place_forget()
        
        # Function to show misc page
        def show_Miscc():
            self.Approval_Issuep.place_forget()
            self.Invoice_Detailsp.place_forget()
            self.Misccp.place(x=0, y=40, width=780, height=110)
        
        show_Approval()
        
        # Creating Buttons Frame for second page
        Buttonframe = tk.Frame(self.Approvalframep, relief=tk.RIDGE)
        Buttonframe.place(x=0, y=8, width=780, height=30)
        
        # Create buttons
        Approval_button = tk.Button(Buttonframe, text="Approval Issue", command=show_Approval)
        Approval_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        Invoice_details_button = tk.Button(Buttonframe, text="Invoice Details", command=show_Invoice_Details)
        Invoice_details_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        Miscc_button = tk.Button(Buttonframe, text="Misc", command=show_Miscc)
        Miscc_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        # Creating data frame for Approval Issue
        Repairerdataframe = tk.Frame(self.Approval_Issuep, bd=3, relief=tk.RIDGE)
        Repairerdataframe.place(x=0, y=0, width=765, height=100)
        
        # Creating data frame for Invoice Details
        Invoicedataframe = tk.Frame(self.Invoice_Detailsp, bd=3, relief=tk.RIDGE)
        Invoicedataframe.place(x=0, y=0, width=765, height=100)

        Reg_Number=self.text1.get()
        lastapproval_details=KBACKEND.fetching_the_last_approval(Reg_Number)

     
        #Creating a label and combobox entry for Repairer 
        sup=KBACKEND.fetch_supplier_details()
        self.supplierp = [row[1] for row in sup]
        Repairer= Label(Repairerdataframe, text="Supplier Name:")
        Repairer.grid(row=0,column=0,padx=5,pady=5)
        
        self.Repairerentryp= ttk.Combobox(Repairerdataframe,values=self.supplierp,width=20)
        self.Repairerentryp.grid(row=0,column=1,sticky="w",padx=5,pady=5)
        if lastapproval_details is not None:
           self.Repairerentrypvalue= lastapproval_details.get('Supplier_Name')
        else:
           self.Repairerentrypvalue=None
        self.Repairerentryp.insert(0,self.Repairerentrypvalue if self.Repairerentrypvalue is not None else"")
        self.attach_context_menu(self.Repairerentryp)
        
        
        self.Repairerentryp.bind("<KeyRelease>", self.filter_supplier_list_three)
        self.Repairerentryp.bind("<<ComboboxSelected>>", self.populate_supplier_detailsp)
        self.Repairerentryp.focus_set()
        

      
        #Creating a label and combobox entry for Account
        Account= Label(Repairerdataframe, text="Account:")
        Account.grid(row=0,column=2,padx=5,pady=5)
        self.Accountentryp= ttk.Entry(Repairerdataframe,width=20)
        self.Accountentryp.grid(row=0,column=3,sticky="w",padx=5,pady=5)
        if lastapproval_details is not None:
           self.Accountentrypvalue=lastapproval_details.get('Supplier_No')
        else:
           self.Accountentrypvalue=None
        self.Accountentryp.insert(0,self.Accountentrypvalue if self.Accountentrypvalue is not None else"")
        self.attach_context_menu(self.Accountentryp)
        self.populate_supplier_detailsp()

        
        #Creating a Label and Entry for Approval
        Approval= Label(Repairerdataframe,text="Approval:")
        Approval.grid(row=0,column=4,padx=5,pady=5)
        self.Approvalentryp= ttk.Entry(Repairerdataframe,width= 20)
        self.Approvalentryp.grid(row=0,column=5,sticky="w",padx=5,pady=3)
        if lastapproval_details is not None:
           self.Approvalentrypvalue= lastapproval_details.get('PO_Number')
        else:
           self.Approvalentrypvalue=None
        self.Approvalentryp.insert(0,self.Approvalentrypvalue if self.Approvalentrypvalue is not None else"")
        self.attach_context_menu(self.Approvalentryp)
        self.Approvalentryp.state(['disabled'])

        #Creating a Label and Entry for Issued:
        Issued = Label(Repairerdataframe, text="Issued:")
        Issued.grid(row=1, column=0,padx=5,pady=5)
        self.Issuedentryp= DateEntry(Repairerdataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.Issuedentryp.grid(row=1, column=1,padx=5,pady=5,sticky='w')
        if lastapproval_details is not None:
           self.Issuedentryvalue= lastapproval_details.get('PO_Created')
        else:
           self.Issuedentryvalue= None
        self.Issuedentryp.set_date(self.Issuedentryvalue if self.Issuedentryvalue is not None else None)
        self.attach_context_menu(self.Issuedentryp)
        
        
        Po_created= Label(Repairerdataframe,text="Created_By:")
        Po_created.grid(row=1,column=2,padx=5,pady=5)
        self.Po_createdby= ttk.Entry(Repairerdataframe,width=20)
        self.Po_createdby.grid(row=1,column=3,padx=5,pady=5)
        if lastapproval_details is not None:
           self.Po_createdbyvalue= lastapproval_details.get('Created_By')
        else:
           self.Po_createdbyvalue= None
        self.Po_createdby.insert(0, self.Po_createdbyvalue if self.Po_createdbyvalue is not None else "")
        self.Po_createdby.state(['disabled'])
        self.attach_context_menu(self.Po_createdby)

        
        Fleet_Number=Label(Repairerdataframe, text="Fleet_No:")
        Fleet_Number.grid(row=1,column=4,padx=5,pady=5)
        self.fleetnumbercost= Entry(Repairerdataframe,width=20)
        self.fleetnumbercost.grid(row=1,column=5,padx=5,pady=5)
        if lastapproval_details is not None:
           self.fleetnumbercostvalue= lastapproval_details.get('Fleet_No')
        else:
           self.fleetnumbercostvalue= None
        self.fleetnumbercost.insert(0,self.fleetnumbercostvalue if self.fleetnumbercostvalue is not None else "")
        self.attach_context_menu(self.fleetnumbercost)

        #Creating a Label and Entry for Odometer
        Odometer= Label(Repairerdataframe,text="Odometer:")
        Odometer.grid(row=2,column=0,padx=5,pady=5)
        self.Odometerentryp= ttk.Entry(Repairerdataframe,width= 20)
        self.Odometerentryp.grid(row=2,column=1,padx=5,pady=5,sticky="w")
        if lastapproval_details is not None:
           self.Odometerentrypvalue= lastapproval_details.get('Odometer')
        else:
           self.Odometerentrypvalue= None
        self.Odometerentryp.insert(0,self.Odometerentrypvalue if self.Odometerentrypvalue is not None else "")
        self.attach_context_menu(self.Odometerentryp)
        self.Odometerentryp.state(['disabled'])

         #Creating a Label and Entry for Repaired:
        Repaired = Label(Repairerdataframe, text="Repaired:")
        Repaired.grid(row=2, column=2,padx=5,pady=5)
        self.Repairedentryp= DateEntry(Repairerdataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.Repairedentryp.grid(row=2, column=3,padx=5,pady=5,sticky='w')
        if lastapproval_details:
           self.Repairedentrypvalue=lastapproval_details.get('Repaired')
        else:
           self.Repairedentrypvalue= None
        self.Repairedentryp.set_date(self.Repairedentrypvalue if self.Repairedentrypvalue is not None else None)
        self.attach_context_menu(self.Repairedentryp)

        Order_Category= Label(Repairerdataframe,text="Order_Category")
        Order_Category.grid(row=2,column=4,padx=5,pady=5,sticky='w')
        self.Order_cat= Entry(Repairerdataframe,width=20)
        self.Order_cat.grid(row=2,column=5,padx=5,pady=5,sticky='w')
        if lastapproval_details is not None:
           self.Order_catvalue=lastapproval_details.get('Order_Category')
        else:
           self.Order_catovalue = None
        self.Order_cat.insert(0, self.Order_catvalue if self.Order_catvalue is not None else"")
        self.attach_context_menu(self.Order_cat)

        #Creating fields for the Invoice details dataframe

        Customer_Po= Label(Invoicedataframe,text="Customer Po:")
        Customer_Po.grid(row=0,column=0,padx=5,pady=5,sticky='w')
        self.Customer_Ponum= Entry(Invoicedataframe,width=20)
        self.Customer_Ponum.grid(row=0,column=1,padx=5,pady=5,sticky='w')
        if lastapproval_details is not None:
           self.Customer_Ponumvalue= lastapproval_details.get('Customer_PO')
        else:
           self.Customer_Ponumvalue= None
        self.Customer_Ponum.insert(0,self.Customer_Ponumvalue if self.Customer_Ponumvalue is not None else"")
        self.attach_context_menu(self.Customer_Ponum)

        kofax= Label(Invoicedataframe,text="Kofax Scan_No:")
        kofax.grid(row=0,column=2,padx=5,pady=5,sticky='w')
        self.Kofaxno= Entry(Invoicedataframe,width=20)
        self.Kofaxno.grid(row=0,column=3,padx=5,pady=5,sticky='w')
        if lastapproval_details is not None:
           self.Kofaxnovalue= lastapproval_details.get('Kofax_Scan_No')
        else:
           self.Kofaxnovalue= None
        self.Kofaxno.insert(0,self.Kofaxnovalue if self.Kofaxnovalue is not None else"")
        self.attach_context_menu(self.Kofaxno)

        Igloo= Label(Invoicedataframe,text="Igloo Invoice_No:")
        Igloo.grid(row=0,column=4,padx=5,pady=5,sticky='w')
        self.Igloono= Entry(Invoicedataframe,width=20)
        self.Igloono.grid(row=0,column=5,padx=5,pady=5,sticky='w')
        if lastapproval_details is not None:
           self.Igloonovalue=lastapproval_details.get('Igloo_Invoice_No')
        else:
           self.Igloonovalue=None
        self.Igloono.insert(0,self.Igloonovalue if self.Igloonovalue is not None else"")
        self.attach_context_menu(self.Igloono)

        Table= Frame(self.purchasehistory, bd=3,relief=tk.RIDGE)
        Table.place(x=0,y=400,width=780,height=140)

        scrollbar_x = ttk.Scrollbar(Table, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(Table, orient=VERTICAL)

        self.Table_treep = ttk.Treeview(Table, columns=("Types", "Category","Products", "Parts_Cost", "Labour_Cost", "Total_Cost", "Rech_Parts","Rech_Labour" ,"Total_Recharge"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        
        self.Table_treep.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.Table_treep.xview)
        scrollbar_y.config(command=self.Table_treep.yview)

        

        self.Table_treep.heading("Types", text="Types")
        self.Table_treep.heading("Category", text="Category")
        self.Table_treep.heading("Products", text="Products")
        self.Table_treep.heading("Parts_Cost", text="Parts_Cost")
        self.Table_treep.heading("Labour_Cost", text="Labour_Cost")
        self.Table_treep.heading("Total_Cost",text="Total_Cost")
        self.Table_treep.heading("Rech_Parts", text="Rech_Parts")
        self.Table_treep.heading("Rech_Labour", text="Rech_Labour")
        self.Table_treep.heading("Total_Recharge", text="Total_Recharge")

        self.Table_treep["show"] = "headings"
    
        self.Table_treep.column("Types", width=90)
        self.Table_treep.column("Category", width=90)
        self.Table_treep.column("Products", width=90)
        self.Table_treep.column("Parts_Cost", width=90)
        self.Table_treep.column("Labour_Cost", width=90)
        self.Table_treep.column("Total_Cost", width=90)
        self.Table_treep.column("Rech_Parts", width=90)
        self.Table_treep.column("Rech_Labour", width=90)
        self.Table_treep.column("Total_Recharge", width=90)

        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.Table_treep.pack(fill="both", expand=True)

        self.Table_treep.bind("<<TreeviewSelect>>", self.clicking_the_costlines)
        self.populate_all_the_costlines()

        Addcostline= Frame(self.purchasehistory, bd=3,relief=tk.RIDGE)
        Addcostline.place(x=0,y=540,width=780,height=50)

        Invoice_details_button = tk.Button(Addcostline, text="Add Costline",command=self.add_costline)
        Invoice_details_button.pack(side=tk.RIGHT, padx=1, pady=2)

      

        ##############----###########Creating Entries for Maintainence Control####################

        Maindataframemaintainence= Frame(self.Maintenance_Controlp,bd=3, relief=tk.RIDGE)
        Maindataframemaintainence.pack(side=tk.TOP,padx=8,pady=3, anchor='nw')
        Maindataframemaintainence.place(x=0,y=33,width=780,height=65)

        #Creating Label and Entry for Reg no 
        reg_entry=self.text1.get()
        Reg_no= Label(Maindataframemaintainence,text="Reg_no:")
        Reg_no.grid(row=0,column=0)
        self.Reg_no_entryp = Entry(Maindataframemaintainence, width=30)
        self.Reg_no_entryp.grid(row=0, column=1)
        self.Reg_no_entryp.insert(0,reg_entry)
        self.attach_context_menu(self.Reg_no_entryp)

        #Creating Label and Entry for Vehicle 
        Vehicle= self.text2.get()
        Vehicle_main= Label(Maindataframemaintainence,text= "Vehicle:")
        Vehicle_main.grid(row=0,column=2)
        self.Vehicle_main_entryp= Entry(Maindataframemaintainence,width=35)
        self.Vehicle_main_entryp.grid(row=0,column=3,sticky='w')
        self.Vehicle_main_entryp.insert(0,Vehicle)
        self.attach_context_menu(self.Vehicle_main_entryp)

        #Creating a new dataframe below Main dataframe

        Agreementframe= Frame(self.Maintenance_Controlp,bd=3, relief=tk.RIDGE)
        Agreementframe.pack(side=tk.TOP,padx=8,pady=3, anchor='nw')
        Agreementframe.place(x=0,y=98,width=780,height=70)

        #Create Label and entry for Agreement inside the dataframe
        Contract_number=self.Contract_No_Entry.get()
        Agreement= Label(Agreementframe,text="Agreement:")
        Agreement.grid(row=0,column=0,padx=5,pady=5)
        self.Agreemententryp= Entry(Agreementframe,width=30)
        self.Agreemententryp.grid(row=0,column=1,padx=5,pady=5)
        self.Agreemententryp.insert(0,Contract_number)
        self.attach_context_menu(self.Agreemententryp)

        #Create Label and entry for Customer
        Customer_name= self.Cust_Name_Entry.get()
        Customer= Label(Agreementframe,text="Customer:")
        Customer.grid(row=0,column=2,padx=5,pady=5)
        self.Customerentryp= Entry(Agreementframe,width=50)
        self.Customerentryp.grid(row=0, column=3, padx=5, pady=5)
        self.Customerentryp.insert(0,Customer_name)
        self.attach_context_menu(self.Customerentryp)
    def add_new_po(self):
     # Generate a new purchase order number
     self.Approvalentryp.state(['!disabled'])

     new_po_number = KBACKEND.generate_purchase_order_number()

     # Clear the existing number in self.Approvalentryp
     self.Approvalentryp.delete(0, tk.END)

     # Insert the new purchase order number
     self.Approvalentryp.insert(0, new_po_number)

     self.Approvalentryp.state(['disabled'])

    def filter_supplier_list_three(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Repairerentryp.get()
        if current_text == '':
            self.Repairerentryp['values'] = self.supplierp
        else:
            filtered_suppliers = [supplier for supplier in self.supplierp if current_text.lower() in supplier.lower()]
            self.Repairerentryp['values'] = filtered_suppliers


       
    def add_costline(self):
     self.save_the_purchase_information()
     
    
     approval_number = self.Approvalentryp.get()

     fetch_incidentnumber = KBACKEND.fetching_selected_approvaldetails(approval_number)
    
     if fetch_incidentnumber is not None:
        incidentnumber = fetch_incidentnumber.get('Incident_Link')
        print(f"Fetched Incident Number: '{incidentnumber}'")  # Debugging print
    
     numberentry = self.Numberentry.get()
     print(f"Number Entry: '{numberentry}'")  # Debugging print
    
     
      # Ensure both values are strings and strip any whitespace
     if str(incidentnumber).strip() == str(numberentry).strip():
        self.open_costlines_to_create()
        self.purchasehistory.iconify()
     else:
        self.purchasehistory.lift()  # Bring the main window to the top
        self.purchasehistory.attributes('-topmost', True) 
        messagebox.showwarning("Warning", "The current incident is not linked with the selected PO Number",parent=self.purchasehistory)
        self.purchasehistory.attributes('-topmost', False) 

    def open_costlines_to_create(self): 
        # Add a new row with default values
     
     self.costline_window = tk.Toplevel(self.root)
     self.costline_window.title("Cost Line Form")
     self.costline_window.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.costline_window.geometry(f"800x620+{offset_x}+{offset_y}")

     #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png", "icon24.png"]
     tool_tips= ["Exit the window","Save"]
     for idcost, (path,tooltip_text) in enumerate(zip(image_paths,tool_tips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcost: self.costline_icons(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)

     dataframe = Frame(self.costline_window, bd=3, relief=tk.RIDGE)
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=35, width=780, height=90)

     Reg_details= self.Reg_no_entryp.get()
     Reg_no = Label(dataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.costlinereg = Entry(dataframe,width=18)
     self.costlinereg.grid(row=0, column=1,padx=10,pady=3)
     self.costlinereg.insert(0,Reg_details)
     self.attach_context_menu(self.costlinereg)
     
     Repairer_name=self.Repairerentryp.get()
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=2)
     self.costlinerep = Entry(dataframe, width=18)
     self.costlinerep.grid(row=0, column=3,padx=10,pady=3)
     self.costlinerep.insert(0,Repairer_name)
     self.attach_context_menu(self.costlinerep)
     
     System_number= self.Approvalentryp.get()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=4)
     self.systemcost = ttk.Entry(dataframe, width=18)
     self.systemcost.grid(row=0, column=5,padx=10,pady=3)
     self.systemcost.insert(0,System_number)
     self.attach_context_menu(self.systemcost)
     self.systemcost.state(['disabled'])
     
     Ododetails=self.Odometerentryp.get()
     Odometerveh = Label(dataframe, text="Vehicle Odometer:")
     Odometerveh.grid(row=1, column=0,pady=5)
     self.odovehcost = ttk.Entry(dataframe, width=18)
     self.odovehcost.grid(row=1, column=1)
     self.odovehcost.insert(0,Ododetails)
     self.attach_context_menu(self.odovehcost)
     self.odovehcost.state(['disabled'])
     
     Repairer_accountdetails= self.Accountentryp.get()
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=1, column=2,pady=5)
     self.repaccocost = Entry(dataframe, width=18)
     self.repaccocost.grid(row=1, column=3)
     self.repaccocost.insert(0,Repairer_accountdetails)
     self.attach_context_menu(self.repaccocost)

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=1,column=4)
     self.Line_createdentry=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentry.grid(row=1,column=5)
     self.Line_createdentry.state(['disabled'])
     
     current_user=getuser()
     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=2,column=0)
     self.Line_createdby= ttk.Entry(dataframe,width=18)
     self.Line_createdby.grid(row=2,column=1)
     self.Line_createdby.insert(0,current_user)
     self.Line_createdby.state(['disabled'])

     Seconddataframe = Frame(self.costline_window, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=125, width=780, height=70)
  
     Reason = Label(Seconddataframe, text="Types*:",fg="red")
     Reason.grid(row=0, column=0)
     Po_Types=KBACKEND.Fetch_PO_Types()
     formatted_data = [f"{row[0]} - {row[1]}" for row in Po_Types]
     self.Reasoncosttypes = ttk.Combobox(Seconddataframe,width=20,values=formatted_data)
     self.Reasoncosttypes.grid(row=0, column=1,padx=15,pady=3)
     self.Reasoncosttypes.bind("<<ComboboxSelected>>", self.update_rtscostcategory)

       # Format data


     RTS = Label(Seconddataframe, text="Category*:",fg="red")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategory = ttk.Combobox(Seconddataframe,width=20)
     self.rtscostcategory.grid(row=0, column=3,padx=10,pady=3)
     self.attach_context_menu(self.rtscostcategory)
     self.rtscostcategory.bind("<<ComboboxSelected>>",self.update_rtscostproducts)
     self.rtscostcategory.bind("<KeyRelease>", self.filter_rts_category)


     category_label = tk.Label(Seconddataframe, text="Products*:",fg="red")
     category_label.grid(row=0, column=4)

     self.category_cost = ttk.Combobox(Seconddataframe, width=20)
     self.category_cost.grid(row=0, column=5, padx=15, pady=3)
     self.category_cost.bind("<KeyRelease>", self.filter_rts_products)
     self.attach_context_menu(self.category_cost)

     
     
     Pfdepot= self.location_2.get()
     rowss = KBACKEND.fetch_locations_and_descriptions()
     self.depotdetails = [row[1] for row in rowss]  # First column values for dropdown
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscost = ttk.Combobox(Seconddataframe, width=20,values=self.depotdetails)
     self.analysiscost.grid(row=1, column=1)
     self.analysiscost.set(Pfdepot)
     self.analysiscost.bind("<<ComboboxSelected>>", self.on_depot_selected)
     self.attach_context_menu(self.analysiscost)



     Thirddataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=195, width=780, height=50)

     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscost = Entry(Thirddataframe,width=13)
     self.Partscost.grid(row=0, column=1,padx=15,pady=3)
     self.Partscost.insert(0,"0.00")
     self.Partscost.bind("<KeyRelease>", self.on_parts_cost_changed)
     self.attach_context_menu(self.Partscost)


     Labour_Hours= Label(Thirddataframe,text="Labour Hours:")
     Labour_Hours.grid(row=0,column=2)
     self.Labour_Hours= Entry(Thirddataframe,width=13)
     self.Labour_Hours.grid(row=0,column=3,padx=15,pady=3)
     self.Labour_Hours.bind("<KeyRelease>", self.calculate_the_labour_value)
     self.attach_context_menu(self.Labour_Hours)

     Labour_Rate=Label(Thirddataframe,text="Labour Rate")
     Labour_Rate.grid(row=0,column=4)
     self.Labour_Rate=Entry(Thirddataframe,width=13)
     self.Labour_Rate.grid(row=0,column=5,padx=15, pady=3)
     self.Labour_Rate.insert(0,"0.00")
     self.Labour_Rate.bind("<KeyRelease>", self.calculate_the_labour_value)
     self.attach_context_menu(self.Labour_Rate)
                       
     Labour = Label(Thirddataframe, text="Labour Value:")
     Labour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Labourcost = Entry(Thirddataframe,width=13)
     self.Labourcost.grid(row=0, column=7,padx=15,pady=3)
     self.Labourcost.insert(0,"0.00")
     self.attach_context_menu(self.Labourcost)

     fourthdataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Recharge")
     fourthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fourthdataframe.place(x=0, y=245, width=780, height=80)

     Parts_Uplift=Label(fourthdataframe,text="Parts Uplift")
     Parts_Uplift.grid(row=0,column=0)
     self.Parts_Uplift= ttk.Entry(fourthdataframe,width=13)
     self.Parts_Uplift.grid(row=0,column=1,padx=15,pady=3)
     self.Parts_Uplift.bind("<FocusOut>", self.on_parts_cost_changed)
     #self.Parts_Uplift.bind("<Control-z>", self.undo_parts_uplift)
     self.attach_context_menu(self.Parts_Uplift)
     
     self.Parts_Uplift.bind("<Double-1>", self.reset_to_original) 

     RechParts = Label(fourthdataframe, text="Rech.Parts:")
     RechParts.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechcost = Entry(fourthdataframe,width=13)
     self.Rechcost.grid(row=0, column=3,padx=15,pady=3)
     self.Rechcost.insert(0,"0.00")
     self.attach_context_menu(self.Rechcost)
     self.Rechcost.bind("<KeyRelease>", self.on_rechcost_changed)

     Labour_Uplift= Label(fourthdataframe,text="Labour Uplift")
     Labour_Uplift.grid(row=0,column=4)
     self.Labour_Uplift= ttk.Entry(fourthdataframe,width=13)
     self.Labour_Uplift.grid(row=0,column=5,padx=15,pady=3)
     self.Labour_Uplift.bind("<Double-1>", self.reset_labour_uplift)
     #self.Labour_Uplift.bind("<Control-z>", self.undo_labour_uplift)

     Rechlabour = Label(fourthdataframe, text="Rech.labour:")
     Rechlabour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechlabcost = Entry(fourthdataframe,width=11)
     self.Rechlabcost.grid(row=0, column=7,padx=15,pady=3)
     self.Rechlabcost.insert(0,"0.00")
     self.attach_context_menu(self.Rechlabcost)
     #self.Rechlabcost.bind("<FocusOut>", self.on_rechlabcost_changed)

     self.on_depot_selected()

     Rechposted = Label(fourthdataframe, text="Rech.posted:")
     Rechposted.grid(row=1, column=0)
     
     self.rechposted_var = tk.BooleanVar()
     self.rechposted_value = tk.StringVar()
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechpostedcost = Checkbutton(fourthdataframe,variable=self.rechposted_var, command=self.toggle_date_entry)
     self.Rechpostedcost.grid(row=1, column=1,padx=15,pady=3)
     self.attach_context_menu(self.Rechpostedcost)

     Rechposteddate = Label(fourthdataframe, text="Rech.posted date:")
     Rechposteddate.grid(row=1, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechposteddatecost = DateEntry(fourthdataframe, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Rechposteddatecost.grid(row=1, column=3,padx=15,pady=3)
     self.Rechposteddatecost.set_date(datetime.now().strftime("%d/%m/%Y"))  # Set to a valid date first
     self.Rechposteddatecost._top_cal.withdraw()  # Hide the calendar popup initially
     self.clear_date_entry()
     self.attach_context_menu(self.Rechposteddatecost)

     Customerreference = Label(fourthdataframe, text="Customer ref:")
     Customerreference.grid(row=1, column=4)

     self.customerreferencecost = Entry(fourthdataframe,width=11)
     self.customerreferencecost.grid(row=1, column=5,padx=15,pady=3)

     fifthdataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=375, width=780, height=115)

     self.notescost= Text(fifthdataframe,width=80, height='5',wrap='word')
     self.notescost.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.notescost)

     Sixthdataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Recharge text")
     Sixthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Sixthdataframe.place(x=0, y=490, width=780, height=115)

     self.rechargecost= Text(Sixthdataframe,width=80, height='5',wrap='word')
     self.rechargecost.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.rechargecost)

     Seventhdataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Customer Specifics")
     Seventhdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seventhdataframe.place(x=0, y=325, width=780, height=50)

     self.Customer_specifics=Entry(Seventhdataframe,width=100,fg="Red")
     self.Customer_specifics.grid(row=0,column=2)

     cust_id=self.Customer_Identry.get()
     result=KBACKEND.check_customer_specific(cust_id)
     if result:
        self.Customer_specifics.delete(0, tk.END)
        self.Customer_specifics.insert(0,result)
     else:
        self.Customer_specifics.delete(0, tk.END)
        self.Customer_specifics.insert(0,"CUSTOMER Does not have SPECAL RECHARGE RATES")
     
     self.widgetscostline=[]

     self.widgetscostline.append(self.costlinereg)
     self.widgetscostline.append(self.costlinerep)
     self.widgetscostline.append(self.systemcost)
     self.widgetscostline.append(self.odovehcost)
     self.widgetscostline.append(self.repaccocost)
     self.widgetscostline.append(self.Line_createdentry)
     self.widgetscostline.append(self.Line_createdby)
     self.widgetscostline.append(self.Reasoncosttypes)
     self.widgetscostline.append(self.rtscostcategory)
     self.widgetscostline.append(self.category_cost)
     self.widgetscostline.append(self.analysiscost)
     self.widgetscostline.append(self.Partscost)
     self.widgetscostline.append(self.Labour_Hours)
     self.widgetscostline.append(self.Labour_Rate)
     self.widgetscostline.append(self.Labourcost)
     self.widgetscostline.append(self.Parts_Uplift)
     self.widgetscostline.append(self.Rechcost)
     self.widgetscostline.append(self.Labour_Uplift)
     self.widgetscostline.append(self.Rechlabcost)
     self.widgetscostline.append(self.Rechpostedcost)
     self.widgetscostline.append(self.Rechposteddatecost)
     self.widgetscostline.append(self.customerreferencecost)
     self.widgetscostline.append(self.Customer_specifics)
     self.widgetscostline.append(self.notescost)
     self.widgetscostline.append(self.rechargecost)

     for widget in self.widgetscostline:
            widget.bind("<Tab>", self.focus_next_widgetcostline)
            widget.bind("<Shift-Tab>", self.focus_previous_widgetcostline)
    

    def focus_next_widgetcostline(self, event):
        """Move focus to the next widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetscostline.index(widget)
        next_index = (current_index + 1) % len(self.widgetscostline)
        self.widgetscostline[next_index].focus_set()
        return "break"  # Prevent default behavior

    def focus_previous_widgetcostline(self, event):
        """Move focus to the previous widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetscostline.index(widget)
        previous_index = (current_index - 1) % len(self.widgetscostline)
        self.widgetscostline[previous_index].focus_set()
        return "break"

        
        

    def on_recharge_selected(self, event):
     self.current_selection = self.Chargeentry.get()

    def on_depot_selected(self, event=None):
     if self.current_selection == "RECHARGE":
        self.update_uplift()
        self.check_supplier_conditions()

    def update_uplift(self):
     depot_name = self.analysiscost.get()
     print(f"Depot Name: {depot_name}")
     parts_uplift = KBACKEND.fetch_uplift_forparts(depot_name)
     self.original_uplift_percentage = parts_uplift
     print(f"Parts Uplift: {parts_uplift}")
     self.Parts_Uplift.delete(0, tk.END)
     self.Parts_Uplift.insert(0, f"{parts_uplift}.00%")
           
            
    def on_parts_cost_changed(self, event):
     if self.current_selection == "RECHARGE":
        try:
            parts_cost = float(self.Partscost.get())
            parts_uplift_text = self.Parts_Uplift.get()
            parts_uplift = float(parts_uplift_text.replace('%', ''))
            uplift_amount = parts_cost * (parts_uplift / 100)
            total_cost = parts_cost + uplift_amount
            self.Rechcost.delete(0, tk.END)
            self.Rechcost.insert(0, "{:.2f}".format(total_cost))
            self.original_rechcost = total_cost
        except ValueError:
            pass

    def on_rechcost_changed(self, event):
     if self.current_selection == "RECHARGE":
        try:
            rech_cost = float(self.Rechcost.get())
            parts_cost = float(self.Partscost.get())
            if parts_cost > 0:
                uplift_percentage = ((rech_cost - parts_cost) / parts_cost) * 100
                self.Parts_Uplift.delete(0, tk.END)
                self.Parts_Uplift.insert(0, "{:.2f}%".format(uplift_percentage))
            else:
                Depot_Name = self.analysiscost.get()
                print(f"Depot Name: {Depot_Name}")
                parts_uplift = KBACKEND.fetch_uplift_forparts(Depot_Name)
                self.Parts_Uplift.delete(0, tk.END)
                self.Parts_Uplift.insert(0, f"{parts_uplift}%")
                #self.Parts_Uplift.insert(0, "{:.2f}%".format(parts_uplift))

        except ValueError:
            print("Invalid input for Rechcost or Parts Cost.")
    def reset_to_original(self, event):
     self.Parts_Uplift.delete(0, tk.END)
     self.Parts_Uplift.insert(0, f"{self.original_uplift_percentage}%")
    
     self.Rechcost.delete(0, tk.END)
     self.Rechcost.insert(0, "{:.2f}".format(self.original_rechcost))

     self.Parts_Uplift.icursor(tk.END)
     self.Parts_Uplift.selection_clear()

    def check_supplier_conditions(self):
     supplier_name = self.costlinerep.get()

     if self.current_selection == "RECHARGE" and supplier_name == "Petit Forestier Holding":
        self.handle_pp_holding_scenario()
     elif self.current_selection == "RECHARGE" and supplier_name != "Petit Forestier Holding":
        self.handle_other_supplier_scenario()

    def calculate_the_labour_value(self,event=None):
       self.recharge_selection=self.Chargeentry.get()
       if self.recharge_selection!= "RECHARGE":
        labour_rate = float(self.Labour_Rate.get())
        labour_hours = float(self.Labour_Hours.get())
        labour_cost = labour_rate * labour_hours
        self.Labourcost.delete(0, tk.END)
        self.Labourcost.insert(0, "{:.2f}".format(labour_cost))
       else:
          self.check_supplier_conditions()

       

    def handle_pp_holding_scenario(self):
     Depot_Name = self.analysiscost.get()
     labour_rate = KBACKEND.fetch_labourrate_forlabours(Depot_Name)
     self.Labour_Rate.delete(0, tk.END)
     self.Labour_Rate.insert(0, "{:.2f}".format(labour_rate))
     self.Labour_Hours.bind("<KeyRelease>", self.calculate_labour_cost_for_pp_holding)
     self.Labour_Rate.bind("<KeyRelease>", self.calculate_labour_cost_for_pp_holding)
     self.original_labour_uplift_percentage = 0.0
     self.calculate_labour_cost_for_pp_holding()

    def calculate_labour_cost_for_pp_holding(self, event=None):
     try:
        labour_rate = float(self.Labour_Rate.get())
        labour_hours = float(self.Labour_Hours.get())
        labour_cost = labour_rate * labour_hours
        self.Labourcost.delete(0, tk.END)
        self.Labourcost.insert(0, "{:.2f}".format(labour_cost))
        self.Rechlabcost.delete(0, tk.END)
        self.Rechlabcost.insert(0, "{:.2f}".format(labour_cost))
        self.original_rechlabcost = labour_cost 
     except ValueError:
        print("Invalid input for labour rate or hours.")

    def handle_other_supplier_scenario(self):
     Depot_Name=self.analysiscost.get()
     labour_uplift = KBACKEND.fetch_labouruplift_forlabours(Depot_Name)
     self.Labour_Uplift.delete(0, tk.END)
     self.Labour_Uplift.insert(0, "{:.2f}%".format(labour_uplift))
     self.Labour_Rate.bind("<KeyRelease>", self.calculate_labour_cost_with_uplift)
     self.Labour_Hours.bind("<KeyRelease>", self.calculate_labour_cost_with_uplift)
     self.Labour_Uplift.bind("<FocusOut>", self.calculate_labour_cost_with_uplift)
     self.original_labour_uplift_percentage = labour_uplift 
     self.calculate_labour_cost_with_uplift()

    def calculate_labour_cost_with_uplift(self, event=None):
     try:
        labour_rate = float(self.Labour_Rate.get())
        labour_hours = float(self.Labour_Hours.get())
        labour_uplift_text = self.Labour_Uplift.get()
        labour_uplift = float(labour_uplift_text.replace('%', ''))
        labour_cost = labour_rate * labour_hours
        self.Labourcost.delete(0, tk.END)
        self.Labourcost.insert(0, "{:.2f}".format(labour_cost))
        uplift_amount = labour_cost * (labour_uplift / 100)
        rech_lab_cost = labour_cost + uplift_amount
        self.Rechlabcost.delete(0, tk.END)
        self.Rechlabcost.insert(0, "{:.2f}".format(rech_lab_cost))
        self.original_rechlabcost = rech_lab_cost
     except ValueError:
        print("Invalid input for labour rate, hours, or uplift.")
      
    


       
       

    #def on_rechlabcost_changed(self, event):
        #rech_lab_cost = float(self.Rechlabcost.get())
        #labour_cost = float(self.Labourcost.get())
        
        #if labour_cost > 0:
            # Calculate uplift percentage
            #labour_uplift_percentage = ((rech_lab_cost - labour_cost) / labour_cost) * 100
            
            # Update Labour_Uplift entry
            #self.Labour_Uplift.delete(0, tk.END)
            #self.Labour_Uplift.insert(0, "{:.2f}%".format(labour_uplift_percentage))
        #else:
            # If labour cost is 0 or negative, keep Labour_Uplift as is
            #pass

    #def on_rechlabcost_changed(self, event):
     #if self.current_selection == "RECHARGE":
        #supplier_name = self.costlinerep.get()  # Get the supplier name
        
        #if supplier_name == "Petit Forestier Holding":
            # For "Petit Forestier Holding", just update Rechlabcost without calculating uplift
            #try:
                #rech_lab_cost = float(self.Rechlabcost.get())
                # Save the original Rechlabcost value if it's being updated
                #self.original_rechlabcost = rech_lab_cost
                # Update Rechlabcost with the new value
                #self.Rechlabcost.delete(0, tk.END)
                #self.Rechlabcost.insert(0, "{:.2f}".format(rech_lab_cost))
                
                # Optional: Clear or set Labour_Uplift to 0% if required
                #self.Labour_Uplift.delete(0, tk.END)
                #self.Labour_Uplift.insert(0, "0.00%")
                
            #except ValueError:
                #print("Invalid input for Rechlabcost.")
        
        #else:
            # For other suppliers, calculate uplift based on the new Rechlabcost
            #try:
                #rech_lab_cost = float(self.Rechlabcost.get())
                #labour_cost = float(self.Labourcost.get())
                
                # Calculate uplift percentage if labour cost is greater than 0
                #if labour_cost > 0:
                    #uplift_percentage = ((rech_lab_cost - labour_cost) / labour_cost) * 100
                    # Update Labour_Uplift entry
                    #self.Labour_Uplift.delete(0, tk.END)
                    #elf.Labour_Uplift.insert(0, "{:.2f}%".format(uplift_percentage))
                #else:
                    # Restore original uplift or set it to 0% if invalid
                    #if hasattr(self, 'original_labour_uplift_percentage'):
                        #self.Labour_Uplift.delete(0, tk.END)
                        #self.Labour_Uplift.insert(0, f"{self.original_labour_uplift_percentage}%")
                    #else:
                        #self.Labour_Uplift.delete(0, tk.END)
                        #self.Labour_Uplift.insert(0, "0.00%")
                
            #except ValueError:
                #print("Invalid input for Rechlabcost or Labour Cost.")

    def reset_labour_uplift(self, event):
     if hasattr(self, 'original_labour_uplift_percentage'):
        self.Labour_Uplift.delete(0, tk.END)
        self.Labour_Uplift.insert(0, f"{self.original_labour_uplift_percentage}%")
     self.Rechlabcost.delete(0, tk.END)
     self.Rechlabcost.insert(0, "{:.2f}".format(self.original_rechlabcost))
    
    def undo_parts_uplift(self, event):
        try:
            self.Parts_Uplift.edit_undo()  # Perform the undo operation
        except tk.TclError:
            print("Nothing to undo in Parts_Uplift")

    def undo_labour_uplift(self, event):
        try:
            self.Labour_Uplift.edit_undo()  # Perform the undo operation
        except tk.TclError:
            print("Nothing to undo in Labour_Uplift")
     
     
   
     
     
        
     
    
    def update_rtscostcategory(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.Reasoncosttypes.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        type_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        self.categories = KBACKEND.Fetch_Categories_By_Type(type_id)
        
        # Format data for the dropdown
        self.formatted_categories = [f"{row[1]} - {row[2]}" for row in self.categories]
        
        self.rtscostcategory.delete(0,tk.END)
        self.category_cost.delete(0,tk.END)
        # Update rtscostcategory dropdown with the new data
        self.rtscostcategory['values'] = self.formatted_categories
        #if formatted_categories:
            #self.rtscostcategory.current(0) 
    
    def update_rtscostproducts(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.rtscostcategory.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        category_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        self.categories = KBACKEND.Fetch_Products_By_Category(category_id)
        
        # Format data for the dropdown
        self.formatted_categoriespro = [f"{row[1]} - {row[2]}" for row in self.categories]
        
        self.category_cost.delete(0,tk.END)
        # Update rtscostcategory dropdown with the new data
        self.category_cost['values'] = self.formatted_categoriespro
        #if formatted_categories:
            #self.category_cost.current(0) 

    def filter_rts_category(self,event):
       current_text = self.rtscostcategory.get()
       if current_text == '':
            self.rtscostcategory['values'] = self.formatted_categories
       else:
            filtered_category = [category for category in self.formatted_categories if current_text.lower() in category.lower()]
            self.rtscostcategory['values'] = filtered_category

    def filter_rts_products(self,event):
       current_text = self.category_cost.get()
       if current_text == '':
            self.category_cost['values'] = self.formatted_categoriespro
       else:
            filtered_category = [product for product in self.formatted_categoriespro if current_text.lower() in product.lower()]
            self.category_cost['values'] = filtered_category

    def clicking_the_costlines(self,event):
       selected_item = self.Table_treep.selection()
       if selected_item:
         # Extract the index of the selected item
         item_index = self.Table_treep.index(selected_item[0])

         Line_added = item_index + 1

         PO_Number= self.Approvalentryp.get()

         open_costline_details= KBACKEND.open_costlines_page(PO_Number,Line_added)

         self.open_costlinespage_with_clickedrow(open_costline_details)
    
    def open_costlinespage_with_clickedrow(self,open_costline_details):
     self.costline_windowclick = tk.Toplevel(self.root)
     self.costline_windowclick.title("Cost Line Form")
     self.costline_windowclick.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.costline_windowclick.geometry(f"800x620+{offset_x}+{offset_y}")

      #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_windowclick, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png"]
     tool_tips=["Exit the window"]
     for idcost, (path,tooltip_text) in enumerate(zip(image_paths,tool_tips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcost: self.costline_iconsclick(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)
     
     dataframe = Frame(self.costline_windowclick, bd=3, relief=tk.RIDGE)
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=35, width=780, height=90)

     Reg_details= self.Reg_no_entryp.get()
     Reg_no = Label(dataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.costlineregclick = ttk.Entry(dataframe,width=18)
     self.costlineregclick.grid(row=0, column=1,padx=10,pady=3)
     self.costlineregclick.insert(0,Reg_details)
     self.attach_context_menu(self.costlineregclick)
     self.costlineregclick.state(['disabled'])
     
     Repairer_name=self.Repairerentryp.get()
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=2)
     self.costlinerepclick = ttk.Entry(dataframe, width=18)
     self.costlinerepclick.grid(row=0, column=3,padx=10,pady=3)
     self.costlinerepclick.insert(0,Repairer_name)
     self.attach_context_menu(self.costlinerepclick)
     self.costlinerepclick.state(['disabled'])
     
     System_number= self.Approvalentryp.get()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=4)
     self.systemcostclick = ttk.Entry(dataframe, width=18)
     self.systemcostclick.grid(row=0, column=5,padx=10,pady=3)
     self.systemcostclick.insert(0,System_number)
     self.attach_context_menu(self.systemcostclick)
     self.systemcostclick.state(['disabled'])
     
     Ododetails=self.Odometerentryp.get()
     Odometerveh = Label(dataframe, text="Vehicle Odometer:")
     Odometerveh.grid(row=1, column=0,pady=5)
     self.odovehcostclick = ttk.Entry(dataframe, width=18)
     self.odovehcostclick.grid(row=1, column=1)
     self.odovehcostclick.insert(0,Ododetails)
     self.attach_context_menu(self.odovehcostclick)
     self.odovehcostclick.state(['disabled'])
     
     Repairer_accountdetails= self.Accountentryp.get()
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=1, column=2,pady=5)
     self.repaccocostclick = ttk.Entry(dataframe, width=18)
     self.repaccocostclick.grid(row=1, column=3)
     self.repaccocostclick.insert(0,Repairer_accountdetails)
     self.attach_context_menu(self.repaccocostclick)
     self.repaccocostclick.state(['disabled'])

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=1,column=4)
     self.Line_createdentryclick=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentryclick.grid(row=1,column=5)
     if open_costline_details is not None:
      self.Line_createdentryvalueclick= open_costline_details.get('Line_Added')
     else:
        self.Line_createdentryvalueclick= None
     if self.Line_createdentryvalueclick:
      self.Line_createdentryclick.set_date(self.Line_createdentryvalueclick)
     else:
      self.Line_createdentryclick.set_date(None)

     self.Line_createdentryclick.state(['disabled'])

     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=2,column=0)
     self.Line_createdbyclick= ttk.Entry(dataframe,width=18)
     self.Line_createdbyclick.grid(row=2,column=1)
     if open_costline_details is not None:
        self.Line_createdbyclickvalue= open_costline_details.get('Added_By')
     else:
        self.Line_createdbyclickvalue= None
     self.Line_createdbyclick.insert(0, self.Line_createdbyclickvalue if self.Line_createdbyclickvalue is not None else"")
     self.Line_createdbyclick.state(['disabled'])

     Seconddataframe = Frame(self.costline_windowclick, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=125, width=780, height=70)

     Reason = Label(Seconddataframe, text="Types:")
     Reason.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Reasoncosttypesclick = ttk.Combobox(Seconddataframe,width=20)
     self.Reasoncosttypesclick.grid(row=0, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Reasoncosttypesclickid= open_costline_details.get('Type_ID')
        self.Reasoncosttypesclickdesc= open_costline_details.get('Type_Desc')
        self.reasoncosttypesclickvalue = f"{self.Reasoncosttypesclickid}-{self.Reasoncosttypesclickdesc}" if self.Reasoncosttypesclickid and self.Reasoncosttypesclickdesc else None
     else:
        self.reasoncosttypesclickvalue= None

     self.Reasoncosttypesclick.insert(0,self.reasoncosttypesclickvalue if self.reasoncosttypesclickvalue is not None else"")
     self.attach_context_menu(self.Reasoncosttypesclick)
     self.Reasoncosttypesclick.state(['disabled'])

     RTS = Label(Seconddataframe, text="Category")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategoryclick = ttk.Combobox(Seconddataframe,width=20)
     self.rtscostcategoryclick.grid(row=0, column=3,padx=10,pady=3)
     if open_costline_details is not None:
        self.rtscostcategoryid= open_costline_details.get('Category_ID')
        self.rtscostcategorydesc= open_costline_details.get('Cat_Desc')
        self.rtscostcategoryclickvalue=f"{self.rtscostcategoryid}-{self.rtscostcategorydesc}" if self.rtscostcategoryid and self.rtscostcategorydesc else None
     else:
        self.rtscostcategoryclickvalue= None
     self.rtscostcategoryclick.insert(0,self.rtscostcategoryclickvalue if self.rtscostcategoryclickvalue is not None else"")
     self.attach_context_menu(self.rtscostcategoryclick)
     self.rtscostcategoryclick.state(['disabled'])

     category_label = tk.Label(Seconddataframe, text="Products:")
     category_label.grid(row=0, column=4)
     self.category_productsclick = ttk.Combobox(Seconddataframe, width=20)
     self.category_productsclick.grid(row=0, column=5, padx=15, pady=3)
     if open_costline_details is not None:
      self.costlineproductid=open_costline_details.get('Product_ID')
      self.costlineproductdesc=open_costline_details.get('Product_Desc')
      self.costlineproductsvalue=f"{self.costlineproductid}-{self.costlineproductdesc}" if self.costlineproductid and self.costlineproductdesc else None
     else:
      self.costlineproductsvalue=None
     self.category_productsclick.insert(0,self.costlineproductsvalue if self.costlineproductsvalue is not None else"")
     self.category_productsclick.state(['disabled'])
     
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscostclick = ttk.Entry(Seconddataframe, width=18)
     self.analysiscostclick.grid(row=1, column=1)
     if open_costline_details is not None:
        self.analysiscostclickvalue= open_costline_details.get('Pf_depot')
     else:
        self.analysiscostclickvalue=None
     self.analysiscostclick.insert(0,self.analysiscostclickvalue if self.analysiscostclickvalue is not None else"")
     self.attach_context_menu(self.analysiscostclick)
     self.analysiscostclick.state(['disabled'])

     Thirddataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=195, width=780, height=50)

     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscostclick = ttk.Entry(Thirddataframe,width=13)
     self.Partscostclick.grid(row=0, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Partscostclickvalue= open_costline_details.get('Parts_cost')
     else:
        self.Partscostclickvalue= None
     self.Partscostclick.insert(0,self.Partscostclickvalue if self.Partscostclickvalue is not None else"")
     self.attach_context_menu(self.Partscostclick)
     self.Partscostclick.state(['disabled'])

     Labour_Hours= Label(Thirddataframe,text="Labour Hours:")
     Labour_Hours.grid(row=0,column=2)
     self.Labour_Hoursclick= ttk.Entry(Thirddataframe,width=13)
     self.Labour_Hoursclick.grid(row=0,column=3,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labour_Hoursclickvalue= open_costline_details.get('Labour_Hours')
     else:
        self.Labour_Hoursclickvalue=None
     self.Labour_Hoursclick.insert(0,self.Labour_Hoursclickvalue if self.Labour_Hoursclickvalue is not None else"")
     self.attach_context_menu(self.Labour_Hoursclick)
     self.Labour_Hoursclick.state(['disabled'])

     Labour_Rate=Label(Thirddataframe,text="Labour Rate")
     Labour_Rate.grid(row=0,column=4)
     self.Labour_Rateclick=ttk.Entry(Thirddataframe,width=13)
     self.Labour_Rateclick.grid(row=0,column=5,padx=15, pady=3)
     if open_costline_details is not None:
        self.Labour_Rateclickvalue= open_costline_details.get('Labour_Rate')
     else:
        self.Labour_Rateclickvalue=None
     self.Labour_Rateclick.insert(0,self.Labour_Rateclickvalue if self.Labour_Rateclickvalue is not None else "0.00")
     self.attach_context_menu(self.Labour_Rateclick)
     self.Labour_Rateclick.state(['disabled'])

     Labour = Label(Thirddataframe, text="Labour Value:")
     Labour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Labourcostclick = ttk.Entry(Thirddataframe,width=13)
     self.Labourcostclick.grid(row=0, column=7,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labourcostclickvalue= open_costline_details.get('labour_cost')
     else:
        self.Labourcostclickvalue= None
     self.Labourcostclick.insert(0,self.Labourcostclickvalue if self.Labourcostclickvalue is not None else"")
     self.attach_context_menu(self.Labourcostclick)
     self.Labourcostclick.state(['disabled'])

     fourthdataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Recharge")
     fourthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fourthdataframe.place(x=0, y=245, width=780, height=80)


     Parts_Uplift=Label(fourthdataframe,text="Parts Uplift")
     Parts_Uplift.grid(row=0,column=0)
     self.Parts_Upliftclick= ttk.Entry(fourthdataframe,width=13)
     self.Parts_Upliftclick.grid(row=0,column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Parts_Upliftclickvalue= open_costline_details.get('Parts_Uplift')
     else:
        self.Parts_Upliftclickvalue=None
     self.Parts_Upliftclick.insert(0,self.Parts_Upliftclickvalue if self.Parts_Upliftclickvalue is not None else"")
     self.attach_context_menu(self.Parts_Upliftclick)
     self.Parts_Upliftclick.state(['disabled'])

     RechParts = Label(fourthdataframe, text="Rech.Parts:")
     RechParts.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechcostclick = ttk.Entry(fourthdataframe,width=13)
     self.Rechcostclick.grid(row=0, column=3,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechcostclickvalue= open_costline_details.get('Recharge_parts')
     else:
        self.Rechcostclickvalue= None
     self.Rechcostclick.insert(0,self.Rechcostclickvalue if self.Rechcostclickvalue is not None else"")
     self.attach_context_menu(self.Rechcostclick)
     self.Rechcostclick.state(['disabled'])
     
     Labour_Uplift= Label(fourthdataframe,text="Labour Uplift")
     Labour_Uplift.grid(row=0,column=4)
     self.Labour_Upliftclick= ttk.Entry(fourthdataframe,width=13)
     self.Labour_Upliftclick.grid(row=0,column=5,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labour_Upliftclickvalue=open_costline_details.get('Labour_Uplift')
     else:
        self.Labour_Upliftclickvalue=None
     self.Labour_Upliftclick.insert(0,self.Labour_Upliftclickvalue if self.Labour_Upliftclickvalue is not None else"")
     self.attach_context_menu(self.Labour_Upliftclick)
     self.Labour_Upliftclick.state(['disabled'])

     Rechlabour = Label(fourthdataframe, text="Rech.labour:")
     Rechlabour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechlabcostclick = ttk.Entry(fourthdataframe,width=11)
     self.Rechlabcostclick.grid(row=0, column=7,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechlabcostclickvalue= open_costline_details.get('Recharge_labour')
     else:
        self.Rechlabcostclickvalue= None
     self.Rechlabcostclick.insert(0,self.Rechlabcostclickvalue if self.Rechlabcostclickvalue is not None else"")
     self.attach_context_menu(self.Rechlabcostclick)
     self.Rechlabcostclick.state(['disabled'])

     Rechposted = Label(fourthdataframe, text="Rech.posted:")
     Rechposted.grid(row=1, column=0)
     
     self.rechposted_varclick = tk.BooleanVar()
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechpostedcostclick = ttk.Checkbutton(fourthdataframe,variable=self.rechposted_varclick)
     self.Rechpostedcostclick.grid(row=1, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechpostedcostclickvalue= open_costline_details.get('Recharge_invoiced')
     else:
        self.Rechpostedcostclickvalue= None
     if self.Rechpostedcostclickvalue == 'Y':
        checkbox_checked = True
     else:
         checkbox_checked = False
     self.rechposted_varclick.set(checkbox_checked)
     self.Rechpostedcostclick.state(['disabled'])

     Rechposteddate = Label(fourthdataframe, text="Rech.posted date:")
     Rechposteddate.grid(row=1, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechposteddatecostclick = ttk.Entry(fourthdataframe, width=12)
     self.Rechposteddatecostclick.grid(row=1, column=3,padx=15,pady=3)

     if open_costline_details is not None:
        self.Rechposteddatecostclickvalue= open_costline_details.get('Recharge_posted')
     else:
        self.Rechposteddatecostclickvalue= None


      # Format the date to dd/mm/yyyy
     if self.Rechposteddatecostclickvalue is not None:
      if isinstance(self.Rechposteddatecostclickvalue, datetime):
        # Format the date to dd/mm/yyyy
        formatted_date = self.Rechposteddatecostclickvalue.strftime("%d/%m/%Y")
      else:
        formatted_date = ""  # Handle case where the value is not a datetime object
         
     else:
      formatted_date = ""

     # Insert the formatted date into the Entry widget
     self.Rechposteddatecostclick.insert(0, formatted_date)
     self.Rechposteddatecostclick.state(['disabled'])
     
     #self.Rechposteddatecostclick.insert(0,self.Rechposteddatecostclickvalue if self.Rechposteddatecostclickvalue is not None else"")
     #self.Rechposteddatecostclick.state(['disabled'])

  
     
     Customer_PO= self.Customer_Ponum.get()
     Customerreference = Label(fourthdataframe, text="Customer ref:")
     Customerreference.grid(row=1, column=4)
     self.customerreferencecostclick = ttk.Entry(fourthdataframe,width=11)
     self.customerreferencecostclick.grid(row=1, column=5,padx=15,pady=3)
     self.customerreferencecostclick.insert(0,Customer_PO if Customer_PO is not None else"")
     self.customerreferencecostclick.state(['disabled'])

     fifthdataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=375, width=780, height=115)

     self.notescostclick= tk.Text(fifthdataframe,width=80, height='5',wrap='word')
     self.notescostclick.grid(row=0,column=0,sticky='w',padx=5)
     if open_costline_details is not None:
        self.notescostclickvalue= open_costline_details.get('Notes')
     else:
        self.notescostclickvalue= None
     self.notescostclick.insert("1.0",self.notescostclickvalue if self.notescostclickvalue is not None else"")
     self.attach_context_menu(self.notescostclick)
     self.notescostclick['state']='disabled'

     Sixthdataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Recharge text")
     Sixthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Sixthdataframe.place(x=0, y=490, width=780, height=115)

     self.rechargecostclick= tk.Text(Sixthdataframe,width=80, height='5',wrap='word')
     self.rechargecostclick.grid(row=0,column=0,sticky='w',padx=5)
     if open_costline_details is not None:
        self.rechargecostclickvalue= open_costline_details.get('Recharge_text')
     else:
        self.rechargecostclickvalue= None
     self.rechargecostclick.insert("1.0",self.rechargecostclickvalue if self.rechargecostclickvalue is not None else"")
     self.rechargecostclick['state']='disabled'

     Seventhdataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Customer Specifics")
     Seventhdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seventhdataframe.place(x=0, y=325, width=780, height=50)
     
     self.Customer_specificsclick=ttk.Entry(Seventhdataframe,width=100)
     self.Customer_specificsclick.grid(row=0,column=2)

     cust_id=self.Customer_Identry.get()
     result=KBACKEND.check_customer_specific(cust_id)
     if result:
        self.Customer_specificsclick.delete(0, tk.END)
        self.Customer_specificsclick.insert(0,"This Customer had SPECIAL RECHARGE RATES")
     else:
        self.Customer_specificsclick.delete(0, tk.END)
        self.Customer_specificsclick.insert(0,"This Customer did not have SPECAL RECHARGE RATES")
     self.Customer_specificsclick.state(['disabled'])

    def costline_iconsclick(self,index):
       if index==1:
          self.close_the_windowclick()
    
    def close_the_windowclick(self):
       self.costline_windowclick.destroy()
    
    def clear_date_entry(self):
        # Clear the displayed date in the DateEntry widget
        self.Rechposteddatecost.delete(0, "end")
    
    def toggle_date_entry(self):
        if self.rechposted_var.get():
            self.Rechposteddatecost.set_date(datetime.now().strftime("%d/%m/%Y"))
            self.rechposted_value.set("Y")
        else:
           self.clear_date_entry()
           self.rechposted_value.set("N")




    def costline_icons(self,index):
       if index==1:
          self.close_the_costline()
       elif index==2:
          self.save_the_costlines()
    
    def close_the_costline(self):
       self.costline_window.destroy()

    def get_combined_datetime(self):
        if not self.rechposted_var.get():
            return None  # Return None if the checkbutton is not checked
        
        # Proceed with date retrieval and combination
        date = self.Rechposteddatecost.get_date()
        current_time = datetime.now().time()
        combined_datetime = datetime.combine(date, current_time)
        return combined_datetime
    
    def save_the_costlines(self):
       PO_Number=self.systemcost.get()
       KBACKEND.generate_line_number(PO_Number)
       Line_Added= self.Line_createdentry.get_date()
       Time= datetime.now().time()

       bothdateandtime= datetime.combine(Line_Added, Time)
       Added_By=self.Line_createdby.get()
       #RTS_code= self.Reasoncost.get()
       #RTS_Desc=self.rtscost.get()
       Type=self.Reasoncosttypes.get()
       if Type:
          type_id=Type.split(' - ')[0]
       else:
          type_id=None
       Category=self.rtscostcategory.get()
       if Category:
          Category_id= Category.split(' - ')[0]
       else:
          Category_id=None
       Products=self.category_cost.get()
       if Products:
          Product_id=Products.split(' - ')[0]
       else:
          Product_id=None
       

       Typetwo=self.Reasoncosttypes.get()
       if Typetwo:
          type_idtwo=Typetwo.split(' - ')[1]
       else:
          type_idtwo=None
       Categorytwo=self.rtscostcategory.get()
       if Categorytwo:
          Category_idtwo= Categorytwo.split(' - ')[1]
       else:
          Category_idtwo=None
       Productstwo=self.category_cost.get()
       if Productstwo:
          Product_idtwo=Productstwo.split(' - ')[1]
       else:
          Product_idtwo=None 
       
       combined_value = f"{type_idtwo} | {Category_idtwo} | {Product_idtwo}"

       PF_Depot=self.analysiscost.get()
       Parts_Cost=self.Partscost.get()
       Labour_Hours=self.Labour_Hours.get()
       Labour_Rate=self.Labour_Rate.get()
       Labour_cost=self.Labourcost.get()
       Parts_Uplift=self.Parts_Uplift.get()
       Labour_Uplift=self.Labour_Uplift.get()
       Recharge_parts=self.Rechcost.get()
       Recharge_cost=self.Rechlabcost.get()
       Recharge_invoiced=self.rechposted_value.get()

       combined_datetime = self.get_combined_datetime()
       Notes=self.notescost.get("1.0", tk.END)
       Recharge_text= self.rechargecost.get("1.0", tk.END)

       Supplier_Name=self.Repairerentryp.get()

       Productsone=self.category_cost.get()
       if Productsone:
          Product_description=Productsone.split(' - ')[1]
       else:
          Product_description=None
 
       if type_id and Category_id and Product_id:
        KBACKEND.store_cost_lines(PO_Number,bothdateandtime,Added_By,PF_Depot,Parts_Cost,Labour_Hours,Labour_Rate,
                            Labour_cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_cost,Recharge_invoiced,combined_datetime,
                                 Notes,Recharge_text,type_id,Category_id,Product_id,Supplier_Name,Product_description,combined_value)
        self.costline_window.destroy()
       else:
        # This will display a message box centered over the parent window (self.costline_windowone)
        self.costline_window.lift()  # Bring the main window to the top
        self.costline_window.attributes('-topmost', True)  # Ensure it's on top
        messagebox.showwarning(
        "Missing Information", 
        "All required fields (Type, Category, and Products) must be entered before saving. Please complete all details.",
        parent=self.costline_window
        )
        self.costline_window.attributes('-topmost', False) 
       
       self.Table_treep.delete(*self.Table_treep.get_children())

       Approval_number= self.Approvalentryp.get()

       Costlines= KBACKEND.populate_costlines(Approval_number)

       if Costlines:
          for incident in Costlines:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel   


             self.Table_treep.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
          self.populate_all_the_costlines()
       Insert_purchase= KBACKEND.retrieve_last_purchase_and_populate(Approval_number)

       self.costlinestable.delete(*self.costlinestable.get_children())

       if Insert_purchase:
          for Purchase in Insert_purchase:
            Repaired= Purchase.get("Repaired")
            if Repaired is not None:
             Repaired_date = Repaired.date()
            else:
             print("Repaired is None, cannot access 'date' attribute.")
            Repaired_date = None  # or some default value           
            Odometer=Purchase.get("Odometer")
            Supplier_Name= Purchase.get("Supplier")
            Incident_Link= Purchase.get("Incident_Link")
            Total_Parts=Purchase.get("Total_parts")
            Total_labours=Purchase.get("Total_labours")
            Total_cost= Total_Parts + Total_labours
            Recharge_parts= Purchase.get("Recharge_parts")
            Recharge_labours= Purchase.get("Recharge_labours")
            Total_Recharge= Recharge_parts+ Recharge_labours
            PO_number= Purchase.get("Approval")
            Products= Purchase.get("Products")

            self.costlinestable.insert("", "end", values=(Repaired_date,Odometer,Supplier_Name,Incident_Link,
                                                         Total_cost,Total_Recharge,PO_number,Products))
       self.populate_top_purchase_order()
             
        
      

    
    def populate_supplier_detailsp(self,event=None):
        selected_supplier= self.Repairerentryp.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.Accountentryp.delete(0,tk.END)
              self.Accountentryp.insert(0,row[0])

        


         
    def initilisecostlinefunctionalities(self,index):
       if index==1:
          self.exit_the_purchaseorders()
       if index==2:
          self.save_the_purchase_information()
       if index==3:
          self.add_new_ponumberfirst()
    
    def exit_the_purchaseorders(self):
       self.purchasehistory.destroy()
    
    def save_the_purchase_information(self):
        PO_Number=self.Approvalentryp.get()
        i_number= self.Numberentry.get()
        # Getting the selected date from the DateEntry widget
        Pocreated_date = self.Issuedentryp.get_date()
    
        # Getting the current time
        current_time = datetime.now().time()
    
        # Combining selected date and current time into a datetime object
        combined_datetime = datetime.combine(Pocreated_date, current_time)

        Created_By= self.Po_createdby.get()

        Supplier_No= self.Accountentryp.get()

        Order_Category= self.Order_cat.get()

        Fleet_No= self.fleetnumbercost.get()

        Odometer= self.Odometerentryp.get()

        Customer_PO= self.Customer_Ponum.get()

       
        Kofax_Scan= self.Kofaxno.get()

        Igloo_invoice=self.Igloono.get()

        Supplier_Name=self.Repairerentryp.get()

        Repaired_Date=self.Repairedentryp.get_date()

        Time= datetime.now().time()

        Repaired_Datetime= datetime.combine(Repaired_Date,Time)

        Registration= self.Reg_no_entryp.get()

        KBACKEND.store_the_purchase_orderinfo(PO_Number,i_number,combined_datetime,Created_By,Supplier_No,
                                              Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,Supplier_Name,Repaired_Datetime,Registration)
    def add_new_ponumberfirst(self):
       self.Repairerentryp.delete(0,"end")
       self.Accountentryp.delete(0,"end")
       self.Approvalentryp.state(['!disabled'])
       self.Approvalentryp.delete(0,"end")
       self.Issuedentryp.delete(0,"end")
       self.Po_createdby.state(['!disabled'])
       self.Po_createdby.delete(0,"end")
       self.fleetnumbercost.delete(0,"end")
       self.Odometerentryp.state(['!disabled'])
       self.Odometerentryp.delete(0,"end")
       self.Repairedentryp.delete(0,"end")
       self.Order_cat.delete(0,"end")
       self.Customer_Ponum.delete(0,"end")
       self.Kofaxno.delete(0,"end")
       self.Igloono.delete(0,"end")

       self.Repairerentryp.focus_set()
       self.Repairerentryp.insert(0,"")
       self.Accountentryp.insert(0,"")
       Approval_number=KBACKEND.generate_purchase_order_number()
       self.Approvalentryp.insert(0,Approval_number)
       self.Approvalentryp.state(['disabled'])
       current_date = datetime.now().strftime("%d/%m/%Y")
       self.Issuedentryp.set_date(current_date)
       current_user=getuser()
       self.Po_createdby.insert(0,current_user)
       self.Po_createdby.state(['disabled'])
       fleet_no=self.Fleet_entry.get()
       self.fleetnumbercost.insert(0,fleet_no)
       Odo=self.Odo.get()
       self.Odometerentryp.state(['!disabled'])
       self.Odometerentryp.insert(0,Odo)
       self.Odometerentryp.state(['disabled'])
       self.Repairedentryp.set_date(current_date)
       self.Order_cat.insert(0,"")
       self.Customer_Ponum.insert(0,"")
       self.Kofaxno.insert(0,"")
       self.Igloono.insert(0,"")

       result=KBACKEND.generate_purchase_order_number()
       
       I_Number=self.Numberentry.get()
       KBACKEND.save_the_Purchasenumber(result,I_Number)

       self.Table_treep.delete(*self.Table_treep.get_children())

    
    def onclick_for_purchaseorder_table(self,event):
       item = self.costlinestable.identify_row(event.y)
       print("Clicked on item:", item)
    
      
    
       # Check if item is valid
       if item:
         # Set focus to the clicked row
         self.costlinestable.focus(item)

       # Get the values from the clicked row
       values = self.costlinestable.item(item, "values")

       

        # Check if the values list has at least 7 elements
       if len(values) > 6:
         approval_number = values[6]
         
       else:
         approval_number = None  # or handle the case appropriately
   
   
       costline_details= KBACKEND.retrieve_costlines_for_approvalnumber(approval_number)
       
       if costline_details:
       
        self.open_costlines_for_purchaseorder_number(costline_details,approval_number)
       
       else:
        print("NO DETAILS FOUND")
    
    def open_costlines_for_purchaseorder_number(self,costline_details,approval_number):
        fetch_details=KBACKEND.fetching_selected_approvaldetails(approval_number)
        if fetch_details:
           
           self.Repairerentryp.delete(0, "end")
           self.Accountentryp.delete(0,"end")
           self.Approvalentryp.state(['!disabled'])
           self.Approvalentryp.delete(0,"end")
           self.Issuedentryp.delete(0,"end")
           self.Po_createdby.state(['!disabled'])
           self.Po_createdby.delete(0,"end")
           self.fleetnumbercost.delete(0,"end")
           self.Odometerentryp.delete(0,"end")
           self.Repairedentryp.delete(0,"end")
           self.Order_cat.delete(0,"end")
           self.Customer_Ponum.delete(0,"end")
           self.Kofaxno.delete(0,"end")
           self.Igloono.delete(0,"end")
           
           Repairervalue=fetch_details.get('Supplier_Name')
           self.Repairerentryp.insert(0, Repairervalue if Repairervalue is not None else "")
           Accountvalue= fetch_details.get('Supplier_No')
           self.Accountentryp.insert(0,Accountvalue if Accountvalue is not None else"")
           Approvalvalue= fetch_details.get('PO_Number')
           self.Approvalentryp.insert(0,Approvalvalue if Approvalvalue is not None else"")
           self.Approvalentryp.state(['disabled'])
           Issuedvalue= fetch_details.get('PO_Created')
           self.Issuedentryp.set_date(Issuedvalue if Issuedvalue is not None else None)
           Po_createdvalue=fetch_details.get('Created_By')#current_user= getuser()
           self.Po_createdby.insert(0,Po_createdvalue if Po_createdvalue is not None else "")
           self.Po_createdby.state(['disabled'])
           fleetvalue=fetch_details.get('Fleet_No')
           self.fleetnumbercost.insert(0,fleetvalue if fleetvalue is not None else"")
           Odometervalue= fetch_details.get('Odometer')
           self.Odometerentryp.insert(0,Odometervalue if Odometervalue is not None else"")

           Repairervaluep= fetch_details.get('Repaired') 
           if Repairervalue is not None:
               self.Repairedentryp.set_date(Repairervaluep)
           else:
               self.Repairedentryp.set_date(None)

           Categoryvalue=fetch_details.get('Order_Category')
           self.Order_cat.insert(0,Categoryvalue if Categoryvalue is not None else"")

            
           Customervalue=fetch_details.get('Customer_PO')
           self.Customer_Ponum.insert(0,Customervalue if Customervalue is not None else"")

           Kofaxvalue=fetch_details.get('Kofax_Scan_No')
           self.Kofaxno.insert(0,Kofaxvalue if Kofaxvalue is not None else"")

           Igloovalue=fetch_details.get('Igloo_Invoice_No')
           self.Igloono.insert(0,Igloovalue if Igloovalue is not None else"")

        self.Table_treep.delete(*self.Table_treep.get_children())
        if costline_details:
         for incident in costline_details:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel

             self.Table_treep.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
        else:
           print("NO DETAILS FOUND")

    def open_costlines_without_incidents(self):
     self.costline_windowwithoutincident = tk.Toplevel(self.root)
     self.costline_windowwithoutincident.title("Cost Line Form without Incident Linked")
     self.costline_windowwithoutincident.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.costline_windowwithoutincident.geometry(f"800x380+{offset_x}+{offset_y}")

     #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_windowwithoutincident, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png", "icon24.png"]
     tool_tips= ["Exit the window","Save"]
     for idcostnoinci, (path,tooltip_text) in enumerate(zip(image_paths,tool_tips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcostnoinci: self.costline_iconswithoutincident(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)

     dataframe = Frame(self.costline_windowwithoutincident, bd=3, relief=tk.RIDGE)
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=35, width=790, height=75)
     
     sup=KBACKEND.fetch_supplier_details()
     self.suppliernoinci = [row[1] for row in sup]
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=0)
     self.costlinerepnoinci = ttk.Combobox(dataframe, width=18,values=self.suppliernoinci)
     self.costlinerepnoinci.grid(row=0, column=1,padx=10,pady=3)
     self.attach_context_menu(self.costlinerepnoinci)
     self.costlinerepnoinci.bind("<<ComboboxSelected>>", self.populate_supplier_detailswithoutinci)
     self.costlinerepnoinci.bind("<KeyRelease>", self.filter_supplier_listwithoutinci)
     
     Po_Number=KBACKEND.generate_purchase_order_number()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=2)
     self.systemcostnoinci = Entry(dataframe, width=18)
     self.systemcostnoinci.grid(row=0, column=3,padx=10,pady=3)
     self.systemcostnoinci.insert(0,Po_Number)
     self.attach_context_menu(self.systemcostnoinci)
     
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=0, column=4,pady=5)
     self.repaccocostnoinci = Entry(dataframe, width=18)
     self.repaccocostnoinci.grid(row=0, column=5)
     self.attach_context_menu(self.repaccocostnoinci)

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=0,column=6)
     self.Line_createdentrynoinci=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentrynoinci.grid(row=0,column=7)
     self.Line_createdentrynoinci.state(['disabled'])
     
     current_time = datetime.now().strftime("%H:%M")
     Time_created= Label(dataframe,text="Time")
     Time_created.grid(row=1,column=0)
     self.Time_createdentrynoinci=ttk.Entry(dataframe,width=18)
     self.Time_createdentrynoinci.grid(row=1,column=1)
     self.Time_createdentrynoinci.insert(0,current_time)
     self.Time_createdentrynoinci.state(['disabled'])
     
     current_user=getuser()
     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=1,column=2)
     self.Line_createdbynoinci=ttk.Entry(dataframe,width=18)
     self.Line_createdbynoinci.grid(row=1,column=3)
     self.Line_createdbynoinci.insert(0,current_user)
     self.Line_createdbynoinci.state(['disabled'])

     Seconddataframe = Frame(self.costline_windowwithoutincident, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=115, width=790, height=70)

     Reason = Label(Seconddataframe, text="Types*:",fg="red")
     Reason.grid(row=0, column=0)
     Po_Types=KBACKEND.Fetch_PO_Types_noinci()
     formatted_data = [f"{row[0]} - {row[1]}" for row in Po_Types]
     self.Reasoncosttypeswithoutinci = ttk.Combobox(Seconddataframe,width=20,values=formatted_data)
     self.Reasoncosttypeswithoutinci.grid(row=0, column=1,padx=15,pady=3)
     self.Reasoncosttypeswithoutinci.bind("<<ComboboxSelected>>", self.update_rtscostcategorywithoutinci)
     
     RTS = Label(Seconddataframe, text="Category*:",fg="red")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategorywithoutinci = ttk.Combobox(Seconddataframe,width=20)
     self.rtscostcategorywithoutinci.grid(row=0, column=3,padx=10,pady=3)
     self.rtscostcategorywithoutinci.bind("<<ComboboxSelected>>",self.update_rtscostproductswithoutinci)
     self.rtscostcategorywithoutinci.bind("<KeyRelease>",self.filter_rts_categorywithoutinci)
     self.attach_context_menu(self.rtscostcategorywithoutinci)

     category_label = tk.Label(Seconddataframe, text="Products*:",fg="red")
     category_label.grid(row=0, column=4)

     self.category_costwithoutinci = ttk.Combobox(Seconddataframe, width=20)
     self.category_costwithoutinci.grid(row=0, column=5, padx=15, pady=3)
     self.category_costwithoutinci.bind("<KeyRelease>",self.filter_rts_productswithoutinci)
     self.attach_context_menu(self.category_costwithoutinci)

     rowss = KBACKEND.fetch_locations_and_descriptions()
     self.depotdetailswithoutinci = [row[1] for row in rowss]  # First column values for dropdown
     Analysis = Label(Seconddataframe, text="PF Depot*:",fg="red")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscostwithoutinci = ttk.Combobox(Seconddataframe, width=20,values=self.depotdetailswithoutinci)
     self.analysiscostwithoutinci.grid(row=1, column=1)
     self.attach_context_menu(self.analysiscostwithoutinci)

     Thirddataframe = LabelFrame(self.costline_windowwithoutincident, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=185, width=790, height=50)

     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscostwithoutinci = Entry(Thirddataframe,width=18)
     self.Partscostwithoutinci.grid(row=0, column=1,padx=15,pady=3)
     self.Partscostwithoutinci.insert(0,"0.00")
     self.attach_context_menu(self.Partscostwithoutinci)

     fifthdataframe = LabelFrame(self.costline_windowwithoutincident, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=235, width=790, height=135)

     self.notescostwithoutinci= Text(fifthdataframe,width=80, height='6',wrap='word')
     self.notescostwithoutinci.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.notescostwithoutinci)

     result=KBACKEND.generate_purchase_order_number()
       
     I_Number= 1
     KBACKEND.save_the_Purchasenumber(result,I_Number)

   
    def populate_supplier_detailswithoutinci(self,event=None):
        selected_supplier= self.costlinerepnoinci.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.repaccocostnoinci.delete(0,tk.END)
              self.repaccocostnoinci.insert(0,row[0])
    def filter_supplier_listwithoutinci(self, event):
        # Function to filter supplier list based on user input
        current_text = self.costlinerepnoinci.get()
        if current_text == '':
            self.costlinerepnoinci['values'] = self.suppliernoinci
        else:
            filtered_suppliers = [supplier for supplier in self.suppliernoinci if current_text.lower() in supplier.lower()]
            self.costlinerepnoinci['values'] = filtered_suppliers
    def update_rtscostcategorywithoutinci(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.Reasoncosttypeswithoutinci.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        type_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        categories = KBACKEND.Fetch_Categories_By_Type(type_id)
        
        # Format data for the dropdown
        self.formatted_categoriescatwithoutinci = [f"{row[1]} - {row[2]}" for row in categories]
        
        self.rtscostcategorywithoutinci.delete(0,tk.END)
        self.category_costwithoutinci.delete(0,tk.END)
        # Update rtscostcategory dropdown with the new data
        self.rtscostcategorywithoutinci['values'] = self.formatted_categoriescatwithoutinci
        #if formatted_categories:
            #self.rtscostcategory.current(0) 
    
    def update_rtscostproductswithoutinci(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.rtscostcategorywithoutinci.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        category_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        categories = KBACKEND.Fetch_Products_By_Category(category_id)
        
        # Format data for the dropdown
        self.formatted_categoriesprodwithoutinci = [f"{row[1]} - {row[2]}" for row in categories]

        # Update rtscostcategory dropdown with the new data
        self.category_costwithoutinci.delete(0,tk.END)
        self.category_costwithoutinci['values'] = self.formatted_categoriesprodwithoutinci
        # if self.formatted_categoriesprodwithoutinci:
            # self.category_costwithoutinci.current(0) 
   
    def filter_rts_categorywithoutinci(self,event):
       current_text = self.rtscostcategorywithoutinci.get()
       if current_text == '':
            self.rtscostcategorywithoutinci['values'] = self.formatted_categoriescatwithoutinci
       else:
            filtered_category = [category for category in self.formatted_categoriescatwithoutinci if current_text.lower() in category.lower()]
            self.rtscostcategorywithoutinci['values'] = filtered_category

    def filter_rts_productswithoutinci(self,event):
       current_text = self.category_costwithoutinci.get()
       if current_text == '':
            self.category_costwithoutinci['values'] = self.formatted_categoriesprodwithoutinci
       else:
            filtered_category = [product for product in self.formatted_categoriesprodwithoutinci if current_text.lower() in product.lower()]
            self.category_costwithoutinci['values'] = filtered_category
    



    def costline_iconswithoutincident(self,index):
       if index==1:
          self.close_the_costlineswithoutincident_window()
       if index==2:
          self.save_the_costlineswithoutincident_details()

    def close_the_costlineswithoutincident_window(self):
       self.costline_windowwithoutincident.destroy()
    def save_the_costlineswithoutincident_details(self):
       SupplierName_withoutinci= self.costlinerepnoinci.get()
       PO_Number=self.systemcostnoinci.get()
       KBACKEND.generate_line_number(PO_Number)
       SupplierNo=self.repaccocostnoinci.get()
       Line_Created= self.Line_createdentrynoinci.get_date()
       Time_Created= self.Time_createdentrynoinci.get()

       current_time = datetime.strptime(Time_Created, "%H:%M").time()
    
       # Combining selected date and current time into a datetime object
       combined_datetime = datetime.combine(Line_Created, current_time)

       Created_By=self.Line_createdbynoinci.get()

       Types=self.Reasoncosttypeswithoutinci.get()
       if Types:
          type_id=Types.split(' - ')[0]
          type_desc=Types.split(' - ')[1]
       else:
          type_id=None
          type_desc=None

       Category=self.rtscostcategorywithoutinci.get()
       if Category:
          Category_id=Category.split(' - ')[0]
       else:
          Category_id=None

       Products= self.category_costwithoutinci.get()
       if Products:
          Product_id=Products.split(' - ')[0]
       else:
          Product_id=None

       Pf_Depot= self.analysiscostwithoutinci.get()
       
       
       fleet_value_to_store = None
       reg_value_to_store = None
       
       regandfleet = KBACKEND.retrieving_the_data_registration_and_fleet()
       for row in regandfleet:
        if row[0] == type_desc and row[1] == Pf_Depot:
         fleet_value_to_store = row[2]
         reg_value_to_store = row[3]
         break
       if fleet_value_to_store is None or reg_value_to_store is None:
        print("No matching data found.")
       else:
        print(f"Fleet Value: {fleet_value_to_store}, Registration Value: {reg_value_to_store}")

      

          
       Parts= self.Partscostwithoutinci.get()

       Notes= self.notescostwithoutinci.get("1.0", tk.END)

       Productstwo= self.category_costwithoutinci.get()
       if Productstwo:
          Product_Description=Productstwo.split(' - ')[0]
       else:
          Product_Description=None

       Typetwo=self.Reasoncosttypeswithoutinci.get()
       if Typetwo:
          type_idtwo=Typetwo.split(' - ')[1]
       else:
          type_idtwo=None
       Categorytwo=self.rtscostcategorywithoutinci.get()
       if Categorytwo:
          Category_idtwo= Categorytwo.split(' - ')[1]
       else:
          Category_idtwo=None
       Productsthree=self.category_costwithoutinci.get()
       if Productsthree:
          Product_idtwo=Productsthree.split(' - ')[1]
       else:
          Product_idtwo=None 
       
       combined_value = f"{type_idtwo} | {Category_idtwo} | {Product_idtwo}"

       if type_id and Category_id and fleet_value_to_store and reg_value_to_store and Pf_Depot:

        KBACKEND.store_the_costlines_withoutinci(SupplierName_withoutinci,PO_Number,SupplierNo,
                                                combined_datetime,Created_By,type_id,Category_id,
                                                Product_id,Pf_Depot,Parts,Notes,Product_Description,fleet_value_to_store,reg_value_to_store,combined_value)
        self.costline_windowwithoutincident.destroy()
       else:
        # This will display a message box centered over the parent window (self.costline_windowone)
        self.costline_windowwithoutincident.lift()  # Bring the main window to the top
        self.costline_windowwithoutincident.attributes('-topmost', True)  # Ensure it's on top
        messagebox.showwarning(
        "Missing Information", 
        "All required fields (Type, Category,Products and Depot) must be entered before saving. Please complete all details.",
        parent=self.costline_windowwithoutincident
        )
        self.costline_windowwithoutincident.attributes('-topmost', False) 
       











     ##########Incident listing in the front page########################
    ########### This clicks the data with a blue colour ###############
    def change_row_color(self, event):
     # Get the clicked row
     item = self.root.Kerride_table.identify_row(event.y)
     print("Clicked on item:", item)
    
     # Select the clicked row and configure tag for color
     self.root.Kerride_table.selection_set(item)
     print("Selected item:", self.root.Kerride_table.selection())
     self.root.Kerride_table.tag_configure("selected", background="lightblue")
    
     # Set focus to the clicked row
     self.root.Kerride_table.focus(item)
    
     
    
     # Extract the registration number from the clicked row
     registration_number = self.root.Kerride_table.item(item, "values")[3]  # Assuming registration number is the first column
     incident_number= self.root.Kerride_table.item(item, "values")[4]
     # Retrieve incident details based on the registration number
     incident_details = KBACKEND.retrieve_incident_details(registration_number,incident_number)
     additional_details=KBACKEND.fetch_additional_details(registration_number)
     
     if incident_details and additional_details:
        if self.form_window is not None:
                self.form_window.destroy()
        # Open the form window and populate it with incident details
        self.open_icon1_window_with_clicked_row_data(registration_number, incident_details,additional_details)
        self.root.iconify()
     else:
        print("No incident details found for the selected registration number.")
     
    ############ After the data is click this opens the incident page for that particular data########
    def open_icon1_window_with_clicked_row_data(self, reg_no, incident_details,additional_details):
     # Create a new window for the form
     self.form_window = tk.Toplevel(self.root)
     self.form_window.title("Incident Detail Form")
     self.form_window.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.form_window.geometry(f"800x660+{offset_x}+{offset_y}")

     #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.form_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png", "icon24.png","icon25.png","icon26.png"]
     tooltips = ["Exit the window", "Save","Create an Event","Open Purchase History"]

     for idin, (path,tooltip_text) in enumerate(zip(image_paths,tooltips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idin: self.open_incident_window(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)
    
    # Create frames for each page
         self.mainn_page = Frame(self.form_window)
         self.eventss_page = Frame(self.form_window)
         self.postincident_pagee = Frame(self.form_window)

    # Function to show main page
     def show_mainn_page():
        self.mainn_page.pack(fill="both", expand=True)
        self.eventss_page.pack_forget()
        self.postincident_pagee.pack_forget()

    # Function to show events page
     def show_eventss_page():
      self.mainn_page.pack_forget()
      self.eventss_page.pack(fill="both", expand=True)
      self.postincident_pagee.pack_forget()
      self.save_the_incident_details()

     def show_postincident_pagee():
      self.mainn_page.pack_forget()
      self.eventss_page.pack_forget()
      self.postincident_pagee.pack(fill="both",expand=True)
      self.save_the_incident_details()

     show_mainn_page()

      #Creating Buttons Frame for second pagE
     Buttonframe= Frame(self.form_window, relief=tk.RIDGE,)
     Buttonframe.place(x=0,y=27,width=780,height=40)

    # Create buttons
     mainn_button = tk.Button(Buttonframe, text="MAIN", command=show_mainn_page)
     mainn_button.pack(side=tk.LEFT, padx=1, pady=2)

     eventss_button = tk.Button(Buttonframe, text="EVENTS", command=show_eventss_page)
     eventss_button.pack(side=tk.LEFT, padx=1, pady=2)

     Post_button = tk.Button(Buttonframe, text="VIEW POST REPORT", command=show_postincident_pagee)
     Post_button.pack(side=tk.LEFT, padx=1, pady=2)

     vor_initial = incident_details.get('VOR', 'N')

        # Set the initial state based on incident_details
     if vor_initial == 'Y':
            self.big_buttontwo_var = tk.StringVar(value="Y")  # Value for "IN VOR"
            button_text = "VOR"
            button_color = "red"
     else:
            self.big_buttontwo_var = tk.StringVar(value="N")  # Value for "NO VOR"
            button_text = "NO VOR"
            button_color = "green"
     self.big_buttontwo = tk.Button(Buttonframe, text=button_text, bg=button_color, fg="white",command=self.toggle_vor_buttontwo,
                                     width=30,font=("Helvetica", 12, "bold"))
     self.big_buttontwo.pack(side=tk.LEFT, padx=50, pady=2)
     
     self.post_incident_reportsone=tk.Button(Buttonframe, text="Post Incident Reports",command=self.post_incident_reports_actionone)

     # Populate the form with the retrieved data
     self.populate_form(reg_no, incident_details,additional_details)

    def populate_form(self, reg_no, incident_details,additional_details):
     # Populate your form with the retrieved incident details

      # Mainn page components
     #First Data Frame for Vehicle Details
     firstdataframe = LabelFrame(self.mainn_page, bd=3, relief=tk.RIDGE,text="Vehicle Details")
     firstdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     firstdataframe.place(x=0, y=29, width=780, height=100) 

     #Registration and Entry for the first data frame
     Reg_no = tk.Label(firstdataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)
    
     self.reistrationentry = ttk.Entry(firstdataframe, width=15)
     self.reistrationentry.insert(0, incident_details.get('Registration', ''))
     self.reistrationentry.grid(row=0, column=1)
     self.reistrationentry.state(['disabled'])
     self.attach_context_menu(self.reistrationentry)

      #Creating an Entry for page 2
     self.Make_Mod = ttk.Entry(firstdataframe, width=30)
     self.Make_Mod.insert(0,additional_details.get('Make_Mod'))
     self.Make_Mod.grid(row=0, column=2,padx=70)
     self.Make_Mod.state(['disabled'])
     self.attach_context_menu(self.Make_Mod)

     self.lb3one = Label(firstdataframe, text="Driver name:",fg="Red")
     #self.lb3one.grid(row=0, column=3)
     self.Driverrentry = Entry(firstdataframe, width=18)
     #self.Driverrentry.grid(row=0, column=4)
     self.attach_context_menu(self.Driverrentry)

    # Retrieve the value
     self.Driverrvalue = incident_details.get('Driver_name')

    # Insert the value into the Entry widget
     self.Driverrentry.insert(0, self.Driverrvalue if self.Driverrvalue is not None else "")
     
     
     #Creating a Label and Entry for Fleet No:
     Fleett_No=Label(firstdataframe, text="Fleet No:")
     Fleett_No.grid(row=1, column=0,pady=6)
     self.fleett=ttk.Entry(firstdataframe,width=15)
     self.fleett.grid(row=1,column=1)
     self.attach_context_menu(self.fleett)
     self.fleettvalue=additional_details.get('fleet_no')
     self.fleett.insert(0,self.fleettvalue if self.fleettvalue is not None else"")
     self.fleett.state(['disabled'])
     
     self.view_fleett = Button(firstdataframe, text="View fleet info",width=12,command=self.open_fleet_infotwo)
     self.view_fleett.grid(row=2, column=0,padx=20)
     self.basee_url = "http://igloouk/Igloo"

     #Creating a Label and Entry for Vehicle loaded:

     lb3 = Label(firstdataframe, text="Vehicle loaded:")
     lb3.grid(row=2,column=1,padx=10)
     self.vehiclevar=tk.BooleanVar()
     self.Vehiclee_loaded=Checkbutton(firstdataframe,width=2,variable=self.vehiclevar)
     self.Vehiclee_loaded.grid(row=2,column=2,sticky='w')
     self.attach_context_menu(self.Vehiclee_loaded)
     self.vehiclevalue= incident_details.get('Vehicle_loaded',0)

     # Convert the retrieved value to boolean (1 for True, 0 for False)
     self.vehiclevalue = bool(self.vehiclevalue)

     # Set the state of the Checkbutton based on the retrieved value
     self.vehiclevar.set(self.vehiclevalue)
    
   

     #Creating a Label and Entry for Driver Phone:

     self.lb3phoneone = Label(firstdataframe, text="Phone:",fg="Red")
     #self.lb3phoneone.grid(row=1, column=3)
     self.Driverrphone = Entry(firstdataframe, width=18)
     #self.Driverrphone.grid(row=1, column=4)
     self.attach_context_menu(self.Driverrphone)
     self.Driverrphonevalue= incident_details.get('Driver_phone')
     self.Driverrphone.insert(0,self.Driverrphonevalue if self.Driverrphonevalue is not None else"")
     
     
     #Second Data Frame for Customer and Company Details 
     Seconddataframe= LabelFrame(self.mainn_page, bd=3, relief=tk.RIDGE,text="Customer/Company Details")
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0,y=130,width=780,height=100)

     #Creating Label for ID and entry
     self.Custidandcustnameinfoone=KBACKEND.fetch_all_the_cust_details()
     self.Custidonlyone=[row[0] for row in self.Custidandcustnameinfoone]
     Customer_Id = Label(Seconddataframe, text="Customer ID:", padx=3, pady=3)
     Customer_Id.grid(row=0, column=0)
     self.Customer_Identryy= ttk.Combobox(Seconddataframe, width=14,values=self.Custidonlyone)
     self.Customer_Identryy.grid(row=0, column=1)
     self.attach_context_menu(self.Customer_Identryy)
     self.Customer_Identryyvalue=incident_details.get('Customer Id')
     self.Customer_Identryy.insert(0,self.Customer_Identryyvalue if self.Customer_Identryyvalue is not 
                                   None else"")
     self.Customer_Identryy.bind("<KeyRelease>", self.filter_custid_listone)
     self.Customer_Identryy.bind("<<ComboboxSelected>>", self.populate_custname_basedon_idone)
     self.Customer_Identryy.focus_set()

     #Creating Label for Cust_Name and entry
     self.Custnameonlyone=[row[1] for row in self.Custidandcustnameinfoone]
     Cust_Name = Label(Seconddataframe, text="Name:", padx=3, pady=3)
     Cust_Name.grid(row=0, column=2)
     self.Cust_Namee_Entry= ttk.Combobox(Seconddataframe, width=14,values=self.Custnameonlyone)
     self.Cust_Namee_Entry.grid(row=0, column=3)
     self.attach_context_menu(self.Cust_Namee_Entry)
     self.Cust_Namee_Entryvalue= incident_details.get('Customer Name')
     self.Cust_Namee_Entry.insert(0,self.Cust_Namee_Entryvalue if self.Cust_Namee_Entryvalue is not
                                  None else"")
     self.Cust_Namee_Entry.bind("<KeyRelease>", self.filter_custname_listone)
     self.Cust_Namee_Entry.bind("<<ComboboxSelected>>", self.populate_custid_basedon_nameone)
     
     
     #Creating Label for Contract_No and Entry
     
     Contract_No = Label(Seconddataframe, text="Contract No:", padx=3, pady=3)
     Contract_No.grid(row=0, column=4)
     self.Contract_No_Entryy= Entry(Seconddataframe, width=14)
     self.Contract_No_Entryy.grid(row=0, column=5)
     self.attach_context_menu(self.Contract_No_Entryy)
     self.Contract_No_Entryyvalue= incident_details.get('Contract No')
     self.Contract_No_Entryy.insert(0,self.Contract_No_Entryyvalue if self.Contract_No_Entryyvalue is 
                                    not None else"")
     
     
      #Creating Label for Contact_Tel and Entry

     self.Contact_Telone = Label(Seconddataframe, text="Contact Tel:", padx=3, pady=3,fg="red")
     self.Contact_Telone.grid(row=1, column=2)
     self.Contact_Tel_Entryy= Entry(Seconddataframe, width=16)
     self.Contact_Tel_Entryy.grid(row=1, column=3)
     self.attach_context_menu(self.Contact_Tel_Entryy)
     self.Contact_Tel_Entryyvalue=incident_details.get('Contact_tel')
     self.Contact_Tel_Entryy.insert(0,self.Contact_Tel_Entryyvalue if self.Contact_Tel_Entryyvalue is 
                                    not None else"" )
     

    #Creating Label for Contact_Email and Entry

     self.Contact_Emailone = Label(Seconddataframe, text="Contact Email:", padx=3, pady=3,fg="red")
     self.Contact_Emailone.grid(row=1, column=4)
     self.Contact_Email_Entryy= Entry(Seconddataframe, width=14)
     self.Contact_Email_Entryy.grid(row=1, column=5)
     self.attach_context_menu(self.Contact_Email_Entryy)
     self.Contact_Email_Entryyvalue=incident_details.get('Contact_Email')
     self.Contact_Email_Entryy.insert(0,self.Contact_Email_Entryyvalue if self.Contact_Email_Entryyvalue
                                      is not None else"")
     

     #Creating Label for Contact_Name and Entry

     Contact_Name_Label=Label(Seconddataframe, text="Contact Name:",fg='red', padx=3, pady=3)
     Contact_Name_Label.grid(row=0, column=6)
     self.Contact_Name_Entryy= Entry(Seconddataframe, width=14)
     self.Contact_Name_Entryy.grid(row=0, column=7)
     self.attach_context_menu(self.Contact_Name_Entryy)
     self.Contact_Name_Entryyvalue=incident_details.get('Contact_name')
     self.Contact_Name_Entryy.insert(0,self.Contact_Name_Entryyvalue if self.Contact_Name_Entryyvalue is
                                     not None else"")
     

     #Creating Label for Customer_Defect_No and Entry

     Customer_DefNO=Label(Seconddataframe, text="Cust Def No:", padx=3, pady=3)
     Customer_DefNO.grid(row=1, column=6)
     self.Customer_defno_Entryy= Entry(Seconddataframe, width=14)
     self.Customer_defno_Entryy.grid(row=1, column=7)
     self.attach_context_menu(self.Customer_defno_Entryy)
     self.Customer_defno_Entryyvalue= incident_details.get('Cust_defect')
     self.Customer_defno_Entryy.insert(0,self.Customer_defno_Entryyvalue if self.Customer_defno_Entryyvalue
                                       is not None else"")


    

     #Creating Label for Contact_Method_ID AND Entry
     self.contactmethd= KBACKEND.fetch_contact_detais()
     self.contactdets=[row[1] for row in self.contactmethd]
     Contact_Method_Id=Label(Seconddataframe,text="Contact Method ID*:",fg="red",padx=3,pady=3)
     Contact_Method_Id.grid(row=1,column=0)
     self.Contact_Method_Entryy=ttk.Combobox(Seconddataframe,width=14,values=self.contactdets)
     self.Contact_Method_Entryy.grid(row=1,column=1)
     self.attach_context_menu(self.Contact_Method_Entryy)
     self.Contact_Email_Entryyvalue=incident_details.get('Contact_id')
     self.Contact_Method_Entryy.insert(0, self.Contact_Email_Entryyvalue if self.Contact_Email_Entryyvalue
                                       is not None else"")
     #self.Contact_Method_Entryy.bind("<<ComboboxSelected>>", self.on_contact_method_selectedone)
     #self.on_contact_method_selectedone()
     

     #Creating Label for Depot
     Depot=Label(Seconddataframe,text="Customer Depot",padx=3,pady=3)
     Depot.grid(row=2,column=0)
     self.Depotentryy=Entry(Seconddataframe,width=16)
     self.Depotentryy.grid(row=2,column=1)
     self.attach_context_menu(self.Depotentryy)
     self.Depotentryyvalue=additional_details.get('Customer_Depot')
     self.Depotentryy.insert(0,self.Depotentryyvalue if self.Depotentryyvalue is not None else"")
     
     
     #Creating a frame for incident details 
      
     ThirdDataframe= LabelFrame(self.mainn_page, bd=3, relief=tk.RIDGE,text="Incident Details")
     ThirdDataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     ThirdDataframe.place(x=0,y=230,width=780,height=345)

     #Creating a label and entry field for location
     Location= Label(ThirdDataframe, text="Location:")
     Location.grid(row=0, column=0,pady=(0,25),sticky='w')
     self.locaentryy= Text(ThirdDataframe,width=30, height='3',wrap='word')
     self.locaentryy.grid(row=0,column=1,columnspan=2,sticky='w')
     self.attach_context_menu(self.locaentryy)
     self.locaentryyvalue=incident_details.get('Defect_Address')
     self.locaentryy.insert("1.0",self.locaentryyvalue if self.locaentryyvalue is not None else"")

     self.view_mapp = Button(ThirdDataframe, text="View map",width=12,command=self.open_maptwo)
     self.view_mapp.grid(row=0, column=2,padx=5)
     self.homee_url = "https://www.google.com/maps"
     

     #Creating a label and Entry for Number

     Number= Label(ThirdDataframe,text="Number:")
     Number.grid(row=0,column=3,padx=3)
     self.Numberentryy=Entry(ThirdDataframe,width=15)
     self.Numberentryy.grid(row=0,column=4)
     self.attach_context_menu(self.Numberentryy)
     self.Numberentryyvalue=incident_details.get('Incident No')
     self.Numberentryy.insert(0, self.Numberentryyvalue if self.Numberentryyvalue is not None else"")
     
     
     #Creating Label and Entry for Date
     Date = Label(ThirdDataframe, text="Date", padx=5)
     Date.grid(row=1, column=3,padx=20,pady=4)
     self.dateeentry= DateEntry(ThirdDataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.dateeentry.grid(row=1, column=4,sticky='w')
     self.attach_context_menu(self.dateeentry)
     self.dateeentryvalue=incident_details.get('Date')
     self.dateeentry.set_date(self.dateeentryvalue if self.dateeentryvalue is not None else"")

     #current_time = datetime.now().strftime("%H:%M")
     Time= Label(ThirdDataframe,text= "Time",padx=5)
     Time.grid(row=2,column=3)
     self.modifiedtimetwo= ttk.Entry(ThirdDataframe,width=15)
     self.modifiedtimetwo.grid(row=2, column=4,sticky='w')
     incident_datetime=incident_details.get('Date')

     incident_time_str = incident_datetime.strftime("%H:%M")

     self.modifiedtimetwo.delete(0, 'end')  # Clear any existing content
     self.modifiedtimetwo.insert(0, incident_time_str)
     self.modifiedtimetwo.bind("<Button-1>", self.open_time_pickerone)

     
     
     #Creating Label and Entry for Time 

     Created_by = Label(ThirdDataframe, text="Created_By", padx=5)
     Created_by.grid(row=3, column=3)
     self.Timee= ttk.Entry(ThirdDataframe, width=15)
     self.Timee.grid(row=3, column=4,sticky='w')
     self.attach_context_menu(self.Timee)
     self.timeevalue=incident_details.get('Createdby')
     self.Timee.insert(0,self.timeevalue if self.timeevalue is not None else"")
     self.Timee.state(['disabled'])
     


     #Creating Label and Entry for Odometer

     Odo= Label(ThirdDataframe, text="Odometer", padx=5)
     Odo.grid(row=4, column=3)
     self.Odoentry= ttk.Entry(ThirdDataframe, width=13)
     self.Odoentry.grid(row=4, column=4,sticky='w')
     self.attach_context_menu(self.Odoentry)
     self.Odoentryvalue=incident_details.get('Odometer')
     self.Odoentry.insert(0,self.Odoentryvalue if self.Odoentryvalue is not None else"")
     self.Odoentry.bind("<FocusOut>", self.validate_odoone)
     self.Odoentry.bind("<Double-1>", self.reset_odoone) 

     

     #Creating Lable and Entry for Location:
     # Define the label
     self.Localabel = tk.Label(ThirdDataframe, text="Depot loc:", padx=5)
     self.Localabel.grid(row=5, column=3)

    # Define locaentry
     # Fetch data from the database using backend function
     rowss = KBACKEND.fetch_locations_and_descriptions()
     self.locations = [row[0] for row in rowss]  # First column values for dropdown
    # Define loca combobox
     self.locationn_1 = ttk.Combobox(ThirdDataframe, values=self.locations, width=15)
     self.locationn_1.grid(row=5, column=4, sticky='w')
     self.attach_context_menu(self.locationn_1)
     self.locationn_1value=additional_details.get('PF_Depot')
     self.locationn_1.insert(0,self.locationn_1value if self.locationn_1value is not None else"")
     #self.populate_location_descriptionn()
     

        # Define loca entry
     self.locationn_2 = tk.Entry(ThirdDataframe, width=15)
     self.locationn_2.grid(row=6, column=4, sticky='w', columnspan=4)
     self.attach_context_menu(self.locationn_2)
     self.locationn_1.bind("<<ComboboxSelected>>", self.populate_location_descriptionn)
     self.populate_location_descriptionn()

     #Creating a Lable and Entry for Type

     self.categorydetails= KBACKEND.fetch_cat_details()
     self.categorydescription= [row[1]for row in self.categorydetails]

     Typee= Label(ThirdDataframe, text="Category *:",fg="red")
     Typee.grid(row=1,column=0,padx=5,pady=6)
     self.CatEntryy= ttk.Combobox(ThirdDataframe, values=self.categorydescription, width=13)
     self.CatEntryy.grid(row=1, column=1, pady=4, sticky='w') 
     self.attach_context_menu(self.CatEntryy)
     self.CatEntryyvalue=incident_details.get('Cat')
     self.CatEntryy.insert(0,self.CatEntryyvalue if self.CatEntryyvalue is not None else"")

     loctype= Label(ThirdDataframe, text="Incident Loc *:",fg="red")
     loctype.grid(row=2,column=0,padx=5,pady=6)
     self.locationdetails=KBACKEND.fetch_Location_details()
     self.locationdescription= [row[1] for row in self.locationdetails]
     self.LolEntryy=ttk.Combobox(ThirdDataframe,values=self.locationdescription,width=13)
     self.LolEntryy.grid(row=2,column=1,pady=4,sticky='w')
     self.attach_context_menu(self.LolEntryy)
     self.LolEntryyvalue=incident_details.get('Loca')
     self.LolEntryy.insert(0,self.LolEntryyvalue if self.LolEntryyvalue is not None else"")
     self.LolEntryy.bind("<<ComboboxSelected>>", self.on_location_selectedone)
     #self.on_location_selectedone()

     Chartype= Label(ThirdDataframe, text="Recharge *:",fg="red")
     Chartype.grid(row=3,column=0,padx=5,pady=2)
     self.chargedetails=KBACKEND.fetch_charge_details()
     self.Chargedescription= [row[1] for row in self.chargedetails]
     self.Chargeentryy=ttk.Combobox(ThirdDataframe,values=self.Chargedescription,width=13)
     self.Chargeentryy.grid(row=3,column=1,pady=2,sticky='w')
     self.attach_context_menu(self.Chargeentryy)
     self.Chargeentryyvalue=incident_details.get('Charge')
     self.Chargeentryy.insert(0,self.Chargeentryyvalue if self.Chargeentryyvalue is not None else"")
     self.Chargeentryy.bind("<<ComboboxSelected>>", self.on_recharge_selectedone)
     self.on_recharge_selectedone()

     Incidenttypeone= Label(ThirdDataframe, text="Type *:",fg="red")
     Incidenttypeone.grid(row=4,column=0,padx=5,pady=2)
     self.Typedetailsone=KBACKEND.fetch_Incidenttype_details()
     self.Typedetailsdescone=[row[1] for row in self.Typedetailsone]
     self.Incitypeentryone=ttk.Combobox(ThirdDataframe,values=self.Typedetailsdescone,width=13)
     self.Incitypeentryone.grid(row=4,column=1,pady=2,sticky='w')
     self.Incitypeentryonevalue= incident_details.get('Inc_Type')
     self.Incitypeentryone.insert(0,self.Incitypeentryonevalue if self.Incitypeentryonevalue is not None else"")
     
     
     #Creating a Label and Entry for Fault Description
     Fault= Label(ThirdDataframe, text="Fault Description:")
     Fault.grid(row=5, column=0, pady=(0,25),sticky='w')
     self.Faultentryy= Text(ThirdDataframe,width=30, height='3',wrap='word')
     self.Faultentryy.grid(row=5,column=1,sticky='w')
     self.attach_context_menu(self.Faultentryy)
     self.Faultentryyvalue=incident_details['Defectdesc']
     self.Faultentryy.insert("1.0",self.Faultentryyvalue if self.Faultentryyvalue is not None else"")
     
     #Creating a Lable and Entry for Status

     self.rowsss= KBACKEND.fetch_status_details()
     self.Statuss= [row[1] for row in self.rowsss]
     Statuss= Label(ThirdDataframe, text="Status *:",fg="red")
     Statuss.grid(row=6,column=0,padx=2)
     self.StatussEntryy= ttk.Combobox(ThirdDataframe, values=self.Statuss, width=25)
     self.StatussEntryy.grid(row=6, column=1, padx=2,pady=2, sticky='w')
     self.attach_context_menu(self.StatussEntryy)
     self.StatussEntryyvalue= incident_details.get('Status')
     self.StatussEntryy.insert(0,self.StatussEntryyvalue if self.StatussEntryyvalue is not None else"")
     self.StatussEntryy.bind('<<ComboboxSelected>>', self.on_status_selectedone)
     self.on_status_selectedone()

     self.Attendance_Deffone= Label(ThirdDataframe, text="Attendance_Deferred")
     #self.Attendance_Deff.grid(row=6,column=0)
     self.attendance_vari=tk.BooleanVar()
     self.AttendanceEntryy= ttk.Checkbutton(ThirdDataframe, variable=self.attendance_vari)
     #self.AttendanceEntryy.grid(row=6, column=1, sticky='w')
     self.attach_context_menu(self.AttendanceEntryy)
     self.AttendanceEntryvalue= incident_details.get('Attendance',0)
     
     self.AttendanceEntryvalue=bool(self.AttendanceEntryvalue)
     self.attendance_vari.set(self.AttendanceEntryvalue)
     
     self.Deffered = Label(ThirdDataframe, text='Deferred To')
     today = datetime.today().date()
     #self.Deffered.grid(row=7, column=0, padx=2, sticky='w')
     self.Deferred_Too = DateEntry(ThirdDataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy',mindate=today)
     #self.Deferred_Too.grid(row=7, column=1, padx=2, sticky='w')
     self.attach_context_menu(self.Deferred_Too)
     self.Deferred_Tovalue= incident_details.get('Deferred')
     if self.Deferred_Tovalue is not None:
          self.Deferred_Tovaluedate= self.Deferred_Tovalue.date()
     else:
          self.Deferred_Tovaluedate=None
     self.Deferred_Too.set_date(self.Deferred_Tovaluedate)

     self.Deff_timeee=Label(ThirdDataframe,text='Deferred To Time')
     #self.Deff_time.grid(row=8,column=0,padx=2, sticky='w')
     self.Deferred_Timetwo= Entry(ThirdDataframe,width=15)
     #self.Deferred_Timetwo.grid(row=8,column=1,sticky='w')
     self.Deferred_Timetwovalue=incident_details.get('Deferred')
     current_time= datetime.now().strftime("%H:%M")
     if self.Deferred_Timetwovalue is not None:
         self.Deferred_TimetwoTime= self.Deferred_Timetwovalue.strftime('%H:%M')
     else:
        self.Deferred_TimetwoTime= current_time
     self.Deferred_Timetwo.insert(0,self.Deferred_TimetwoTime if self.Deferred_TimetwoTime is not None else current_time)
     self.Deferred_Timetwo.bind("<Button-1>", self.open_time_picker_deffone)
     self.attach_context_menu(self.Deferred_Timetwo)


     whatwords = Label(ThirdDataframe, text='Defect_loc_W3W')
     whatwords.grid(row=7, column=3,sticky='w')
     self.whatwordsentryy = Entry(ThirdDataframe, width=30)
     self.whatwordsentryy.grid(row=7, column=4, sticky='w') 
     self.attach_context_menu(self.whatwordsentryy)
     self.whatwordsentryyvalue= incident_details.get('Whatwords')
     self.whatwordsentryy.insert(0,self.whatwordsentryyvalue if self.whatwordsentryyvalue is not None else"")

     self.whatt= tk.Button(ThirdDataframe, text="View map", width=12,command=self.open_what_maptwo)
     self.whatt.grid(row=8, column=4, columnspan=2, pady=5)
     self.whatt_url = "https://what3words.com"
     
     self.on_location_selectedone()
     
     #Creating Frame for Supplier details
     Fourthdataframe=LabelFrame(self.mainn_page,bd=3,relief=tk.RIDGE,text="Supplier Details")
     Fourthdataframe.pack(side=tk.TOP,padx=8,pady=3, anchor="nw")
     Fourthdataframe.place(x=0,y=575,width=780,height=50)
     
     #Creating label and Entry for Name:
     supp=KBACKEND.fetch_supplier_details()
     self.supplier = [row[1] for row in supp]
     
     self.supplierno=[row[0] for row in supp]
     Namesup= Label(Fourthdataframe, text="Supplier No:")
     Namesup.grid(row=0,column=2,padx=5)
     self.nameentryy= ttk.Combobox(Fourthdataframe,value=self.supplierno,width=30)
     self.nameentryy.grid(row=0,column=3,padx=5)
     self.Suppliernamevalue= incident_details.get('Supplier_No')
     self.nameentryy.insert(0,self.Suppliernamevalue if self.Suppliernamevalue is not None else"")
     self.attach_context_menu(self.nameentryy)
     #self.nameentryy.bind("<<ComboboxSelected>>", self.populate_supplier_details_two)
     
    
     
      #Creating label and Entry for Contat:
     Contactsup= Label(Fourthdataframe, text="Supplier Name:")
     Contactsup.grid(row=0,column=0,padx=5,pady=5)
     self.Contactentryy= ttk.Combobox(Fourthdataframe,values=self.supplier,width=30)
     self.Contactentryy.grid(row=0,column=1,padx=5,pady=5)
     self.attach_context_menu(self.Contactentryy)
     self.Contactentryy.bind("<KeyRelease>", self.filter_supplier_list_two)
     self.nameentryy.bind("<<ComboboxSelected>>", self.populate_supplier_details_two)
     self.Contactentryy.bind("<<ComboboxSelected>>", self.populate_supplier_detailss)
     
     
     
     

     Phonesup= Label(Fourthdataframe, text="Phone:")
     Phonesup.grid(row=0,column=4,padx=5)
     self.Phoneentryy= ttk.Entry(Fourthdataframe,width=17)
     self.Phoneentryy.grid(row=0,column=5,padx=5)
     self.attach_context_menu(self.Phoneentryy)
     self.nameentryy.bind("<<ComboboxSelected>>", self.populate_supplier_details_two)
     self.populate_supplier_details_two()

     self.widgetstwootab=[]

     self.widgetstwootab.append(self.Customer_Identryy)
     self.widgetstwootab.append(self.Cust_Namee_Entry)
     self.widgetstwootab.append(self.Contract_No_Entryy)
     self.widgetstwootab.append(self.Contact_Name_Entryy)
     self.widgetstwootab.append(self.Contact_Method_Entryy)
     self.widgetstwootab.append(self.Contact_Tel_Entryy)
     self.widgetstwootab.append(self.Contact_Email_Entryy)
     self.widgetstwootab.append(self.Customer_defno_Entryy)
     self.widgetstwootab.append(self.Depotentryy)
     self.widgetstwootab.append(self.locaentryy)
     self.widgetstwootab.append(self.view_mapp)
     self.widgetstwootab.append(self.Numberentryy)
     self.widgetstwootab.append(self.CatEntryy)
     self.widgetstwootab.append(self.dateeentry)
     self.widgetstwootab.append(self.LolEntryy)
     self.widgetstwootab.append(self.modifiedtimetwo)
     self.widgetstwootab.append(self.Chargeentryy)
     self.widgetstwootab.append(self.Timee)
     self.widgetstwootab.append(self.Incitypeentryone)
     self.widgetstwootab.append(self.Odoentry)
     self.widgetstwootab.append(self.Faultentryy)
     self.widgetstwootab.append(self.locationn_1)
     self.widgetstwootab.append(self.StatussEntryy)
     self.widgetstwootab.append(self.locationn_2)
     self.widgetstwootab.append(self.AttendanceEntryy)
     self.widgetstwootab.append(self.whatwordsentryy)
     self.widgetstwootab.append(self.whatt)
     self.widgetstwootab.append(self.Deferred_Too)
     self.widgetstwootab.append(self.Deferred_Timetwo)
     self.widgetstwootab.append(self.Contactentryy)
     self.widgetstwootab.append(self.nameentryy)
     self.widgetstwootab.append(self.Phoneentryy)

     for widget in self.widgetstwootab:
            widget.bind("<Tab>", self.focus_next_widgetonee)
            widget.bind("<Shift-Tab>", self.focus_previous_widgetonee)


     
     
     #Retrieving all the events_information :

     EventsFrame= LabelFrame(self.eventss_page, relief=tk.RIDGE,text="Events")
     EventsFrame.place(x=0,y=30,width=780,height=500)
    
     
     self.eventss_tree = ttk.Treeview(EventsFrame, columns=("Created", "Time1", "By1", "Event Type", "Event Action", "Notes", "Last Updated", "Time2","By2", "Follow-Up", "Time3","By3", "Action"),show="headings")
     self.eventss_tree.pack(fill="both", expand=True)

     self.eventss_tree.heading("Created", text="Created")
     self.eventss_tree.heading("Time1", text="Time1")
     self.eventss_tree.heading("By1", text="By1")
     self.eventss_tree.heading("Event Type", text="Event Type")
     self.eventss_tree.heading("Event Action", text="Event Action")
     self.eventss_tree.heading("Notes", text="Notes")
     self.eventss_tree.heading("Last Updated", text="Last Updated")
     self.eventss_tree.heading("Time2", text="Time2")
     self.eventss_tree.heading("By2",text="By2")
     self.eventss_tree.heading("Follow-Up", text="Follow-Up")
     self.eventss_tree.heading("Time3", text="Time3")
     self.eventss_tree.heading("By3",text="By3")
     self.eventss_tree.heading("Action", text="Action")

     self.eventss_tree.column("Created", width=90)
     self.eventss_tree.column("Time1", width=70)
     self.eventss_tree.column("By1", width=60)
     self.eventss_tree.column("Event Type", width=80)
     self.eventss_tree.column("Event Action", width=80)
     self.eventss_tree.column("Notes", width=200)
     self.eventss_tree.column("Last Updated", width=90)
     self.eventss_tree.column("Time2", width=70)
     self.eventss_tree.column("By2",width=60)
     self.eventss_tree.column("Follow-Up", width= 70)
     self.eventss_tree.column("Time3",width= 70)
     self.eventss_tree.column("By3",width= 60)
     self.eventss_tree.column("Action",width= 70)
     
     
     #Simulate adding some data to the tree
     self.scrollbarr_y = ttk.Scrollbar(EventsFrame, orient="vertical", command=self.eventss_tree.yview)
     self.scrollbarr_y.pack(side="right", fill="y")
     self.eventss_tree.configure(yscrollcommand=self.scrollbarr_y.set)

     self.scrollbarr_x = ttk.Scrollbar(EventsFrame, orient="horizontal", command=self.eventss_tree.xview)
     self.scrollbarr_x.pack(side="bottom", fill="x")
     self.eventss_tree.configure(xscrollcommand=self.scrollbarr_x.set)

     self.populate_events_tree()

     self.eventss_tree.bind("<<TreeviewSelect>>", self.on_row_selected)

     PostincidentFrame= LabelFrame(self.postincident_pagee, relief=tk.RIDGE,text="Post Incident Report")
     PostincidentFrame.place(x=0,y=30,width=780,height=300)

     self.Post_incident_treee = ttk.Treeview(PostincidentFrame, columns=("Incident_Number","Date","Time","Created By","Incident Category","Comments"),show="headings")
     self.Post_incident_treee.pack(fill="both", expand=True)

     self.Post_incident_treee.heading("Incident_Number", text="Incident_Number")
     self.Post_incident_treee.heading("Date", text="Date")
     self.Post_incident_treee.heading("Time", text="Time")
     self.Post_incident_treee.heading("Created By", text="Created By")
     self.Post_incident_treee.heading("Incident Category", text="Incident Category")
     self.Post_incident_treee.heading("Comments", text="Comments")
     

     self.Post_incident_treee.column("Incident_Number", width=90)
     self.Post_incident_treee.column("Date", width=70)
     self.Post_incident_treee.column("Time", width=60)
     self.Post_incident_treee.column("Created By", width=80)
     self.Post_incident_treee.column("Incident Category", width=80)
     self.Post_incident_treee.column("Comments", width=200)
     self.Post_incident_treee.bind("<<TreeviewSelect>>",self.clicking_the_postreports)
     self.populate_the_post_incident_reports()
   
    def focus_next_widgetonee(self, event):
        """Move focus to the next widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetstwootab.index(widget)
        next_index = (current_index + 1) % len(self.widgetstwootab)
        self.widgetstwootab[next_index].focus_set()
        return "break"  # Prevent default behavior

    def focus_previous_widgetonee(self, event):
        """Move focus to the previous widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetstwootab.index(widget)
        previous_index = (current_index - 1) % len(self.widgetstwootab)
        self.widgetstwootab[previous_index].focus_set()
        return "break"
    def toggle_vor_buttontwo(self):
     # Get the incident number from the entry field
     Incident_No = self.Numberentryy.get()

     # Get the current state of the button and toggle it
     if self.big_buttontwo_var.get() == "Y":
        # Button was in "NO VOR" state, change to "VOR" (red)
        self.big_buttontwo_var.set("N")
        self.big_buttontwo.config(text="NOT VOR", bg="green", fg="white",font=("Helvetica", 12, "bold"))
        
        
        self.create_event_listnew()
        KBACKEND.generate_event_number(Incident_No)

        # Date and time for event creation
        date_str = self.dateeentry.get()  
        time_str = self.modifiedtimetwo.get()
        datetime_str = f"{date_str} {time_str}"
        datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

        # Insert event details for VOR
        self.Event_type_entrynew.insert(0, "VOR")
        First_event_tostore = 13
        self.Event_details_entrynew.insert("1.0", "VEHICLE NOT VOR")
        Event_Notes = self.Event_details_entrynew.get("1.0", tk.END)

        # Set next event details
        self.Type_nextevent_entrynew.insert(0, "UPDATE")
        Second_event_tostore = 12

        # Handle follow-up datetime (add 30 minutes)
        datetime_objj = datetime.strptime(f"{self.dateeentry.get()} {self.modifiedtimetwo.get()}", "%d/%m/%Y %H:%M")
        datetime_objj_plus_30 = datetime_objj + timedelta(minutes=30)
        datetime_strr_plus_30 = datetime_objj_plus_30.strftime("%Y-%m-%d %H:%M:%S")

        # Get current user
        current_user = getuser()
        self.Action_required_entrynew.insert(0, current_user)
        Created_by = self.Action_required_entrynew.get()
        Ownerof = self.Owner_entrynew.get()

        # Store VOR event in the backend
        KBACKEND.store_event_detailstwoo(Incident_No, datetime_obj, First_event_tostore, Event_Notes,
                                         Second_event_tostore, datetime_strr_plus_30, Created_by, Ownerof)
        self.icon3_windownew.destroy()

     else:
        # Button was in "VOR" state, change to "NO VOR" (green)
        self.big_buttontwo_var.set("Y")
        self.big_buttontwo.config(text="VOR", bg="red", fg="white",font=("Helvetica", 12, "bold"))

        self.create_event_listnew()
        KBACKEND.generate_event_number(Incident_No)

        # Date and time for event creation
        date_str = self.dateeentry.get()
        time_str = self.modifiedtimetwo.get()
        datetime_str = f"{date_str} {time_str}"
        datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

        # Insert event details for NO VOR
        self.Event_type_entrynew.insert(0, "VOR")
        First_event_tostore = 13
        self.Event_details_entrynew.insert("1.0", "VEHICLE VOR")
        Event_Notes = self.Event_details_entrynew.get("1.0", tk.END)

        # Set next event details
        self.Type_nextevent_entrynew.insert(0, "UPDATE")
        Second_event_tostore = 12

        # Handle follow-up datetime (add 30 minutes)
        datetime_objj = datetime.strptime(f"{self.dateeentry.get()} {self.modifiedtimetwo.get()}", "%d/%m/%Y %H:%M")
        datetime_objj_plus_30 = datetime_objj + timedelta(minutes=30)
        datetime_strr_plus_30 = datetime_objj_plus_30.strftime("%Y-%m-%d %H:%M:%S")

        # Get current user
        current_user = getuser()
        self.Action_required_entrynew.insert(0, current_user)
        Created_by = self.Action_required_entrynew.get()
        Ownerof = self.Owner_entrynew.get()

        # Store NO VOR event in the backend
        KBACKEND.store_event_detailstwoo(Incident_No, datetime_obj, First_event_tostore, Event_Notes,
                                         Second_event_tostore, datetime_strr_plus_30, Created_by, Ownerof)
        self.icon3_windownew.destroy()

    # Fetch and update event details in the tree
     event_details = KBACKEND.fetch_all_events(Incident_No)
     self.eventss_tree.delete(*self.eventss_tree.get_children())

     if event_details:
        for event in event_details:
            Event_created = event.get('Created')
            Created_date = Event_created.date()
            Created_time = Event_created.time()
            Notes = event.get('Notes')
            Last_updated = event.get('Last Updated')
            Last_updated_date = Last_updated.date()
            Last_updated_time = Last_updated.time()
            Follow_up = event.get('Follow up')
            Follow_up_date = Follow_up.date()
            follow_up_time = Follow_up.time()
            Event_Description = event.get('Event_Description')
            Next_Event_Description = event.get('Next_Event_Description')
            Created = event.get('Created_By')
            Own = event.get('Owner')

            self.eventss_tree.insert("", "end", values=(Created_date, Created_time, Created, Event_Description, "",
                Notes, Last_updated_date, Last_updated_time, Own, Follow_up_date, follow_up_time, Own, Next_Event_Description))
            
            self.eventss_tree.bind("<<TreeviewSelect>>", self.on_row_selected)
        self.populate_events_tree()
    
    def open_time_pickerone(self, event):
        # Create new window for time selection
        self.time_windowone = tk.Toplevel(self.root)
        self.time_windowone.title("Select Time") 
        self.time_windowone.grab_set()  

        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
        offset_x = root_x + 50  # You can adjust this offset value
        offset_y = root_y + 50  # You can adjust this offset value

        # Set the position of the registration window to be relative to the main window
        self.time_windowone.geometry(f"250x170+{offset_x}+{offset_y}")

        # Styling the popup window (Center alignment, padding)
        self.time_windowone.configure(bg="lightblue")
        frame = ttk.Frame(self.time_windowone, padding=10)
        frame.grid(row=0, column=0, padx=20, pady=20)

        # Hour and Minute selection
        hours = [f"{i:02}" for i in range(24)]  # Hours: 00 to 23
        minutes = [f"{i:02}" for i in range(0, 60, 5)]  # Minutes: 00, 05, 10, ..., 55

        # Dropdown for Hour
        ttk.Label(frame, text="Hour").grid(row=0, column=0, padx=5, pady=5, sticky='w')
        self.hour_comboboxone = ttk.Combobox(frame, values=hours, width=5)
        self.hour_comboboxone.grid(row=0, column=1, padx=5, pady=5)
        self.hour_comboboxone.set(datetime.now().strftime("%H"))

        # Dropdown for Minute
        ttk.Label(frame, text="Minute").grid(row=1, column=0, padx=5, pady=5, sticky='w')
        self.minute_comboboxone = ttk.Combobox(frame, values=minutes, width=5)
        self.minute_comboboxone.grid(row=1, column=1, padx=5, pady=5)
        self.minute_comboboxone.set(datetime.now().strftime("%M"))

        # Confirm Button to set the selected time
        confirm_button = ttk.Button(self.time_windowone, text="Set Time", command=self.set_timeoner)
        confirm_button.grid(row=2, column=0, padx=10, pady=10)

        # Make the popup movable and independent
        
        self.time_windowone.grab_set()  # Prevent interaction with main window until popup is closed
        
    # Function to set the time in the entry box
    def set_timeoner(self):
        selected_hour = self.hour_comboboxone.get()
        selected_minute = self.minute_comboboxone.get()

        # Format time as HH:MM
        formatted_time = f"{selected_hour}:{selected_minute}"

        # Set the formatted time in the modifiedtime entry and close the popup
        self.modifiedtimetwo.config(state='normal')  # Allow editing temporarily
        self.modifiedtimetwo.delete(0, tk.END)  # Clear current value
        self.modifiedtimetwo.insert(0, formatted_time)  # Insert selected time
        self.modifiedtimetwo.config(state='readonly')  # Make it readonly again

        # Close the popup window
        self.time_windowone.destroy()
    def open_time_picker_deffone(self, event):
        # Create new window for time selection
        self.time_windowdeffone = tk.Toplevel(self.root)
        self.time_windowdeffone.title("Select Time")
        self.time_windowdeffone.grab_set()
        
        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
        offset_x = root_x + 50  # You can adjust this offset value
        offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
        self.time_windowdeffone.geometry(f"250x170+{offset_x}+{offset_y}")  # Ensure the popup is modal (prevents interaction with the main window)

        # Styling the popup window (Center alignment, padding)
        self.time_windowdeffone.configure(bg="lightblue")
        frame = ttk.Frame(self.time_windowdeffone, padding=10)
        frame.grid(row=0, column=0, padx=20, pady=20)

        # Hour and Minute selection
        hours = [f"{i:02}" for i in range(24)]  # Hours: 00 to 23
        minutes = [f"{i:02}" for i in range(0, 60, 5)]  # Minutes: 00, 05, 10, ..., 55

        # Dropdown for Hour
        ttk.Label(frame, text="Hour").grid(row=0, column=0, padx=5, pady=5, sticky='w')
        self.hour_comboboxdeffone = ttk.Combobox(frame, values=hours, width=5)
        self.hour_comboboxdeffone.grid(row=0, column=1, padx=5, pady=5)
        self.hour_comboboxdeffone.set(datetime.now().strftime("%H"))

        # Dropdown for Minute
        ttk.Label(frame, text="Minute").grid(row=1, column=0, padx=5, pady=5, sticky='w')
        self.minute_comboboxdeffone= ttk.Combobox(frame, values=minutes, width=5)
        self.minute_comboboxdeffone.grid(row=1, column=1, padx=5, pady=5)
        self.minute_comboboxdeffone.set(datetime.now().strftime("%M"))

        # Confirm Button to set the selected time
        confirm_button = ttk.Button(self.time_windowdeffone, text="Set Time", command=self.set_timedeffsecond)
        confirm_button.grid(row=2, column=0, padx=10, pady=10)

        # Make the popup movable and independent
        
        self.time_windowdeffone.grab_set()  # Prevent interaction with main window until popup is closed
        
    # Function to set the time in the entry box
    def set_timedeffsecond(self):
        selected_hour = self.hour_comboboxdeffone.get()
        selected_minute = self.minute_comboboxdeffone.get()

        # Format time as HH:MM
        formatted_time = f"{selected_hour}:{selected_minute}"

        # Set the formatted time in the modifiedtime entry and close the popup
        self.Deferred_Timetwo.config(state='normal')  # Allow editing temporarily
        self.Deferred_Timetwo.delete(0, tk.END)  # Clear current value
        self.Deferred_Timetwo.insert(0, formatted_time)  # Insert selected time
        self.Deferred_Timetwo.config(state='readonly')  # Make it readonly again

        # Close the popup window
        self.time_windowdeffone.destroy()
      
    def filter_custid_listone(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Customer_Identryy.get()
        if current_text == '':
            self.Customer_Identryy['values'] = self.Custidonlyone
        else:
            filtered_suppliers = [supplier for supplier in self.Custidonlyone if current_text.lower() in supplier.lower()]
            self.Customer_Identryy['values'] = filtered_suppliers

    def filter_custname_listone(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Cust_Namee_Entry.get()
        if current_text == '':
            self.Cust_Namee_Entry['values'] = self.Custnameonlyone
        else:
            filtered_suppliers = [supplier for supplier in self.Custnameonlyone if current_text.lower() in supplier.lower()]
            self.Cust_Namee_Entry['values'] = filtered_suppliers
    def populate_custname_basedon_idone(self,event):
       selected_supplier= self.Customer_Identryy.get()
       rows=KBACKEND.fetch_all_the_cust_details()
       for row in rows:
           if row[0]==selected_supplier:
              self.Cust_Namee_Entry.delete(0,tk.END)
              self.Cust_Namee_Entry.insert(0,row[1])
    def populate_custid_basedon_nameone(self,event):
       selected_supplier= self.Cust_Namee_Entry.get()
       rows=KBACKEND.fetch_all_the_cust_details()
       for row in rows:
           if row[1]==selected_supplier:
              self.Customer_Identryy.delete(0,tk.END)
              self.Customer_Identryy.insert(0,row[0])
     
    
    def open_fleet_infotwo(self):
            webbrowser.open(self.basee_url)     
    def open_maptwo(self):
        address = self.locaentryy.get("1.0", tk.END).strip()  # Get the text from the Text widget
        if not address:
            webbrowser.open(self.homee_url)
        else:
            formatted_address = address.replace(" ", "+")
            map_url = f"https://www.google.com/maps/search/?api=1&query={formatted_address}"
            webbrowser.open(map_url)
    def open_what_maptwo(self):
        address = self.whatwordsentryy.get().strip()  # Get the text from the Entry widget
        if not address:
            webbrowser.open(self.whatt_url)
        else:
            formatted_address = address.replace(" ", ".")
            map_url = f"https://what3words.com/{formatted_address}"
            webbrowser.open(map_url)
    def validate_odoone(self, event):
      try:
        odo = float(self.Odoentry.get())
        
        # Retrieve mileage data directly as a single value
        fleet_no = self.fleett.get()
        mileage_data = KBACKEND.getmileage(fleet_no)
        
        if mileage_data is not None:
            # Extract the mileage value from the pyodbc.Row object
            mileage_value = float(mileage_data[0])  # Assuming mileage is the first column
            
            if odo < mileage_value:
                messagebox.showwarning("Invalid Odometer", "Odometer cannot be lesser than igloo.")
            else:
                print("Odometer is valid.")
        else:
            messagebox.showerror("Error", "Failed to retrieve mileage data.")
    
      except ValueError:
        messagebox.showerror("Invalid Input", "Please enter a valid number.")
        self.Odo.focus_set()

      except Exception as ex:
        messagebox.showerror("Error", f"An unexpected error occurred: {ex}")
        self.Odo.focus_set()
   
    def reset_odoone(self,event):
        # Reset the Odo entry to the initial value
        if self.Odoentryvalue is not None:
            self.Odoentry.delete(0, tk.END)
            self.Odoentry.insert(0, self.Odoentryvalue)
    def on_row_selected(self, event):
        
        selected_item = self.eventss_tree.selection()
        
        if selected_item:
         # Extract the index of the selected item
         item_index = self.eventss_tree.index(selected_item[0])

         # Event number is the index + 1 (since event numbers start from 1)
         event_no = item_index + 1

         # Get the incident number from the entry
         incident_no=self.Numberentryy.get()

         fetch_event_details= KBACKEND.fetch_data_for_event(incident_no,event_no)

         self.open_eventspage_with_clickedrow(fetch_event_details)
    
    def filter_supplier_list_two(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Contactentryy.get()
        if current_text == '':
            self.Contactentryy['values'] = self.supplier
        else:
            filtered_suppliers = [supplier for supplier in self.supplier if current_text.lower() in supplier.lower()]
            self.Contactentryy['values'] = filtered_suppliers
    
    def post_incident_reports_actionone(self):
      self.save_the_incident_details()
      self.post_windowone= tk.Toplevel(self.root)
      self.post_windowone.title("Post Incident Report Form")
      self.post_windowone.resizable(False,False)

      root_x = self.root.winfo_x()
      root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
      offset_x = root_x + 50  # You can adjust this offset value
      offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
      self.post_windowone.geometry(f"750x350+{offset_x}+{offset_y}")

      icon_box = tk.Frame(self.post_windowone, relief=tk.RIDGE, borderwidth=3)
      icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

      # You can add icons below menus using PhotoImage or other methods.
      # For demonstration purposes, let's create 13 small image icons.
      image_paths = ["icon14.png", "icon15.png"]
      tooltips = ["Exit the window", "Save"]
      for idpost, (path,tooltip_text) in enumerate(zip(image_paths,tooltips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idpost: self.postwindowfunctionsone(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)

      First_framepost= LabelFrame(self.post_windowone, bd=3, relief=tk.RIDGE,text="Post Incident Reports")
      First_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      First_framepost.place(x=0,y=30,width=700,height=120)
      
      Incident_Number=self.Numberentryy.get()
      I_No=Label(First_framepost, text="Incident_Number:")
      I_No.grid(row=0, column=0,padx=5)
      self.Incidentnumber_entrypostone=Entry(First_framepost,width=15)
      self.Incidentnumber_entrypostone.grid(row=0,column=1,padx=5)
      self.Incidentnumber_entrypostone.insert(0,Incident_Number)

      Date = Label(First_framepost, text="Date:")
      Date.grid(row=0, column=2,padx=5)
      self.datepostone= DateEntry(First_framepost, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
      self.datepostone.grid(row=0, column=3,sticky='w',padx=5)
      self.datepostone.state(['disabled'])

      current_time = datetime.now().strftime("%H:%M")
      Time= Label(First_framepost,text= "Time:")
      Time.grid(row=0,column=4,padx=5)
      self.timepostone= ttk.Entry(First_framepost,width=15)
      self.timepostone.grid(row=0, column=5,sticky='w',padx=5,pady=8)
      self.timepostone.insert(0,current_time)
      self.timepostone.state(['disabled'])

      currentuser=getuser()
      Createdby= Label(First_framepost,text="Created By")
      Createdby.grid(row=1,column=0,padx=5)
      self.createdbypostone= ttk.Entry(First_framepost)
      self.createdbypostone.grid(row=1,column=1,padx=5)
      self.createdbypostone.insert(0,currentuser)
      self.createdbypostone.state(['disabled'])

      Inc= Label(First_framepost, text="Incident_Category:")
      Inc.grid(row=1, column=2,padx=5)
      self.Incpostone= ttk.Entry(First_framepost, width=15)
      self.Incpostone.grid(row=1, column=3,sticky='w')

      self.linked_postvarone = tk.BooleanVar()
      self.linked_postvalueone = tk.StringVar()
      self.Linkedpostone=Checkbutton(First_framepost,width=2,variable=self.linked_postvarone,command=self.toggle_post_entryone)
      self.Linkedpostone.grid(row=1,column=4,sticky='w',padx=3)
      Linked_Orders= Label(First_framepost,text="Final Costed")
      Linked_Orders.grid(row=1,column=5,padx=5,pady=5)

      self.catdetailsforpostincidentone=KBACKEND.fetch_cat_details()
      self.catdetailspostone= [row[1] for row in self.catdetailsforpostincidentone]
      lb5 = Label(First_framepost, text="Defect Cat*",fg="red", padx=5,pady=5)
      lb5.grid(row=2, column=0)
      self.Categorypostone = ttk.Combobox(First_framepost, values= self.catdetailspostone, width=13)
      self.Categorypostone.grid(row=2, column=1)

      self.verdictdetailsone=KBACKEND.fetch_verdict_details()
      self.verdictdetailspostone=[row[1] for row in self.verdictdetailsone]
      lb6 = Label(First_framepost, text="PIR_Verdict*",fg="red", padx=5,pady=5)
      lb6.grid(row=2, column=2)
      self.PIR_verdictone = ttk.Combobox(First_framepost, values= self.verdictdetailspostone, width=13)
      self.PIR_verdictone.grid(row=2, column=3)

      Second_framepost= Frame(self.post_windowone, bd=3, relief=tk.RIDGE)
      Second_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      Second_framepost.place(x=0,y=150,width=700,height=180)

      comments= Label(Second_framepost, text="Comments:")
      comments.grid(row=0, column=0,pady=5,sticky='w')
      self.commentspostone= Text(Second_framepost,width=40, height='8',wrap='word')
      self.commentspostone.grid(row=0,column=1,columnspan=2,sticky='w',pady=5)

      
    def toggle_post_entryone(self):
        if self.linked_postvarone.get():
            self.linked_postvalueone.set("Y")
        else:
           self.linked_postvalueone.set("N")
    def postwindowfunctionsone(self,index):
       if index==1:
          self.exit_the_post_incident_reportone()
       if index==2:
          self.save_the_post_incident_reportone()
    def exit_the_post_incident_reportone(self):
       self.post_windowone.destroy()
    def save_the_post_incident_reportone(self):
       Incident_Number=self.Incidentnumber_entrypostone.get()
       date_str=self.datepostone.get_date()
       time_str=self.timepostone.get()

       current_time = datetime.strptime(time_str, "%H:%M").time()

       combined_datetime = datetime.combine(date_str, current_time)

       Created_By= self.createdbypostone.get()

       Incident_cat=self.Incpostone.get()

       Final_costed=self.linked_postvalueone.get()

       category_post= self.Categorypostone.get()
       if category_post is None or category_post == "":
          messagebox.showerror("Error", "Primary key attribute 'Category_Post' requires a value.")
       else:
         for row in self.catdetailsforpostincidentone:
          if row[1] == category_post:
            category_post_value_to_store = row[0]
            break
       verdict_post=self.PIR_verdictone.get()
       if verdict_post is None or verdict_post=="":
          messagebox.showerror("Error", "Primary key attribute 'PIR_Verdict' requires a value.")
       else:
          for row in self.verdictdetailsone:
             if row[1]== verdict_post:
               verdict_post_value_to_store=row[0]
               break

       Comments=self.commentspostone.get("1.0", tk.END)

       KBACKEND.store_the_postincident_reports(Incident_Number,combined_datetime,Created_By,Incident_cat,
                                               Final_costed,Comments,category_post_value_to_store,verdict_post_value_to_store)
       
       Incident_Number=self.Numberentryy.get()
       Post_incident_report=KBACKEND.fetch_lastpost_reports_and_insert(Incident_Number)

       self.Post_incident_treee.delete(*self.Post_incident_treee.get_children())

       if Post_incident_report:
          for post_details in Post_incident_report:
             Inci_Number= post_details.get("I_number")
             Date_time= post_details.get("Report_Created")
             if Date_time is not None:
              Date = Date_time.date()
              Time = Date_time.time()
             else:
               Date = None  # or a default value
               Time = None
             Created= post_details.get("Created_By")
             Incident_Category= post_details.get("Inc_Category_ID")
             Commentss= post_details.get("Comments")

             self.Post_incident_treee.insert("", "end", values=(Incident_Number,Date,Time,Created,Incident_Category,Commentss))   
             
             self.post_incident_reportsone.config(state=DISABLED)
    def on_status_selectedone(self, event=None):
        selected_status = self.StatussEntryy.get()
        Inci_number= self.Numberentryy.get()
        current_user=getuser()
        if selected_status == "Completed" and KBACKEND.is_authority_level_sufficient(current_user):
            self.post_incident_reportsone.pack(side=tk.RIGHT, padx=1, pady=2)
        else:
            self.post_incident_reportsone.pack_forget()
        if selected_status=="Completed" and KBACKEND.fetch_postreportsnew(Inci_number):
           self.post_incident_reportsone.config(state=DISABLED)   
        if selected_status == "Closed": 
           Incident_Number = self.Numberentryy.get()
           if not KBACKEND.fetch_postreports(Incident_Number):
                messagebox.showwarning("Warning", "Create a post incident report before closing the incident.")
                self.StatussEntryy.set('')  # Clear the selection
           else:
               self.StatussEntryy.set("Closed")
               #self.post_incident_reports.config(state=DISABLED)
               #self.StatussEntry.state(['disabled'])

    def check_initial_value(self):
        initial_value = self.LolEntryy.get()
        self.handle_location_logic(initial_value)

    def on_location_selectedone(self, event=None):
        selected_location = self.LolEntryy.get()
        self.handle_location_logic(selected_location)

    def handle_location_logic(self, location):
        if location == "Roadside":
            self.show_driver_fields()
        else:
            self.hide_driver_fields()

    def show_driver_fields(self):
        self.lb3one.grid(row=0, column=3)
        self.Driverrentry.grid(row=0, column=4)
        self.lb3phoneone.grid(row=1, column=3)
        self.Driverrphone.grid(row=1, column=4)
        self.Attendance_Deffone.grid_remove()
        self.AttendanceEntryy.grid_remove()
        self.Deff_timeee.grid_remove()
        self.Deferred_Timetwo.grid_remove()
        self.Deffered.grid_remove()
        self.Deferred_Too.grid_forget()

    def hide_driver_fields(self):
        self.lb3one.grid_remove()
        self.Driverrentry.grid_remove()
        self.lb3phoneone.grid_remove()
        self.Driverrphone.grid_remove()
        self.Attendance_Deffone.grid(row=7,column=0)
        self.AttendanceEntryy.grid(row=7, column=1, sticky='w')
        self.Deff_timeee.grid(row=9,column=0,padx=2, sticky='w')
        self.Deferred_Timetwo.grid(row=9,column=1,sticky='w')
        self.Deffered.grid(row=8, column=0, padx=2, sticky='w')
        self.Deferred_Too.grid(row=8, column=1, padx=2, sticky='w')

    #def on_location_selectedone(self, event):
        #selected_location = self.LolEntryy.get()
        
        #if selected_location == "Roadside":
            #self.lb3one.grid(row=0, column=3)
            #self.Driverrentry.grid(row=0, column=4)
            #self.lb3phoneone.grid(row=1, column=3)
            #self.Driverrphone.grid(row=1, column=4)

        #else:
            #self.lb3one.grid_remove()
            #self.Driverrentry.grid_remove()
            #self.lb3phoneone.grid_remove()
            #self.Driverrphone.grid_remove()
    
    def clicking_the_postreports(self,event):
       selected_item = self.Post_incident_treee.selection()
       if selected_item:
         # Extract the index of the selected item
         #item_index = self.Table_treep.index(selected_item[0])

         Incident_Number= self.Numberentryy.get()

         open_post_report_details= KBACKEND.fetch_lastpost_reports_and_inserttwo(Incident_Number)

         self.open_postreports_with_clickedrow(open_post_report_details)

    def open_postreports_with_clickedrow(self,open_post_report_details):
      self.post_windowoneclick= tk.Toplevel(self.root)
      self.post_windowoneclick.title("Post Incident Report Form")
      self.post_windowoneclick.resizable(False,False)

      root_x = self.root.winfo_x()
      root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
      offset_x = root_x + 50  # You can adjust this offset value
      offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
      self.post_windowoneclick.geometry(f"750x350+{offset_x}+{offset_y}")

      First_framepost= LabelFrame(self.post_windowoneclick, bd=3, relief=tk.RIDGE,text="Post Incident Reports")
      First_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      First_framepost.place(x=0,y=30,width=700,height=120)
      
      Incident_Number=self.Numberentryy.get()
      I_No=Label(First_framepost, text="Incident_Number:")
      I_No.grid(row=0, column=0,padx=5)
      self.Incidentnumber_entrypostone=ttk.Entry(First_framepost,width=15)
      self.Incidentnumber_entrypostone.grid(row=0,column=1,padx=5)
      self.Incidentnumber_entrypostone.insert(0,Incident_Number)
      self.Incidentnumber_entrypostone.state(['disabled'])

      Date = Label(First_framepost, text="Date:")
      Date.grid(row=0, column=2,padx=5)
      self.datepostoneclick= DateEntry(First_framepost, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
      self.datepostoneclick.grid(row=0, column=3,sticky='w',padx=5)
      if open_post_report_details is not None:
         self.datepostonevalue= open_post_report_details.get("Report_Created")
      else:
         self.datepostonevalue=None
      self.datevalueclick= self.datepostonevalue.date()
      self.datepostoneclick.set_date(self.datevalueclick)
      self.datepostoneclick.state(['disabled'])

      Time= Label(First_framepost,text= "Time:")
      Time.grid(row=0,column=4,padx=5)
      self.timepostoneclick= ttk.Entry(First_framepost,width=15)
      self.timepostoneclick.grid(row=0, column=5,sticky='w',padx=5,pady=8)
      if open_post_report_details is not None:
         self.timepostoneclickvalue= open_post_report_details.get("Report_Created")
      else:
         self.timepostoneclickvalue= None
      self.timevalueclick= self.timepostoneclickvalue.time()
      self.timepostoneclick.insert(0,self.timevalueclick)
      self.timepostoneclick.state(['disabled'])

      
      Createdby= Label(First_framepost,text="Created By")
      Createdby.grid(row=1,column=0,padx=5)
      self.createdbypostoneclick= ttk.Entry(First_framepost)
      self.createdbypostoneclick.grid(row=1,column=1,padx=5)
      if open_post_report_details is not None:
       self.createdbypostoneclickvalue= open_post_report_details.get("Created_By")
      else:
       self.createdbypostoneclickvalue=None
      self.createdbypostoneclick.insert(0,self.createdbypostoneclickvalue)
      self.createdbypostoneclick.state(['disabled'])
      

      Inc= Label(First_framepost, text="Incident_Category:")
      Inc.grid(row=1, column=2,padx=5)
      self.Incpostoneclick= ttk.Entry(First_framepost, width=15)
      self.Incpostoneclick.grid(row=1, column=3,sticky='w')
      if open_post_report_details is not None:
         self.Incpostoneclickvalue=open_post_report_details.get("Inc_Category_ID")
      else:
         self.Incpostoneclickvalue= None
      self.Incpostoneclick.insert(0,self.Incpostoneclickvalue)
      self.Incpostoneclick.state(['disabled'])

      self.linked_postvaroneclick = tk.BooleanVar()
      self.Linkedpostoneclick=ttk.Checkbutton(First_framepost,width=2,variable=self.linked_postvaroneclick)
      self.Linkedpostoneclick.grid(row=1,column=4,sticky='w',padx=3)
      if open_post_report_details is not None:
         self.Linkedpostoneclickvalue= open_post_report_details.get("Linked_Orders")
      else:
         self.Linkedpostoneclickvalue= None
      if self.Linkedpostoneclickvalue=='Y':
         checkbox=True
      else:
         checkbox=False
      self.linked_postvaroneclick.set(checkbox)
      self.Linkedpostoneclick.state(['disabled'])
      Linked_Orders= Label(First_framepost,text="Final Costed")
      Linked_Orders.grid(row=1,column=5,padx=5,pady=5)

      self.catdetailsforpostincidentclickone=KBACKEND.fetch_cat_details()
      self.catdetailspostclickone= [row[1] for row in self.catdetailsforpostincidentclickone]
      lb5 = Label(First_framepost, text="Defect Cat*",fg="red", padx=5,pady=5)
      lb5.grid(row=2, column=0)
      self.Categorypostclickone = ttk.Combobox(First_framepost, values= self.catdetailspostclickone, width=15)
      self.Categorypostclickone.grid(row=2, column=1)
      if open_post_report_details is not None:
         self.Categorypostclickvalueone= open_post_report_details.get("Category")
      else:
         self.Categorypostclickvalueone= None
      self.Categorypostclickone.insert(0,self.Categorypostclickvalueone if self.Categorypostclickvalueone is not None else"")
      self.Categorypostclickone.state(['disabled'])

      self.verdictdetailsoneclick=KBACKEND.fetch_verdict_details()
      self.verdictdetailspostoneclick=[row[1] for row in self.verdictdetailsoneclick]
      lb6 = Label(First_framepost, text="PIR_Verdict*",fg="red", padx=5,pady=5)
      lb6.grid(row=2, column=2)
      self.PIR_verdictoneclick = ttk.Combobox(First_framepost, values= self.verdictdetailspostoneclick, width=13)
      self.PIR_verdictoneclick.grid(row=2, column=3)
      if open_post_report_details is not None:
         self.PIR_verdictoneclickvalue=open_post_report_details.get("Verdict")
      else:
         self.PIR_verdictoneclickvalue=None
      self.PIR_verdictoneclick.insert(0,self.PIR_verdictoneclickvalue if self.PIR_verdictoneclickvalue is not None else"")
      self.PIR_verdictoneclick.state(['disabled'])

      Second_framepost= Frame(self.post_windowoneclick, bd=3, relief=tk.RIDGE)
      Second_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      Second_framepost.place(x=0,y=150,width=700,height=180)

      comments= Label(Second_framepost, text="Comments:")
      comments.grid(row=0, column=0,pady=5,sticky='w')
      self.commentspostoneclick= tk.Text(Second_framepost,width=40, height='8',wrap='word')
      self.commentspostoneclick.grid(row=0,column=1,columnspan=2,sticky='w',pady=5)
      if open_post_report_details is not None:
         self.commentspostoneclickvalue= open_post_report_details.get("Comments")
      else:
         self.commentspostoneclickvalue=None
      self.commentspostoneclick.insert("1.0",self.commentspostoneclickvalue)
      self.commentspostoneclick['state']='disabled'

       
    def open_eventspage_with_clickedrow(self,fetch_event_details):
     
     self.event_window= tk.Toplevel(self.root)
     self.event_window.title("Event Detail Form")
     self.event_window.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.event_window.geometry(f"800x600+{offset_x}+{offset_y}")

     Incident_Eventt= Frame(self.event_window, bd=3, relief=tk.RIDGE)
     Incident_Eventt.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Eventt.place(x=0,y=30,width=600,height=100)

     self.eventsinfo= KBACKEND.fetch_event_types()
     self.eventtypesinformation= [row[1] for row in self.eventsinfo]
     Event_type= Label(Incident_Eventt, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entryy= ttk.Combobox(Incident_Eventt,values=self.eventtypesinformation,width=20)
     self.Event_type_entryy.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.Event_type_value= fetch_event_details.get("Event_Type")
     self.Event_type_entryy.set(self.Event_type_value if self.Event_type_value is not None else"")
     self.Event_type_entryy.state(['disabled'])
     self.attach_context_menu(self.Event_type_entryy)
     
     Action_required= Label(Incident_Eventt, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entryy= ttk.Entry(Incident_Eventt,width=30)
     self.Action_required_entryy.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entryyvalue=fetch_event_details.get("Createdby")
     self.Action_required_entryy.insert(0,self.Action_required_entryyvalue if self.Action_required_entryyvalue
                                        is not None else"")
     self.Action_required_entryy.state(['disabled'])
     self.attach_context_menu(self.Action_required_entryy)

     Created= LabelFrame(self.event_window,bd=3, relief=tk.RIDGE,text="Created")
     Created.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Created.place(x=610,y=30,width=180,height=120)
     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Created, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entryy= DateEntry(Created, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entryy.grid(row=0, column=1,sticky='w')
     self.Date_created_Entryyvalue= fetch_event_details.get("Createddate")
     self.Date_created_date= self.Date_created_Entryyvalue.date()
     self.Date_created_Entryy.set_date(self.Date_created_date if self.Date_created_date is not None else"")
     self.Date_created_Entryy.state(['disabled'])
     self.attach_context_menu(self.Date_created_Entryy)
     #Time
     Time_created= Label(Created,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entryy= ttk.Entry(Created,width=9)
     self.Time_created_entryy.grid(row=1,column=1,sticky="w")
     self.Time_created_entryyvalue= fetch_event_details.get("Createddate")
     self.Time_created_time=self.Time_created_entryyvalue.time()
     self.Time_created_entryy.insert(0,self.Time_created_time if self.Time_created_time is not None else"")
     self.Time_created_entryy.state(['disabled'])
     self.attach_context_menu(self.Time_created_entryy)
     


     Event_text=Frame(self.event_window,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entryy= tk.Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entryy.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.Event_detailsvalue= fetch_event_details.get("Eventtext")
     self.Event_details_entryy.insert("1.0",self.Event_detailsvalue if self.Event_detailsvalue is not None else"")
     self.Event_details_entryy['state'] = 'disabled'
     self.attach_context_menu(self.Event_details_entryy)

     

     


     Next_event= LabelFrame(self.event_window,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)
     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entryy= DateEntry(Next_event, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_nextevent_Entryy.grid(row=0, column=1,sticky='w')
     self.Date_nextevent_Entryyvalue=fetch_event_details.get("Nexteventdate")
     self.Date_nextevent_date= self.Date_nextevent_Entryyvalue.date()
     print(self.Date_nextevent_date)
     self.Date_nextevent_Entryy.set_date(self.Date_nextevent_date if self.Date_nextevent_date is not None else"")
     self.Date_nextevent_Entryy.state(['disabled'])
     self.attach_context_menu(self.Date_nextevent_Entryy)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entryy= Entry(Next_event,width=9)
     self.Time_nextevent_entryy.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Time_nextevent_entryyvalue= fetch_event_details.get("Nexteventdate")
     self.Time_nextevent_time= self.Time_nextevent_entryyvalue.time()
     self.Time_nextevent_entryy.insert(0,self.Time_nextevent_time if self.Time_nextevent_time is not None else"")
     self.Time_nextevent_entryy['state'] = 'disabled'
     self.attach_context_menu(self.Time_nextevent_entryy)

     self.type=KBACKEND.fetch_event_types()
     self.typedetails= [row[1] for row in self.type]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entryy= ttk.Combobox(Next_event,values=self.typedetails,width=20)
     self.Type_nextevent_entryy.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.Typenextevent_value= fetch_event_details.get("Nexteventtype")
     self.Type_nextevent_entryy.state(['disabled'])
     self.Type_nextevent_entryy.set(self.Typenextevent_value if self.Type_nextevent_entryy is not None else"")
     self.attach_context_menu(self.Type_nextevent_entryy)
   

     Owner= Label(Next_event, text="Owner")
     Owner.grid(row=4,column=0,padx=5,pady=5)
     self.Owner_entryy= ttk.Entry(Next_event,width=30)
     self.Owner_entryy.grid(row=4,column=1,sticky="w",padx=5,pady=5)
     self.Ownerentryyvalue= fetch_event_details.get("Owner")
     self.Owner_entryy.insert(0,self.Ownerentryyvalue if self.Ownerentryyvalue is not None else"")
     self.Owner_entryy.state(['disabled'])
     self.attach_context_menu(self.Owner_entryy)
     

    def populate_events_tree(self):
       incident_number=self.Numberentryy.get()
       event_details=KBACKEND.fetch_all_event_details(incident_number)
       self.eventss_tree.delete(*self.eventss_tree.get_children())
       if event_details:
          for events in event_details:
             Event_created= events.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= events.get('Notes')
             Last_updated= events.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= events.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= events.get('Event_Description')
             Next_Event_Description= events.get('Next_Event_Description')
             C_By= events.get('Created_By')
             Own= events.get('Owner')


             self.eventss_tree.insert("", "end", values=(Created_date,Created_time,C_By,Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,Own,Follow_up_date,follow_up_time,Own,Next_Event_Description))
        
    

    def populate_location_descriptionn(self, event=None):
        selected_location = self.locationn_1.get()
        rows = KBACKEND.fetch_locations_and_descriptions()
        for row in rows:
            if row[0] == selected_location:
                self.locationn_2.delete(0, tk.END)
                self.locationn_2.insert(0, row[1])
                break
    def populate_supplier_detailss(self,event=None):
        selected_supplier= self.Contactentryy.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.nameentryy.delete(0,tk.END)
              self.Phoneentryy.delete(0,tk.END)
              self.nameentryy.insert(0,row[0])
              self.Phoneentryy.insert(0,row[2])
    def populate_supplier_details_two(self,event=None):
       selected_supplierno=self.nameentryy.get()
       rows=KBACKEND.fetch_supplier_details()
       for row in rows:
          if row[0]==selected_supplierno:
             self.Contactentryy.delete(0,tk.END)
             self.Phoneentryy.delete(0,tk.END)
             self.Contactentryy.insert(0,row[1])
             self.Phoneentryy.insert(0,row[2])     
    def on_click_index_4one(self):
     self.save_the_incident_details()
     # Open the pop-up window (Toplevel)
     fleet_no = self.fleett.get()  # Get the fleet number from the entry widget

     # Fetch the service, compliance, and recall data using the backend functions
     service_data = KBACKEND.fetch_service_type_data(fleet_no)
     compliance_data = KBACKEND.fetch_compliance_data(fleet_no)
     recall_data = KBACKEND.fetch_recall_data(fleet_no)

     # Create a new pop-up window with a larger size
     self.purchasehistoryoneveh = tk.Toplevel(self.root)
     self.purchasehistoryoneveh.title("Vehicle Details")
     self.purchasehistoryoneveh.geometry("800x720")  # Expanded window size
     self.purchasehistoryoneveh.resizable(False, False)

     # Create a frame to hold all the tables and widgets
     main_frame = tk.Frame(self.purchasehistoryoneveh, bg="lightgray")
     main_frame.pack(pady=10, padx=10, fill="both", expand=True)

     style = ttk.Style()
     style.configure("Bold.Treeview", font=("Arial", 10, "bold"))


     # ---- Service Data Table ----
     service_label = tk.Label(main_frame, text="Service Data", font=("Arial", 14, "bold"), bg="lightgray")
     service_label.grid(row=0, column=0, pady=(0, 5), sticky="w")

     service_frame = tk.Frame(main_frame)
     service_frame.grid(row=1, column=0, pady=(0, 10))

     service_columns = ("service_type", "due_date")
     service_tree = ttk.Treeview(service_frame, columns=service_columns, show="headings", height=5,style="Bold.Treeview")

     # Define headings and column width
     service_tree.heading("service_type", text="Service Type")
     service_tree.heading("due_date", text="Due Date")
     service_tree.column("service_type", width=200)
     service_tree.column("due_date", width=200)

     # Insert service data
     for row in service_data:
        service_tree.insert("", "end", values=(row[0], row[1]))
      
     
     # Add vertical scrollbar for the service table
     service_scrollbar = ttk.Scrollbar(service_frame, orient="vertical", command=service_tree.yview)
     service_tree.configure(yscrollcommand=service_scrollbar.set)
     service_scrollbar.pack(side="right", fill="y")
     service_tree.pack(side="left")

     # ---- Compliance Data Table ----
     compliance_label = tk.Label(main_frame, text="Compliance Data", font=("Arial", 14, "bold"), bg="lightgray")
     compliance_label.grid(row=2, column=0, pady=(0, 5), sticky="w")

     compliance_frame = tk.Frame(main_frame)
     compliance_frame.grid(row=3, column=0, pady=(0, 10))

     compliance_columns = ("compliance_type", "due_date")
     compliance_tree = ttk.Treeview(compliance_frame, columns=compliance_columns, show="headings", height=5,style="Bold.Treeview")

     # Define headings and column width
     compliance_tree.heading("compliance_type", text="Compliance Type")
     compliance_tree.heading("due_date", text="Due Date")
     compliance_tree.column("compliance_type", width=200)
     compliance_tree.column("due_date", width=200)

     # Insert compliance data
     for row in compliance_data:
        compliance_tree.insert("", "end", values=(row[0], row[1]))

     # Add vertical scrollbar for the compliance table
     compliance_scrollbar = ttk.Scrollbar(compliance_frame, orient="vertical", command=compliance_tree.yview)
     compliance_tree.configure(yscrollcommand=compliance_scrollbar.set)
     compliance_scrollbar.pack(side="right", fill="y")
     compliance_tree.pack(side="left")

     # ---- Recall Data Table ----
     recall_label = tk.Label(main_frame, text="Recall Data", font=("Arial", 14, "bold"), bg="lightgray")
     recall_label.grid(row=4, column=0, pady=(0, 5), sticky="w")

     recall_frame = tk.Frame(main_frame)
     recall_frame.grid(row=5, column=0, pady=(0, 10))

     recall_columns = ("recall_number", "recall_description")
     recall_tree = ttk.Treeview(recall_frame, columns=recall_columns, show="headings", height=5,style="Bold.Treeview")

     # Define headings and column width
     recall_tree.heading("recall_number", text="Recall Number")
     recall_tree.heading("recall_description", text="Recall Description")
     recall_tree.column("recall_number", width=200)
     recall_tree.column("recall_description", width=200)

     # Insert recall data
     for row in recall_data:
        recall_tree.insert("", "end", values=(row[0], row[1]))

    # Add vertical scrollbar for the recall table
     recall_scrollbar = ttk.Scrollbar(recall_frame, orient="vertical", command=recall_tree.yview)
     recall_tree.configure(yscrollcommand=recall_scrollbar.set)
     recall_scrollbar.pack(side="right", fill="y")
     recall_tree.pack(side="left")

    # ---- Vehicle Notes Text Field ----
     notes_label = tk.Label(main_frame, text="Vehicle Notes", font=("Arial", 14, "bold"), bg="lightgray")
     notes_label.grid(row=6, column=0, pady=(0, 5), sticky="w")

     # Adjusted text field size
     vehicle_notes = tk.Text(main_frame, height=5, width=80, font=("Arial", 12))  # Increased width and slightly taller
     vehicle_notes.grid(row=7, column=0, pady=(0, 10))

     # ---- OK Button ----
     ok_button = tk.Button(main_frame, text="OK", font=("Arial", 14, "bold"), command=self.open_Purchase_order_From_mainpage)
     ok_button.grid(row=8, column=0, pady=10)

    def open_Purchase_order_From_mainpage(self):
        self.purchasehistoryoneveh.iconify()
        self.purchasehistoryone = tk.Toplevel(self.root)
        self.purchasehistoryone.title("Maintenance Control")
        self.purchasehistoryone.resizable(False, False)

        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
        offset_x = root_x + 50  # You can adjust this offset value
        offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
        self.purchasehistoryone.geometry(f"800x615+{offset_x}+{offset_y}")

        icon_box = tk.Frame(self.purchasehistoryone, relief=tk.RIDGE, borderwidth=3)
        icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

        image_paths = ["icon 18.png", "icon 19.png","newicon.png"]
        tool_tips=["Exit the window","Save","Create new Purchase Order"]
        
        for idpurcost, (path,tooltip_text) in enumerate(zip(image_paths,tool_tips), start=1):
            image = Image.open(path)
            image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
            photo = ImageTk.PhotoImage(image)
            icon_button = tk.Button(icon_box, image=photo, command=lambda index=idpurcost: self.update_purchase_information(index))
            icon_button.image = photo
            icon_button.pack(side=tk.LEFT, padx=5, pady=2)

            ToolTip(icon_button, tooltip_text)
        
        # Create frames for each page
        self.Historypone = Frame(self.purchasehistoryone)
        self.Maintenance_Controlpone = Frame(self.purchasehistoryone)

        def show_History():
            self.Maintenance_Controlpone.pack_forget()
            self.Historypone.pack(fill="both", expand=True)

        def show_maintenance():
            self.Maintenance_Controlpone.pack(fill="both", expand=True)
            self.Historypone.pack_forget()

        show_History()

        # Creating Buttons Frame for second page
        Buttonframe = Frame(self.purchasehistoryone, relief=tk.RIDGE)
        Buttonframe.place(x=0, y=27, width=780, height=40)

        # Create buttons
        hist_button = tk.Button(Buttonframe, text="History", command=show_History)
        hist_button.pack(side=tk.LEFT, padx=1, pady=2)

        maintain_button = tk.Button(Buttonframe, text="Maintenance Control", command=show_maintenance)
        maintain_button.pack(side=tk.LEFT, padx=1, pady=2)

        dataframe = Label(self.Historypone, bd=3, relief=tk.RIDGE)
        dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
        dataframe.place(x=0, y=29, width=780, height=180) 

        scrollbar_x = ttk.Scrollbar(dataframe, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(dataframe, orient=VERTICAL)

        self.costlinestableone = ttk.Treeview(dataframe, column=("Repaired", "Odometer", "Supplier_Name",
                                                             "Incident_Link", "Total_Parts_Cost", 
                                                            "Total_Recharge","Approval","Products"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        self.costlinestableone.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.costlinestableone.xview)
        scrollbar_y.config(command=self.costlinestableone.yview)

        # Set column headings
        self.costlinestableone.heading("Repaired", text="Repaired")
        self.costlinestableone.heading("Odometer", text="Odometer")
        self.costlinestableone.heading("Supplier_Name", text="Supplier_Name")
        self.costlinestableone.heading("Incident_Link", text="Incident_Link")
        self.costlinestableone.heading("Total_Parts_Cost", text="Total_Parts_Cost")
        self.costlinestableone.heading("Total_Recharge", text="Total_Recharge")
        self.costlinestableone.heading("Approval", text="Approval")
        self.costlinestableone.heading("Products", text="Products")


        # Set Treeview to display column headings only
        self.costlinestableone["show"] = "headings"

        # Set column widths
        self.costlinestableone.column("Repaired", width=90)
        self.costlinestableone.column("Odometer", width=80)
        self.costlinestableone.column("Supplier_Name", width=90)
        self.costlinestableone.column("Incident_Link", width=100)
        self.costlinestableone.column("Total_Parts_Cost", width=100)
        self.costlinestableone.column("Total_Recharge", width=100)
        self.costlinestableone.column("Approval", width=90)
        self.costlinestableone.column("Products", width=100)
        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.costlinestableone.pack(side=LEFT, fill=BOTH, expand=True)
        self.costlinestableone.bind("<ButtonRelease-1>", self.onclick_for_purchaseorder_tableone)
        self.populate_top_purchase_order_two()

        self.Approvalframepone = tk.Frame(self.purchasehistoryone, bd=3, relief=tk.RIDGE)
        self.Approvalframepone.place(x=0, y=250, width=780, height=150)

        # Creating frame for the 3 buttons
        self.Approval_Issuepone = tk.Frame(self.Approvalframepone)
        self.Invoice_Detailspone = tk.Frame(self.Approvalframepone)
        self.Misccpone = tk.Frame(self.Approvalframepone)
        
        # Function to show approval page
        def show_Approval():
            self.Approval_Issuepone.place(x=0, y=40, width=780, height=110)
            self.Invoice_Detailspone.place_forget()
            self.Misccpone.place_forget()
        
        # Function to show invoice details page
        def show_Invoice_Details():
            self.Approval_Issuepone.place_forget()
            self.Invoice_Detailspone.place(x=0, y=40, width=780, height=110)
            self.Misccpone.place_forget()
        
        # Function to show misc page
        def show_Miscc():
            self.Approval_Issuepone.place_forget()
            self.Invoice_Detailspone.place_forget()
            self.Misccpone.place(x=0, y=40, width=780, height=110)
        
        show_Approval()
        
        # Creating Buttons Frame for second page
        Buttonframe = tk.Frame(self.Approvalframepone, relief=tk.RIDGE)
        Buttonframe.place(x=0, y=8, width=780, height=30)
        
        # Create buttons
        Approval_button = tk.Button(Buttonframe, text="Approval Issue", command=show_Approval)
        Approval_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        Invoice_details_button = tk.Button(Buttonframe, text="Invoice Details", command=show_Invoice_Details)
        Invoice_details_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        Miscc_button = tk.Button(Buttonframe, text="Misc", command=show_Miscc)
        Miscc_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        # Creating data frame for Approval Issue
        Repairerdataframe = tk.Frame(self.Approval_Issuepone, bd=3, relief=tk.RIDGE)
        Repairerdataframe.place(x=0, y=0, width=765, height=100)
        
        # Creating data frame for Invoice Details
        Invoicedataframe = tk.Frame(self.Invoice_Detailspone, bd=3, relief=tk.RIDGE)
        Invoicedataframe.place(x=0, y=0, width=765, height=100)


        Reg_Number=self.reistrationentry.get()

        purchase_details= KBACKEND.insert_purchase_details(Reg_Number)

        #Creating a label and combobox entry for Repairer 
        sup=KBACKEND.fetch_supplier_details()
        self.supplierpname = [row[1] for row in sup]
        Repairer= Label(Repairerdataframe, text="Supplier Name:")
        Repairer.grid(row=0,column=0,padx=5,pady=5)
        self.Repairerentrypone= ttk.Combobox(Repairerdataframe,values=self.supplierpname,width=20)
        self.Repairerentrypone.grid(row=0,column=1,sticky="w",padx=5,pady=5)
        if purchase_details is not None:
           self.Repairerentryponevaluesup= purchase_details.get('Supplier_Name')
        else:
           self.Repairerentryponevaluesup=None
        self.Repairerentrypone.insert(0, self.Repairerentryponevaluesup if self.Repairerentryponevaluesup is not None else "")
        self.attach_context_menu(self.Repairerentrypone)
        self.Repairerentrypone.bind("<KeyRelease>", self.filter_supplier_list_four)
        self.Repairerentrypone.bind("<<ComboboxSelected>>", self.populate_supplier_detailspinsert)
        self.Repairerentrypone.focus_set()

        Account= Label(Repairerdataframe, text="Account:")
        Account.grid(row=0,column=2,padx=5,pady=5)
        self.Accountentrypone= ttk.Entry(Repairerdataframe,width=20)
        self.Accountentrypone.grid(row=0,column=3,sticky="w",padx=5,pady=5)
        if purchase_details is not None:
           self.Accountentryponevalue=purchase_details.get('Supplier_No')
        else:
           self.Accountentryponevalue=None
        self.Accountentrypone.insert(0,self.Accountentryponevalue if self.Accountentryponevalue is not None else"")
        self.attach_context_menu(self.Accountentrypone)
        self.populate_supplier_detailspinsert()

        Approval= Label(Repairerdataframe,text="Approval:")
        Approval.grid(row=0,column=4,padx=5,pady=5)
        self.Approvalentrypone= ttk.Entry(Repairerdataframe,width= 20)
        self.Approvalentrypone.grid(row=0,column=5,sticky="w",padx=5,pady=3)
        if purchase_details is not None:
           self.Approvalentryponevalue= purchase_details.get('PO_Number')
        else:
           self.Approvalentryponevalue= None
        self.Approvalentrypone.insert(0,self.Approvalentryponevalue if self.Approvalentryponevalue is not None else "")
        self.attach_context_menu(self.Approvalentrypone)
        self.Approvalentrypone.state(['disabled'])

        Issued = Label(Repairerdataframe, text="Issued:")
        Issued.grid(row=1, column=0,padx=5,pady=5)
        self.Issuedentrypone= DateEntry(Repairerdataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.Issuedentrypone.grid(row=1, column=1,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
           self.Issuedentryponevalue= purchase_details.get('PO_Created')
        else:
           self.Issuedentryponevalue= None
        self.Issuedentrypone.set_date(self.Issuedentryponevalue if self.Issuedentryponevalue is not None else None)
        self.attach_context_menu(self.Issuedentrypone)
        
        current_user=getuser()
        Po_created= Label(Repairerdataframe,text="Created_By:")
        Po_created.grid(row=1,column=2,padx=5,pady=5)
        self.Po_createdbyone= ttk.Entry(Repairerdataframe,width=20)
        self.Po_createdbyone.grid(row=1,column=3,padx=5,pady=5)
        if purchase_details is not None:
           self.Po_createdbyonevalue= purchase_details.get('Created_By')
        else:
           self.Po_createdbyonevalue= None
        self.Po_createdbyone.insert(0, self.Po_createdbyonevalue if self.Po_createdbyonevalue is not None else current_user)
        self.attach_context_menu(self.Po_createdbyone)
        self.Po_createdbyone.state(['disabled'])
        
        fleet_entry=self.fleett.get()
        Fleet_Number=Label(Repairerdataframe, text="Fleet_No:")
        Fleet_Number.grid(row=1,column=4,padx=5,pady=5)
        self.fleetnumbercostone= Entry(Repairerdataframe,width=20)
        self.fleetnumbercostone.grid(row=1,column=5,padx=5,pady=5)
        if purchase_details is not None:
           self.fleetnumbercostonevalue= purchase_details.get('Fleet_No')
        else:
           self.fleetnumbercostonevalue= None
        self.fleetnumbercostone.insert(0,self.fleetnumbercostonevalue if self.fleetnumbercostonevalue is not None else fleet_entry)
        self.attach_context_menu(self.fleetnumbercostone)

        #Creating a Label and Entry for Odometer
        Odoentry=self.Odoentry.get()
        Odometer= Label(Repairerdataframe,text="Odometer:")
        Odometer.grid(row=2,column=0,padx=5,pady=5)
        self.Odometerentrypone= ttk.Entry(Repairerdataframe,width= 20)
        self.Odometerentrypone.grid(row=2,column=1,padx=5,pady=5,sticky="w")
        if purchase_details is not None:
           self.Odometerentryponevalue= purchase_details.get('Odometer')
        else:
           self.Odometerentryponevalue= None
        self.Odometerentrypone.insert(0,self.Odometerentryponevalue if self.Odometerentryponevalue is not None else Odoentry)
        self.attach_context_menu(self.Odometerentrypone)
        self.Odometerentrypone.state(['disabled'])


        #Creating a Label and Entry for Repaired:
        Repaired = Label(Repairerdataframe, text="Repaired:")
        Repaired.grid(row=2, column=2,padx=5,pady=5)
        self.Repairedentrypone= DateEntry(Repairerdataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.Repairedentrypone.grid(row=2, column=3,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
         self.Repairedentryponevalue = purchase_details.get('Repaired') 
        else:
           self.Repairedentryponevalue= None
        self.Repairedentrypone.set_date(self.Repairedentryponevalue if self.Repairedentryponevalue is not None else None)
        
        

        Order_Category= Label(Repairerdataframe,text="Order_Category")
        Order_Category.grid(row=2,column=4,padx=5,pady=5,sticky='w')
        self.Order_catone= Entry(Repairerdataframe,width=20)
        if purchase_details is not None:
           self.Order_catonevalue=purchase_details.get('Order_Category')
        else:
           self.Order_catonevalue = None
        self.Order_catone.grid(row=2,column=5,padx=5,pady=5,sticky='w')
        self.Order_catone.insert(0, self.Order_catonevalue if self.Order_catonevalue is not None else"")
        self.attach_context_menu(self.Order_catone)

        #Creating fields for the Invoice details dataframe

        Customer_Po= Label(Invoicedataframe,text="Customer Po:")
        Customer_Po.grid(row=0,column=0,padx=5,pady=5,sticky='w')
        self.Customer_Ponumone= Entry(Invoicedataframe,width=20)
        self.Customer_Ponumone.grid(row=0,column=1,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
           self.Customer_Ponumonevalue= purchase_details.get('Customer_PO')
        else:
           self.Customer_Ponumonevalue= None
        self.Customer_Ponumone.insert(0,self.Customer_Ponumonevalue if self.Customer_Ponumonevalue is not None else"")
        self.attach_context_menu(self.Customer_Ponumone)

        kofax= Label(Invoicedataframe,text="Kofax Scan_No:")
        kofax.grid(row=0,column=2,padx=5,pady=5,sticky='w')
        self.Kofaxnoone= Entry(Invoicedataframe,width=20)
        self.Kofaxnoone.grid(row=0,column=3,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
           self.Kofaxnoonevalue= purchase_details.get('Kofax_Scan_No')
        else:
           self.Kofaxnoonevalue= None
        self.Kofaxnoone.insert(0,self.Kofaxnoonevalue if self.Kofaxnoonevalue is not None else"")
        self.attach_context_menu(self.Kofaxnoone)

        Igloo= Label(Invoicedataframe,text="Igloo Invoice_No:")
        Igloo.grid(row=0,column=4,padx=5,pady=5,sticky='w')
        self.Igloonoone= Entry(Invoicedataframe,width=20)
        self.Igloonoone.grid(row=0,column=5,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
           self.Igloonoonevalue=purchase_details.get('Igloo_Invoice_No')
        else:
           self.Igloonoonevalue=None
        self.Igloonoone.insert(0,self.Igloonoonevalue if self.Igloonoonevalue is not None else"")
        self.attach_context_menu(self.Igloonoone)

        Tableone= Frame(self.purchasehistoryone, bd=3,relief=tk.RIDGE)
        Tableone.place(x=0,y=400,width=780,height=140)

        scrollbar_x = ttk.Scrollbar(Tableone, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(Tableone, orient=VERTICAL)

        self.Table_treepone = ttk.Treeview(Tableone, columns=("Types", "Category","Products", "Parts_Cost", "Labour_Cost", "Total_Cost", "Rech_Parts","Rech_Labour" ,"Total_Recharge"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        
        self.Table_treepone.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.Table_treepone.xview)
        scrollbar_y.config(command=self.Table_treepone.yview)

        

        self.Table_treepone.heading("Types", text="Types")
        self.Table_treepone.heading("Category", text="Category")
        self.Table_treepone.heading("Products", text="Products")
        self.Table_treepone.heading("Parts_Cost", text="Parts_Cost")
        self.Table_treepone.heading("Labour_Cost", text="Labour_Cost")
        self.Table_treepone.heading("Total_Cost",text="Total_Cost")
        self.Table_treepone.heading("Rech_Parts", text="Rech_Parts")
        self.Table_treepone.heading("Rech_Labour", text="Rech_Labour")
        self.Table_treepone.heading("Total_Recharge", text="Total_Recharge")

        self.Table_treepone["show"] = "headings"
    
        self.Table_treepone.column("Types", width=90)
        self.Table_treepone.column("Category", width=90)
        self.Table_treepone.column("Products", width=90)
        self.Table_treepone.column("Parts_Cost", width=90)
        self.Table_treepone.column("Labour_Cost", width=90)
        self.Table_treepone.column("Total_Cost", width=90)
        self.Table_treepone.column("Rech_Parts", width=90)
        self.Table_treepone.column("Rech_Labour", width=90)
        self.Table_treepone.column("Total_Recharge", width=90)

        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.Table_treepone.pack(fill="both", expand=True)
        self.populate_all_the_costlines_two()
        
        self.Table_treepone.bind("<<TreeviewSelect>>", self.clicking_the_costlinestwo)

        Addcostline= Frame(self.purchasehistoryone, bd=3,relief=tk.RIDGE)
        Addcostline.place(x=0,y=540,width=780,height=50)

        Invoice_details_button = tk.Button(Addcostline, text="Add Costline",command= self.add_costline_two)
        Invoice_details_button.pack(side=tk.RIGHT, padx=1, pady=2)

        Maindataframemaintainence= Frame(self.Maintenance_Controlpone,bd=3, relief=tk.RIDGE)
        Maindataframemaintainence.pack(side=tk.TOP,padx=8,pady=3, anchor='nw')
        Maindataframemaintainence.place(x=0,y=33,width=780,height=65)

        reg_entry=self.reistrationentry.get()
        Reg_no= Label(Maindataframemaintainence,text="Reg_no:")
        Reg_no.grid(row=0,column=0)
        self.Reg_no_entrypone = Entry(Maindataframemaintainence, width=30)
        self.Reg_no_entrypone.grid(row=0, column=1)
        self.Reg_no_entrypone.insert(0,reg_entry if reg_entry is not None else"")
        self.attach_context_menu(self.Reg_no_entrypone)

        Vehicle= self.Make_Mod.get()
        Vehicle_main= Label(Maindataframemaintainence,text= "Vehicle:")
        Vehicle_main.grid(row=0,column=2)
        self.Vehicle_main_entrypone= Entry(Maindataframemaintainence,width=35)
        self.Vehicle_main_entrypone.grid(row=0,column=3,sticky='w')
        self.Vehicle_main_entrypone.insert(0,Vehicle if Vehicle is not None else"")
        self.attach_context_menu(self.Vehicle_main_entrypone)

        Agreementframe= Frame(self.Maintenance_Controlpone,bd=3, relief=tk.RIDGE)
        Agreementframe.pack(side=tk.TOP,padx=8,pady=3, anchor='nw')
        Agreementframe.place(x=0,y=98,width=780,height=70)

         #Create Label and entry for Agreement inside the dataframe
        Contract_number=self.Contract_No_Entryy.get()
        Agreement= Label(Agreementframe,text="Agreement:")
        Agreement.grid(row=0,column=0,padx=5,pady=5)
        self.Agreemententrypone= Entry(Agreementframe,width=30)
        self.Agreemententrypone.grid(row=0,column=1,padx=5,pady=5)
        self.Agreemententrypone.insert(0,Contract_number if Contract_number is not None else"")
        self.attach_context_menu(self.Agreemententrypone)

        #Create Label and entry for Customer
        Customer_name= self.Cust_Namee_Entry.get()
        Customer= Label(Agreementframe,text="Customer:")
        Customer.grid(row=0,column=2,padx=5,pady=5)
        self.Customerentrypone= Entry(Agreementframe,width=50)
        self.Customerentrypone.grid(row=0, column=3, padx=5, pady=5)
        self.Customerentrypone.insert(0,Customer_name if Customer_name is not None else"")
        self.attach_context_menu(self.Customerentrypone)
    
    def filter_supplier_list_four(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Repairerentrypone.get()
        if current_text == '':
            self.Repairerentrypone['values'] = self.supplierpname
        else:
            filtered_suppliers = [supplier for supplier in self.supplierpname if current_text.lower() in supplier.lower()]
            self.Repairerentrypone['values'] = filtered_suppliers

    def add_costline_two(self):
     self.update_the_information()
     
     
     approval_number = self.Approvalentrypone.get()

     fetch_incidentnumber = KBACKEND.fetching_selected_approvaldetails(approval_number)
    
     if fetch_incidentnumber is not None:
        incidentnumber = fetch_incidentnumber.get('Incident_Link')
        print(f"Fetched Incident Number: '{incidentnumber}'")  # Debugging print
    
     numberentry = self.Numberentryy.get()
     print(f"Number Entry: '{numberentry}'")  # Debugging print
    
     
      # Ensure both values are strings and strip any whitespace
     if str(incidentnumber).strip() == str(numberentry).strip():
        self.open_costlines_to_createtwo()
        self.purchasehistoryone.iconify()
     else:
        self.purchasehistoryone.lift()  # Bring the main window to the top
        self.purchasehistoryone.attributes('-topmost', True) 
        messagebox.showwarning("Warning", "The current incident is not linked with the selected PO Number",parent=self.purchasehistoryone)
        self.purchasehistoryone.attributes('-topmost', False) 
    def open_costlines_to_createtwo(self):
     
     self.costline_windowone = tk.Toplevel(self.root)
     self.costline_windowone.title("Cost Line Form")
     self.costline_windowone.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.costline_windowone.geometry(f"800x620+{offset_x}+{offset_y}")

     #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_windowone, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

         # You can add icons below menus using PhotoImage or other methods.
        # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png", "icon24.png"]
     tool_tips= ["Exit the window","Save"]
     for idcostone, (path,tooltip_text) in enumerate(zip(image_paths,tool_tips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcostone: self.costline_icons_two(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)

         dataframe = Frame(self.costline_windowone, bd=3, relief=tk.RIDGE)
         dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
         dataframe.place(x=0, y=35, width=780, height=90)

         Reg_details= self.Reg_no_entrypone.get()
         Reg_no = Label(dataframe, text="Registration No:")
         Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.costlineregone = Entry(dataframe,width=18)
     self.costlineregone.grid(row=0, column=1,padx=10,pady=3)
     self.costlineregone.insert(0,Reg_details)
     self.attach_context_menu(self.costlineregone)
     
     Repairer_name=self.Repairerentrypone.get()
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=2)
     self.costlinerepone = Entry(dataframe, width=18)
     self.costlinerepone.grid(row=0, column=3,padx=10,pady=3)
     self.costlinerepone.insert(0,Repairer_name)
     self.attach_context_menu(self.costlinerepone)
     
     System_number= self.Approvalentrypone.get()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=4)
     self.systemcostone = ttk.Entry(dataframe, width=18)
     self.systemcostone.grid(row=0, column=5,padx=10,pady=3)
     self.systemcostone.insert(0,System_number)
     self.attach_context_menu(self.systemcostone)
     self.systemcostone.state(['disabled'])
     
     Ododetails=self.Odometerentrypone.get()
     Odometerveh = Label(dataframe, text="Vehicle Odometer:")
     Odometerveh.grid(row=1, column=0,pady=5)
     self.odovehcostone = ttk.Entry(dataframe, width=18)
     self.odovehcostone.grid(row=1, column=1)
     self.odovehcostone.insert(0,Ododetails)
     self.attach_context_menu(self.odovehcostone)
     self.odovehcostone.state(['disabled'])
     
     Repairer_accountdetails= self.Accountentrypone.get()
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=1, column=2,pady=5)
     self.repaccocostone = Entry(dataframe, width=18)
     self.repaccocostone.grid(row=1, column=3)
     self.repaccocostone.insert(0,Repairer_accountdetails)
     self.attach_context_menu(self.repaccocostone)

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=1,column=4)
     self.Line_createdentryone=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentryone.grid(row=1,column=5)
     self.Line_createdentryone.state(['disabled'])

     current_user=getuser()
     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=2,column=0)
     self.Line_createdbyone= ttk.Entry(dataframe,width=18)
     self.Line_createdbyone.grid(row=2,column=1)
     self.Line_createdbyone.insert(0,current_user)
     self.Line_createdbyone.state(['disabled'])

     Seconddataframe = Frame(self.costline_windowone, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=125, width=780, height=70)

     Reason = Label(Seconddataframe, text="Types*:",fg="red")
     Reason.grid(row=0, column=0)

     Po_Types = KBACKEND.Fetch_PO_Types()
     formatted_data = [f"{row[0]} - {row[1]}" for row in Po_Types]
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Reasoncosttypesone = ttk.Combobox(Seconddataframe,width=20,values=formatted_data)
     self.Reasoncosttypesone.grid(row=0, column=1,padx=15,pady=3)
     self.attach_context_menu(self.Reasoncosttypesone)
     self.Reasoncosttypesone.bind("<<ComboboxSelected>>", self.update_rtscostcategoryone)

     RTS = Label(Seconddataframe, text="Category*:",fg="red")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategoryone = ttk.Combobox(Seconddataframe,width=20)
     self.rtscostcategoryone.grid(row=0, column=3,padx=10,pady=3)
     self.attach_context_menu(self.rtscostcategoryone)
     self.rtscostcategoryone.bind("<<ComboboxSelected>>", self.update_rtscostproductsone)
     self.rtscostcategoryone.bind("<KeyRelease>",self.filter_rts_categoryone)
     

     category_label = tk.Label(Seconddataframe, text="Products*:",fg="red")
     category_label.grid(row=0, column=4)

     self.category_costoneproducts = ttk.Combobox(Seconddataframe, width=20)
     self.category_costoneproducts.grid(row=0, column=5, padx=15, pady=3)
     self.category_costoneproducts.bind("<KeyRelease>",self.filter_rts_productsone)
     self.attach_context_menu(self.category_costoneproducts)
     
     Pfdepot= self.locationn_2.get()
     rowss = KBACKEND.fetch_locations_and_descriptions()
     self.depotdetailsone = [row[1] for row in rowss]  # First column values for dropdown
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscostone = ttk.Combobox(Seconddataframe, width=18,values=self.depotdetailsone)
     self.analysiscostone.grid(row=1, column=1)
     self.analysiscostone.insert(0,Pfdepot)
     self.analysiscostone.bind("<<ComboboxSelected>>", self.on_depot_selectedone)
     self.attach_context_menu(self.analysiscostone)

     Thirddataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=195, width=780, height=50)
     
     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscostone = Entry(Thirddataframe,width=13)
     self.Partscostone.grid(row=0, column=1,padx=15,pady=3)
     self.Partscostone.insert(0,"0.00")
     self.Partscostone.bind("<KeyRelease>", self.on_parts_cost_changedone)
     self.attach_context_menu(self.Partscostone)

     Labour_Hours= Label(Thirddataframe,text="Labour Hours:")
     Labour_Hours.grid(row=0,column=2)
     self.Labour_Hoursone= Entry(Thirddataframe,width=13)
     self.Labour_Hoursone.grid(row=0,column=3,padx=15,pady=3)
     self.Labour_Hoursone.bind("<KeyRelease>", self.calculate_the_labour_valueone)
     self.attach_context_menu(self.Labour_Hoursone)

     Labour_Rate=Label(Thirddataframe,text="Labour Rate")
     Labour_Rate.grid(row=0,column=4)
     self.Labour_Rateone=Entry(Thirddataframe,width=13)
     self.Labour_Rateone.grid(row=0,column=5,padx=15, pady=3)
     self.Labour_Rateone.insert(0,"0.00")
     self.Labour_Rateone.bind("<KeyRelease>", self.calculate_the_labour_valueone)
     self.attach_context_menu(self.Labour_Rateone)
                       

     Labour = Label(Thirddataframe, text="Labour Value:")
     Labour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Labourcostone = Entry(Thirddataframe,width=13)
     self.Labourcostone.grid(row=0, column=7,padx=15,pady=3)
     self.Labourcostone.insert(0,"0.00")
     self.attach_context_menu(self.Labourcostone)

     fourthdataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Recharge")
     fourthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fourthdataframe.place(x=0, y=245, width=780, height=80)

     Parts_Uplift=Label(fourthdataframe,text="Parts Uplift")
     Parts_Uplift.grid(row=0,column=0)
     self.Parts_Upliftone= ttk.Entry(fourthdataframe,width=13)
     self.Parts_Upliftone.grid(row=0,column=1,padx=15,pady=3)
     self.Parts_Upliftone.bind("<FocusOut>", self.on_parts_cost_changedone)
     self.Parts_Upliftone.bind("<Double-1>", self.reset_to_originalone) 
     self.attach_context_menu(self.Parts_Upliftone)

     RechParts = Label(fourthdataframe, text="Rech.Parts:")
     RechParts.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechcostone = Entry(fourthdataframe,width=13)
     self.Rechcostone.grid(row=0, column=3,padx=15,pady=3)
     self.Rechcostone.insert(0,"0.00")
     self.Rechcostone.bind("<KeyRelease>", self.on_rechcost_changedone)
     self.attach_context_menu(self.Rechcostone)

     Labour_Uplift= Label(fourthdataframe,text="Labour Uplift")
     Labour_Uplift.grid(row=0,column=4)
     self.Labour_Upliftone= ttk.Entry(fourthdataframe,width=13)
     self.Labour_Upliftone.grid(row=0,column=5,padx=15,pady=3)
     self.Labour_Upliftone.bind("<Double-1>", self.reset_labour_upliftone)
     self.attach_context_menu(self.Labour_Upliftone)

     Rechlabour = Label(fourthdataframe, text="Rech.labour:")
     Rechlabour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechlabcostone = Entry(fourthdataframe,width=11)
     self.Rechlabcostone.grid(row=0, column=7,padx=15,pady=3)
     self.Rechlabcostone.insert(0,"0.00")
     self.attach_context_menu(self.Rechlabcostone)
     #self.Rechlabcostone.bind("<FocusOut>", self.on_rechlabcost_changedone)
     
     self.on_depot_selectedone()
     Rechposted = Label(fourthdataframe, text="Rech.posted:")
     Rechposted.grid(row=1, column=0)
     
     self.rechposted_varone = tk.BooleanVar()
     self.rechposted_valueone = tk.StringVar()
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechpostedcostone = Checkbutton(fourthdataframe,variable=self.rechposted_varone, command=self.toggle_date_entrytwo)
     self.Rechpostedcostone.grid(row=1, column=1,padx=15,pady=3)
     self.attach_context_menu(self.Rechpostedcostone)

     Rechposteddate = Label(fourthdataframe, text="Rech.posted date:")
     Rechposteddate.grid(row=1, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechposteddatecostone = DateEntry(fourthdataframe, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Rechposteddatecostone.grid(row=1, column=3,padx=15,pady=3)
     self.Rechposteddatecostone.set_date(datetime.now().strftime("%d/%m/%Y"))  # Set to a valid date first
     self.Rechposteddatecostone._top_cal.withdraw()  # Hide the calendar popup initially
     self.clear_date_entrytwo()
     self.attach_context_menu(self.Rechposteddatecostone)


     Customerreference = Label(fourthdataframe, text="Customer ref:")
     Customerreference.grid(row=1, column=4)

     self.customerreferencecostone = Entry(fourthdataframe,width=11)
     self.customerreferencecostone.grid(row=1, column=5,padx=15,pady=3)

     fifthdataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=375, width=780, height=115)

     self.notescostone= Text(fifthdataframe,width=80, height='5',wrap='word')
     self.notescostone.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.notescostone)

     Sixthdataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Recharge text")
     Sixthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Sixthdataframe.place(x=0, y=490, width=780, height=115)

     self.rechargecostone= Text(Sixthdataframe,width=80, height='5',wrap='word')
     self.rechargecostone.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.rechargecostone)

     Seventhdataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Customer Specifics")
     Seventhdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seventhdataframe.place(x=0, y=325, width=780, height=50)
     
     self.Customer_specificsone=Entry(Seventhdataframe,width=100,fg="Red")
     self.Customer_specificsone.grid(row=0,column=2)

     cust_id=self.Customer_Identryy.get()
     result=KBACKEND.check_customer_specific(cust_id)
     if result:
        self.Customer_specificsone.delete(0, tk.END)
        self.Customer_specificsone.insert(0,result)
     else:
        self.Customer_specificsone.delete(0, tk.END)
        self.Customer_specificsone.insert(0,"CUSTOMER Does not have SPECAL RECHARGE RATES")
     self.widgetscostlineone=[]

     self.widgetscostlineone.append(self.costlineregone)
     self.widgetscostlineone.append(self.costlinerepone)
     self.widgetscostlineone.append(self.systemcostone)
     self.widgetscostlineone.append(self.odovehcostone)
     self.widgetscostlineone.append(self.repaccocostone)
     self.widgetscostlineone.append(self.Line_createdentryone)
     self.widgetscostlineone.append(self.Line_createdbyone)
     self.widgetscostlineone.append(self.Reasoncosttypesone)
     self.widgetscostlineone.append(self.rtscostcategoryone)
     self.widgetscostlineone.append(self.category_costoneproducts)
     self.widgetscostlineone.append(self.analysiscostone)
     self.widgetscostlineone.append(self.Partscostone)
     self.widgetscostlineone.append(self.Labour_Hoursone)
     self.widgetscostlineone.append(self.Labour_Rateone)
     self.widgetscostlineone.append(self.Labourcostone)
     self.widgetscostlineone.append(self.Parts_Upliftone)
     self.widgetscostlineone.append(self.Rechcostone)
     self.widgetscostlineone.append(self.Labour_Upliftone)
     self.widgetscostlineone.append(self.Rechlabcostone)
     self.widgetscostlineone.append(self.Rechpostedcostone)
     self.widgetscostlineone.append(self.Rechposteddatecostone)
     self.widgetscostlineone.append(self.customerreferencecostone)
     self.widgetscostlineone.append(self.Customer_specificsone)
     self.widgetscostlineone.append(self.notescostone)
     self.widgetscostlineone.append(self.rechargecostone)

     for widget in self.widgetscostlineone:
            widget.bind("<Tab>", self.focus_next_widgetcostlineone)
            widget.bind("<Shift-Tab>", self.focus_previous_widgetcostlineone)
    

    def focus_next_widgetcostlineone(self, event):
        """Move focus to the next widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetscostlineone.index(widget)
        next_index = (current_index + 1) % len(self.widgetscostlineone)
        self.widgetscostlineone[next_index].focus_set()
        return "break"  # Prevent default behavior

    def focus_previous_widgetcostlineone(self, event):
        """Move focus to the previous widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetscostlineone.index(widget)
        previous_index = (current_index - 1) % len(self.widgetscostlineone)
        self.widgetscostlineone[previous_index].focus_set()
        return "break"

    
    def on_recharge_selectedone(self, event=None):
     self.current_selectionone = self.Chargeentryy.get()

    def on_depot_selectedone(self, event=None):
     if self.current_selectionone == "RECHARGE":
        self.update_upliftone()
        self.check_supplier_conditionsone()

    def update_upliftone(self):
     depot_name = self.analysiscostone.get()
     print(f"Depot Name: {depot_name}")
     parts_uplift = KBACKEND.fetch_uplift_forparts(depot_name)
     self.original_uplift_percentageone = parts_uplift
     print(f"Parts Uplift: {parts_uplift}")
     self.Parts_Upliftone.delete(0, tk.END)
     self.Parts_Upliftone.insert(0, f"{parts_uplift}%")
           
            
    def on_parts_cost_changedone(self, event):
     if self.current_selectionone == "RECHARGE":
        try:
            parts_cost = float(self.Partscostone.get())
            parts_uplift_text = self.Parts_Upliftone.get()
            parts_uplift = float(parts_uplift_text.replace('%', ''))
            uplift_amount = parts_cost * (parts_uplift / 100)
            total_cost = parts_cost + uplift_amount
            self.Rechcostone.delete(0, tk.END)
            self.Rechcostone.insert(0, "{:.2f}".format(total_cost))
            self.original_rechcostone = total_cost
        except ValueError:
            pass

    def on_rechcost_changedone(self, event):
     if self.current_selectionone == "RECHARGE":
        try:
            rech_cost = float(self.Rechcostone.get())
            parts_cost = float(self.Partscostone.get())
            if parts_cost > 0:
                uplift_percentage = ((rech_cost - parts_cost) / parts_cost) * 100
                self.Parts_Upliftone.delete(0, tk.END)
                self.Parts_Upliftone.insert(0, "{:.2f}%".format(uplift_percentage))
            else:
                Depot_Name = self.analysiscostone.get()
                print(f"Depot Name: {Depot_Name}")
                parts_uplift = KBACKEND.fetch_uplift_forparts(Depot_Name)
                self.Parts_Upliftone.delete(0, tk.END)
                self.Parts_Upliftone.insert(0, f"{parts_uplift}%")
        except ValueError:
            print("Invalid input for Rechcost or Parts Cost.")
    def reset_to_originalone(self, event):
     self.Parts_Upliftone.delete(0, tk.END)
     self.Parts_Upliftone.insert(0, f"{self.original_uplift_percentageone}%")
    
     self.Rechcostone.delete(0, tk.END)
     self.Rechcostone.insert(0, "{:.2f}".format(self.original_rechcostone))

    def check_supplier_conditionsone(self):
     supplier_name = self.costlinerepone.get()

     if self.current_selectionone == "RECHARGE" and supplier_name == "Petit Forestier Holding":
        self.handle_pp_holding_scenarioone()
     elif self.current_selectionone == "RECHARGE" and supplier_name != "Petit Forestier Holding":
        self.handle_other_supplier_scenarioone()
    
    def calculate_the_labour_valueone(self,event=None):
       self.recharge_selection=self.Chargeentryy.get()
       if self.recharge_selection!= "RECHARGE":
        labour_rate = float(self.Labour_Rateone.get())
        labour_hours = float(self.Labour_Hoursone.get())
        labour_cost = labour_rate * labour_hours
        self.Labourcostone.delete(0, tk.END)
        self.Labourcostone.insert(0, "{:.2f}".format(labour_cost))
       else:
          self.check_supplier_conditionsone()
    def handle_pp_holding_scenarioone(self):
     Depot_Name = self.analysiscostone.get()
     labour_rate = KBACKEND.fetch_labourrate_forlabours(Depot_Name)
     self.Labour_Rateone.delete(0, tk.END)
     self.Labour_Rateone.insert(0, "{:.2f}".format(labour_rate))
     self.Labour_Hoursone.bind("<KeyRelease>", self.calculate_labour_cost_for_pp_holdingone)
     self.Labour_Rateone.bind("<KeyRelease>", self.calculate_labour_cost_for_pp_holdingone)
     self.original_labour_uplift_percentageone = 0.0
     self.calculate_labour_cost_for_pp_holdingone()
    
    def calculate_labour_cost_for_pp_holdingone(self, event=None):
     try:
        labour_rate = float(self.Labour_Rateone.get())
        labour_hours = float(self.Labour_Hoursone.get())
        labour_cost = labour_rate * labour_hours
        self.Labourcostone.delete(0, tk.END)
        self.Labourcostone.insert(0, "{:.2f}".format(labour_cost))
        self.Rechlabcostone.delete(0, tk.END)
        self.Rechlabcostone.insert(0, "{:.2f}".format(labour_cost))
        self.original_rechlabcostone = labour_cost 
     except ValueError:
        print("Invalid input for labour rate or hours.")

    def handle_other_supplier_scenarioone(self):
     Depot_Name=self.analysiscostone.get()
     labour_uplift = KBACKEND.fetch_labouruplift_forlabours(Depot_Name)
     self.Labour_Upliftone.delete(0, tk.END)
     self.Labour_Upliftone.insert(0, "{:.2f}%".format(labour_uplift))
     self.Labour_Rateone.bind("<KeyRelease>", self.calculate_labour_cost_with_upliftone)
     self.Labour_Hoursone.bind("<KeyRelease>", self.calculate_labour_cost_with_upliftone)
     self.Labour_Upliftone.bind("<FocusOut>", self.calculate_labour_cost_with_upliftone)
     self.original_labour_uplift_percentageone = labour_uplift 
     self.calculate_labour_cost_with_upliftone()

    def calculate_labour_cost_with_upliftone(self, event=None):
     try:
        labour_rate = float(self.Labour_Rateone.get())
        labour_hours = float(self.Labour_Hoursone.get())
        labour_uplift_text = self.Labour_Upliftone.get()
        labour_uplift = float(labour_uplift_text.replace('%', ''))
        labour_cost = labour_rate * labour_hours
        self.Labourcostone.delete(0, tk.END)
        self.Labourcostone.insert(0, "{:.2f}".format(labour_cost))
        uplift_amount = labour_cost * (labour_uplift / 100)
        rech_lab_cost = labour_cost + uplift_amount
        self.Rechlabcostone.delete(0, tk.END)
        self.Rechlabcostone.insert(0, "{:.2f}".format(rech_lab_cost))
        self.original_rechlabcostone = rech_lab_cost
     except ValueError:
        print("Invalid input for labour rate, hours, or uplift.")

    #def on_rechlabcost_changed(self, event):
        #rech_lab_cost = float(self.Rechlabcost.get())
        #labour_cost = float(self.Labourcost.get())
        
        #if labour_cost > 0:
            # Calculate uplift percentage
            #labour_uplift_percentage = ((rech_lab_cost - labour_cost) / labour_cost) * 100
            
            # Update Labour_Uplift entry
            #self.Labour_Uplift.delete(0, tk.END)
            #self.Labour_Uplift.insert(0, "{:.2f}%".format(labour_uplift_percentage))
        #else:
            # If labour cost is 0 or negative, keep Labour_Uplift as is
            #pass

    #def on_rechlabcost_changedone(self, event):
     #if self.current_selectionone == "RECHARGE":
        #supplier_name = self.costlinerepone.get()  # Get the supplier name
        
        #if supplier_name == "Petit Forestier Holding":
            # For "Petit Forestier Holding", just update Rechlabcost without calculating uplift
            #try:
                #rech_lab_cost = float(self.Rechlabcostone.get())
                # Save the original Rechlabcost value if it's being updated
                #self.original_rechlabcostone = rech_lab_cost
                # Update Rechlabcost with the new value
                #self.Rechlabcostone.delete(0, tk.END)
                #self.Rechlabcostone.insert(0, "{:.2f}".format(rech_lab_cost))
                
                # Optional: Clear or set Labour_Uplift to 0% if required
                #self.Labour_Upliftone.delete(0, tk.END)
                #self.Labour_Upliftone.insert(0, "0.00%")
                
            #except ValueError:
                #print("Invalid input for Rechlabcost.")
        
        #else:
            # For other suppliers, calculate uplift based on the new Rechlabcost
            #try:
                #rech_lab_cost = float(self.Rechlabcostone.get())
                #labour_cost = float(self.Labourcostone.get())
                
                # Calculate uplift percentage if labour cost is greater than 0
                #if labour_cost > 0:
                    #uplift_percentage = ((rech_lab_cost - labour_cost) / labour_cost) * 100
                    # Update Labour_Uplift entry
                    #self.Labour_Upliftone.delete(0, tk.END)
                    #self.Labour_Upliftone.insert(0, "{:.2f}%".format(uplift_percentage))
                #else:
                    # Restore original uplift or set it to 0% if invalid
                    #if hasattr(self, 'original_labour_uplift_percentage'):
                        #self.Labour_Upliftone.delete(0, tk.END)
                        #self.Labour_Upliftone.insert(0, f"{self.original_labour_uplift_percentageone}%")
                    #else:
                       # self.Labour_Upliftone.delete(0, tk.END)
                        #self.Labour_Upliftone.insert(0, "0.00%")
                
            #except ValueError:
                #print("Invalid input for Rechlabcost or Labour Cost.")

    #def reset_labour_upliftone(self, event):
     #if hasattr(self, 'original_labour_uplift_percentage'):
        #self.Labour_Upliftone.delete(0, tk.END)
        #self.Labour_Upliftone.insert(0, f"{self.original_labour_uplift_percentageone}%")
     #self.Rechlabcostone.delete(0, tk.END)
     #self.Rechlabcostone.insert(0, "{:.2f}".format(self.original_rechlabcostone))
    
    def reset_labour_upliftone(self, event):
     # Resetting Labour_Upliftone to the original uplift percentage
     if hasattr(self, 'original_labour_uplift_percentageone'):
        self.Labour_Upliftone.delete(0, tk.END)
        self.Labour_Upliftone.insert(0, f"{self.original_labour_uplift_percentageone:.2f}%")
     else:
        print("original_labour_uplift_percentageone not set or not available.")

     # Resetting Rechlabcostone to the original value
     if hasattr(self, 'original_rechlabcostone'):
         self.Rechlabcostone.delete(0, tk.END)
         self.Rechlabcostone.insert(0, "{:.2f}".format(self.original_rechlabcostone))
     else:
        print("original_rechlabcostone not set or not available.")
   

    








    
    def update_rtscostcategoryone(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.Reasoncosttypesone.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        type_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        self.categoriesone = KBACKEND.Fetch_Categories_By_Type(type_id)
        
        # Format data for the dropdown
        self.formatted_categoriesone = [f"{row[1]} - {row[2]}" for row in self.categoriesone]
        
        self.rtscostcategoryone.delete(0,tk.END)
        self.category_costoneproducts.delete(0,tk.END)
        # Update rtscostcategory dropdown with the new data
        self.rtscostcategoryone['values'] = self.formatted_categoriesone
        #if formatted_categories:
            #self.rtscostcategory.current(0) 
    
    def update_rtscostproductsone(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.rtscostcategoryone.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        category_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        self.categoriesproone = KBACKEND.Fetch_Products_By_Category(category_id)
        
        # Format data for the dropdown
        self.formatted_categoriesproone = [f"{row[1]} - {row[2]}" for row in self.categoriesproone]
        
        self.category_costoneproducts.delete(0,tk.END)
        # Update rtscostcategory dropdown with the new data
        self.category_costoneproducts['values'] = self.formatted_categoriesproone
        #if formatted_categories:
            #self.category_cost.current(0) 
    def filter_rts_categoryone(self,event):
       current_text = self.rtscostcategoryone.get()
       if current_text == '':
            self.rtscostcategoryone['values'] = self.formatted_categoriesone
       else:
            filtered_category = [category for category in self.formatted_categoriesone if current_text.lower() in category.lower()]
            self.rtscostcategoryone['values'] = filtered_category

    def filter_rts_productsone(self,event):
       current_text = self.category_costoneproducts.get()
       if current_text == '':
            self.category_costoneproducts['values'] = self.formatted_categoriesproone
       else:
            filtered_category = [product for product in self.formatted_categoriesproone if current_text.lower() in product.lower()]
            self.category_costoneproducts['values'] = filtered_category

    
    def clear_date_entrytwo(self):
        # Clear the displayed date in the DateEntry widget
        self.Rechposteddatecostone.delete(0, "end")
    
    def toggle_date_entrytwo(self):
        if self.rechposted_varone.get():
            self.Rechposteddatecostone.set_date(datetime.now().strftime("%d/%m/%Y"))
            self.rechposted_valueone.set("Y")
        else:
           self.clear_date_entrytwo()
           self.rechposted_valueone.set("N")
       
    def update_purchase_information(self,index):
       if index==1:
          self.Close_the_purchase_window()
       if index==2:
          self.update_the_information()
       if index==3:
          self.add_new_ponumber()
    
    def Close_the_purchase_window(self):
       self.purchasehistoryone.destroy()
    
    def update_the_information(self):
        PO_Number=self.Approvalentrypone.get()
        i_number= self.Numberentryy.get()
        # Getting the selected date from the DateEntry widget
        Pocreated_date = self.Issuedentrypone.get_date()
    
        # Getting the current time
        current_time = datetime.now().time()
    
        # Combining selected date and current time into a datetime object
        combined_datetime = datetime.combine(Pocreated_date, current_time)

        Created_By= self.Po_createdbyone.get()

        Supplier_No= self.Accountentrypone.get()

        Order_Category= self.Order_catone.get()

        Fleet_No= self.fleetnumbercostone.get()

        Odometer= self.Odometerentrypone.get()

        Customer_PO= self.Customer_Ponumone.get()

       
        Kofax_Scan= self.Kofaxnoone.get()

        Igloo_invoice=self.Igloonoone.get()

        Supplier_Name=self.Repairerentrypone.get()

        Repaired_Date=self.Repairedentrypone.get_date()

        Time= datetime.now().time()

        Repaired_Datetime= datetime.combine(Repaired_Date,Time)

        Registration=self.Reg_no_entrypone.get()

        KBACKEND.update_the_purchase_orderinfo(PO_Number,i_number,combined_datetime,Created_By,Supplier_No,
                                             Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,Supplier_Name,Repaired_Datetime,Registration)        
    def add_new_ponumber(self):
       self.Repairerentrypone.delete(0,"end")
       self.Accountentrypone.delete(0,"end")
       self.Approvalentrypone.state(['!disabled'])
       self.Approvalentrypone.delete(0,"end")
       self.Issuedentrypone.delete(0,"end")
       self.Po_createdbyone.state(['!disabled'])
       self.Po_createdbyone.delete(0,"end")
       self.fleetnumbercostone.delete(0,"end")
       self.Odometerentrypone.state(['!disabled'])
       self.Odometerentrypone.delete(0,"end")
       self.Repairedentrypone.delete(0,"end")
       self.Order_catone.delete(0,"end")
       self.Customer_Ponumone.delete(0,"end")
       self.Kofaxnoone.delete(0,"end")
       self.Igloonoone.delete(0,"end")
       
       self.Repairerentrypone.focus_set()
       self.Repairerentrypone.insert(0,"")
       self.Accountentrypone.insert(0,"")
       Approval_number=KBACKEND.generate_purchase_order_number()
       self.Approvalentrypone.insert(0,Approval_number)
       self.Approvalentrypone.state(['disabled'])
       current_date = datetime.now().strftime("%d/%m/%Y")
       self.Issuedentrypone.set_date(current_date)
       current_user=getuser()
       self.Po_createdbyone.insert(0,current_user)
       self.Po_createdbyone.state(['disabled'])
       fleet_no=self.fleett.get()
       self.fleetnumbercostone.insert(0,fleet_no)
       Odo=self.Odoentry.get()
       self.Odometerentrypone.state(['!disabled'])
       self.Odometerentrypone.insert(0,Odo)
       self.Odometerentrypone.state(['disabled'])
       self.Repairedentrypone.set_date(current_date)
       self.Order_catone.insert(0,"")
       self.Customer_Ponumone.insert(0,"")
       self.Kofaxnoone.insert(0,"")
       self.Igloonoone.insert(0,"")

       result=KBACKEND.generate_purchase_order_number()
       I_Number=self.Numberentryy.get()
       KBACKEND.save_the_Purchasenumber(result,I_Number)

       self.Table_treepone.delete(*self.Table_treepone.get_children())

    def costline_icons_two(self,index):
       if index==1:
          self.close_the_costline_window()
       if index==2:
          self.save_the_costlines_two()
    def get_combined_datetime_two(self):
        if not self.rechposted_varone.get():
            return None  # Return None if the checkbutton is not checked
        
        # Proceed with date retrieval and combination
        date = self.Rechposteddatecostone.get_date()
        current_time = datetime.now().time()
        combined_datetime = datetime.combine(date, current_time)
        return combined_datetime
    
    def close_the_costline_window(self):
       self.costline_windowone.destroy()
    def save_the_costlines_two(self):
       PO_Number=self.systemcostone.get()
       KBACKEND.generate_line_number(PO_Number)
       Line_Added= self.Line_createdentryone.get_date()
       Time= datetime.now().time()

       bothdateandtime= datetime.combine(Line_Added, Time)
       Added_By=self.Line_createdbyone.get()
       #RTS_code= self.Reasoncostone.get()
       #RTS_Desc=self.rtscostone.get()
       Type=self.Reasoncosttypesone.get()
       if Type:
          type_id=Type.split(' - ')[0]
       else:
          type_id=None
       Category=self.rtscostcategoryone.get()
       if Category:
          Category_id= Category.split(' - ')[0]
       else:
          Category_id=None
       Products=self.category_costoneproducts.get()
       if Products:
          Product_id=Products.split(' - ')[0]
       else:
          Product_id=None

       Typetwo=self.Reasoncosttypesone.get()
       if Typetwo:
          type_idtwo=Typetwo.split(' - ')[1]
       else:
          type_idtwo=None
       Categorytwo=self.rtscostcategoryone.get()
       if Categorytwo:
          Category_idtwo= Categorytwo.split(' - ')[1]
       else:
          Category_idtwo=None
       Productstwo=self.category_costoneproducts.get()
       if Productstwo:
          Product_idtwo=Productstwo.split(' - ')[1]
       else:
          Product_idtwo=None 
       
       combined_value = f"{type_idtwo} | {Category_idtwo} | {Product_idtwo}"

       PF_Depot=self.analysiscostone.get()
       Parts_Cost=self.Partscostone.get()
       Labour_Hours=self.Labour_Hoursone.get()
       Labour_Rate=self.Labour_Rateone.get()
       Labour_cost=self.Labourcostone.get()
       Parts_Uplift=self.Parts_Upliftone.get()
       Labour_Uplift=self.Labour_Upliftone.get()
       Recharge_parts=self.Rechcostone.get()
       Recharge_cost=self.Rechlabcostone.get()
       Recharge_invoiced=self.rechposted_valueone.get()       
       combined_datetime = self.get_combined_datetime_two()
       Notes=self.notescostone.get("1.0", tk.END)
       Recharge_text= self.rechargecostone.get("1.0", tk.END)

       Supplier_Name=self.Repairerentrypone.get()

       Productthree=self.category_costoneproducts.get()
       if Productthree:
          Product_Descriptiom=Productthree.split(' - ')[1]
       else:
          Product_Descriptiom=None
       if type_id and Category_id and Product_id:
        KBACKEND.store_cost_lines_two(PO_Number,bothdateandtime,Added_By,PF_Depot,Parts_Cost,Labour_Hours,
                                 Labour_Rate,Labour_cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_cost,Recharge_invoiced,combined_datetime,
                                 Notes,Recharge_text,type_id,Category_id,Product_id,Supplier_Name,Product_Descriptiom,combined_value)
       
        self.costline_windowone.destroy()
       else:
        # This will display a message box centered over the parent window (self.costline_windowone)
        self.costline_windowone.lift()  # Bring the main window to the top
        self.costline_windowone.attributes('-topmost', True)  # Ensure it's on top
        messagebox.showwarning(
        "Missing Information", 
        "All required fields (Type, Category, and Products) must be entered before saving. Please complete all details.",
        parent=self.costline_windowone
        )
        self.costline_windowone.attributes('-topmost', False) 
       
       self.Table_treepone.delete(*self.Table_treepone.get_children())

       Approval_number= self.Approvalentrypone.get()

       Costlines= KBACKEND.populate_costlines(Approval_number)

       if Costlines:
          for incident in Costlines:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel


             self.Table_treepone.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
       self.populate_all_the_costlines_two()

       Insert_purchase= KBACKEND.retrieve_last_purchase_and_populate(Approval_number)

       self.costlinestableone.delete(*self.costlinestableone.get_children())

       if Insert_purchase:
          for Purchase in Insert_purchase:
            Repaired= Purchase.get("Repaired")
            if Repaired is not None:
             Repaired_date = Repaired.date()
            else:
             print("Repaired is None, cannot access 'date' attribute.")
            Repaired_date = None  # or some default value           
            Odometer=Purchase.get("Odometer")
            Supplier_Name= Purchase.get("Supplier")
            Incident_Link= Purchase.get("Incident_Link")
            Total_Parts=Purchase.get("Total_parts")
            Total_labours=Purchase.get("Total_labours")
            Total_cost= Total_Parts + Total_labours
            Recharge_parts= Purchase.get("Recharge_parts")
            Recharge_labours= Purchase.get("Recharge_labours")
            Total_Recharge= Recharge_parts+ Recharge_labours
            PO_number= Purchase.get("Approval")
            Products=Purchase.get("Products")

            self.costlinestableone.insert("", "end", values=(Repaired_date,Odometer,Supplier_Name,Incident_Link,
                                                         Total_cost,Total_Recharge,PO_number,Products))
       self.populate_top_purchase_order_two()
       
    def onclick_for_purchaseorder_tableone(self,event):
       item = self.costlinestableone.identify_row(event.y)
       print("Clicked on item:", item)
    
      
    
       # Check if item is valid
       if item:
         # Set focus to the clicked row
         self.costlinestableone.focus(item)

       # Get the values from the clicked row
       values = self.costlinestableone.item(item, "values")

       

        # Check if the values list has at least 7 elements
       if len(values) > 6:
         approval_number = values[6]
         
       else:
         approval_number = None  # or handle the case appropriately
   
   
       costline_details= KBACKEND.retrieve_costlines_for_approvalnumber(approval_number)
       
       if costline_details:
       
        self.open_costlines_for_purchaseorder_numberone(costline_details,approval_number) 
       else:
        print("NO DETAILS FOUND")
    def open_costlines_for_purchaseorder_numberone(self,costline_details,approval_number):
        fetch_details=KBACKEND.fetching_selected_approvaldetails(approval_number)
        if fetch_details:
           
           self.Repairerentrypone.delete(0, "end")
           self.Accountentrypone.delete(0,"end")
           self.Approvalentrypone.state(['!disabled'])
           self.Approvalentrypone.delete(0,"end")
           self.Issuedentrypone.delete(0,"end")
           self.Po_createdbyone.state(['!disabled'])
           self.Po_createdbyone.delete(0,"end")
           self.fleetnumbercostone.delete(0,"end")
           self.Odometerentrypone.delete(0,"end")
           self.Repairedentrypone.delete(0,"end")
           self.Order_catone.delete(0,"end")
           self.Customer_Ponumone.delete(0,"end")
           self.Kofaxnoone.delete(0,"end")
           self.Igloonoone.delete(0,"end")
           
           Repairervalue=fetch_details.get('Supplier_Name')
           self.Repairerentrypone.insert(0, Repairervalue if Repairervalue is not None else "")
           Accountvalue= fetch_details.get('Supplier_No')
           self.Accountentrypone.insert(0,Accountvalue if Accountvalue is not None else"")
           Approvalvalue= fetch_details.get('PO_Number')
           self.Approvalentrypone.insert(0,Approvalvalue if Approvalvalue is not None else"")
           self.Approvalentrypone.state(['disabled'])
           Issuedvalue= fetch_details.get('PO_Created')
           self.Issuedentrypone.set_date(Issuedvalue if Issuedvalue is not None else None)
           Po_createdvalue=fetch_details.get('Created_By')#current_user= getuser()
           self.Po_createdbyone.insert(0,Po_createdvalue if Po_createdvalue is not None else "")
           self.Po_createdbyone.state(['disabled'])
           fleetvalue=fetch_details.get('Fleet_No')
           self.fleetnumbercostone.insert(0,fleetvalue if fleetvalue is not None else"")
           Odometervalue= fetch_details.get('Odometer')
           self.Odometerentrypone.insert(0,Odometervalue if Odometervalue is not None else"")

           Repairervaluep= fetch_details.get('Repaired') 
           if Repairervalue is not None:
               self.Repairedentrypone.set_date(Repairervaluep)
           else:
               self.Repairedentrypone.set_date(None)

           Categoryvalue=fetch_details.get('Order_Category')
           self.Order_catone.insert(0,Categoryvalue if Categoryvalue is not None else"")

            
           Customervalue=fetch_details.get('Customer_PO')
           self.Customer_Ponumone.insert(0,Customervalue if Customervalue is not None else"")

           Kofaxvalue=fetch_details.get('Kofax_Scan_No')
           self.Kofaxnoone.insert(0,Kofaxvalue if Kofaxvalue is not None else"")

           Igloovalue=fetch_details.get('Igloo_Invoice_No')
           self.Igloonoone.insert(0,Igloovalue if Igloovalue is not None else"")
        

        self.Table_treepone.delete(*self.Table_treepone.get_children())
        if costline_details:
         for incident in costline_details:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel

             self.Table_treepone.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
        else:
           print("NO DETAILS FOUND")
    
    def open_incident_window(self,index):
        if index==1:
           self.close_the_incident_window()
        if index==2:
           self.save_the_incident_details()
        if index==3:
           self.open_events_From_mainpage()
        if index==4:
           self.on_click_index_4one()
    
    import datetime
    ############### Giving Functionalities for icons of the incidentspage navigated from mainpage ########
    def close_the_incident_window(self):
        self.form_window.destroy()
    def save_the_incident_details(self):
     registration_no=self.reistrationentry.get()
     Driver_name= self.Driverrentry.get()
     fleet_no=self.fleett.get()
     Driver_Phone=self.Driverrphone.get()
     Customer_Id=self.Customer_Identryy.get()
     Customer_name= self.Cust_Namee_Entry.get()
     Contract_No=self.Contract_No_Entryy.get()
     Contact_Tel=self.Contact_Tel_Entryy.get()
     Contact_Email=self.Contact_Email_Entryy.get()
     
     Contact_Name=self.Contact_Name_Entryy.get()
     if Contact_Name=="":
        messagebox.showerror("Error", "Contact Name is an Mandatory field")
     Customer_defect_no=self.Customer_defno_Entryy.get()
     Contact_method=self.Contact_Method_Entryy.get()
     for row in self.contactmethd:
        if row[1] == Contact_method:
            contact_methodd = row[0]
            break
     if Contact_method == "Telephone" and (not Contact_Tel):
            messagebox.showerror("Error", "Telephone is required for this incident.")
     elif Contact_method=="Email" and (not Contact_Email):
          messagebox.showerror("Error", "Email is required for this incident.")
     Depot=self.Depotentryy.get()
     Defect_Address=self.locaentryy.get("1.0", tk.END)
     Incident_No=self.Numberentryy.get()
     selected_date=self.dateeentry.get_date()
     current_time_str = self.modifiedtimetwo.get()
     current_time = datetime.strptime(current_time_str, "%H:%M").time()
     combined_datetime = datetime.combine(selected_date, current_time)
     created_by=self.Timee.get()
     Odometer=self.Odoentry.get()
     Depot_no=self.locationn_1.get()

     cat_selected = self.CatEntryy.get()
     for row in self.categorydetails:
        if row[1] == cat_selected:
            cat_value_to_store = row[0]
            break

     lol=self.LolEntryy.get()
     for row in self.locationdetails:
        if row[1] == lol:
            lol_value_to_store = row[0]
            break
     if lol == "Roadside" and (not Driver_name or not Driver_Phone):
            messagebox.showerror("Error", "Driver name and phone are required for Roadside incidents.")
     charge=self.Chargeentryy.get()
     for row in self.chargedetails:
        if row[1]==charge:
           char_value_to_store= row[0]
           break

     status=self.StatussEntryy.get()
     for row in self.rowsss:
        if row[1]==status:
           stat_value_store= row[0]
           break
     

     Locat=self.LolEntryy.get()
     

     Charge=self.Chargeentryy.get()
    
     Status=self.StatussEntryy.get()

     Faultdesc=self.Faultentryy.get("1.0", tk.END)
     
     Attendance_def= self.attendance_vari.get()
     Deferred_to=self.Deferred_Too.get()

     Deferred_time=self.Deferred_Timetwo.get()
     
     current_time= datetime.now().strftime("%H:%M")
    # Getting the current time
     if Deferred_time is not None:
      datetime_str = f"{Deferred_to} {Deferred_time}"
     else:
     # Handle the case where Deferred_time is None
      datetime_str = f"{Deferred_to} {current_time}" 

    # Convert the datetime string to a datetime object
     if len(datetime_str)>19:
      combined_deferred = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M:%S.%f")
     else:
       combined_deferred = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")
    
     whatwords=self.whatwordsentryy.get()
     SupplierNo=self.nameentryy.get()
     Vehicle_loaded=self.vehiclevar.get()
     customer_name=self.Cust_Namee_Entry.get()
     depot_name=self.locationn_2.get()

     InciType = self.Incitypeentryone.get()
     if InciType is None or InciType == "":
      messagebox.showerror("Error", "'Incident Type' requires a value.")
     else:
        for row in self.Typedetailsone:
         if row[1] == InciType:
            InciType_value_to_store = row[0]
            break

     KBACKEND.update_incident_Details(Driver_name,fleet_no,Driver_Phone,Customer_Id,Contract_No,
                                      Contact_Tel,Contact_Email,Contact_Name,Customer_defect_no,
                                      contact_methodd,Defect_Address,Incident_No,combined_datetime,created_by,Odometer,
                                      Depot_no,cat_value_to_store,lol_value_to_store,char_value_to_store,Faultdesc,stat_value_store,Attendance_def,
                                      combined_deferred,whatwords,registration_no,SupplierNo,Vehicle_loaded,customer_name,depot_name,InciType_value_to_store)
     
     last_updated_incident= KBACKEND.retrieve_updated_incieve(Incident_No)

      ## Clear existing data from Kerride_table
     self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())

     if last_updated_incident:
        for incidents in last_updated_incident:
        # Retrieve attribute values for each incident
         incident_date = incidents.get("Incident Date")
         Customer=incidents.get("Customer")
         registration = incidents.get("Registration")
         I_no=incidents.get("Incident No")
         Status=incidents.get("Status")
         Category=incidents.get("Category")
         loca=incidents.get("Location")
         Charg=incidents.get("Charge")
         Locate= incidents.get("Locationn")
         Owner=incidents.get("Owner")
         Creator=incidents.get("Creator")
         Next_Event_DT=incidents.get("Next_Event_DT")
         if Next_Event_DT is not None:
          Next_Event_Date = Next_Event_DT.date()
          Next_Event_Time = Next_Event_DT.time()
         else:
          Next_Event_Date = None  # or a default value
          Next_Event_Time = None
         # Insert the incident into Kerride_table
         self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locate, registration,I_no,Category,loca,Charg,Status,Owner,Creator,Next_Event_Date,Next_Event_Time))
     self.populate_kerride_table()




    
    def open_events_From_mainpage(self):
     self.save_the_incident_details()
     self.events_window= tk.Toplevel(self.root)
     self.events_window.title("Event Detail Form")
     self.events_window.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.events_window.geometry(f"800x600+{offset_x}+{offset_y}")


       #defining functionalities for icons in the event details page 
     icon_box = tk.Frame(self.events_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

    # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     images = ["icon27.png", "icon28.png"]
     for ideve, path in enumerate(images, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=ideve: self.event_functionalitytwo(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)
    
     Incident_Eventtwo= Frame(self.events_window, bd=3, relief=tk.RIDGE)
     Incident_Eventtwo.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Eventtwo.place(x=0,y=30,width=600,height=100)
     
     #Creating Label and Entry for Event Type, Action required inside Incident Event frame
     self.event_typesinfotwo= KBACKEND.fetch_event_types()
     self.eventtypedetailstwo= [row[1] for row in self.event_typesinfotwo]
     Event_type= Label(Incident_Eventtwo, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entrytwo= ttk.Combobox(Incident_Eventtwo,values=self.eventtypedetailstwo,width=20)
     self.Event_type_entrytwo.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Event_type_entrytwo)

     current_user=getuser()
     Action_required= Label(Incident_Eventtwo, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entrytwo= ttk.Entry(Incident_Eventtwo,width=30)
     self.Action_required_entrytwo.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entrytwo.insert(0,current_user)
     self.attach_context_menu(self.Action_required_entrytwo)
     self.Action_required_entrytwo.state(['disabled'])
     
     

     Createdtwo= LabelFrame(self.events_window,bd=3, relief=tk.RIDGE,text="Created")
     Createdtwo.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Createdtwo.place(x=610,y=30,width=180,height=120)
     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Createdtwo, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entrytwo= DateEntry(Createdtwo, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entrytwo.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_created_Entrytwo)
     self.Date_created_Entrytwo.state(['disabled'])
     #Time
     Time_created= Label(Createdtwo,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entrytwo= ttk.Entry(Createdtwo,width=9)
     current_time = datetime.now().strftime("%H:%M")
     self.Time_created_entrytwo.grid(row=1,column=1,sticky="w")
     self.Time_created_entrytwo.insert(0, current_time)
     self.attach_context_menu(self.Time_created_entrytwo)
     self.Time_created_entrytwo.state(['disabled'])
     


     Event_text=Frame(self.events_window,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entrytwo= Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entrytwo.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.attach_context_menu(self.Event_details_entrytwo)



     


     Next_event= LabelFrame(self.events_window,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)
     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entrytwo= DateEntry(Next_event, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_nextevent_Entrytwo.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_nextevent_Entrytwo)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entrytwo= Entry(Next_event,width=9)
     self.Time_nextevent_entrytwo.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Time_nextevent_entrytwo)
     self.Time_nextevent_entrytwo.bind("<Button-1>", self.open_time_picker_event_final)

     self.typetwo=KBACKEND.fetch_event_types()
     self.typedetailstwo= [row[1] for row in self.typetwo]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entrytwo= ttk.Combobox(Next_event,values=self.typedetailstwo,width=20)
     self.Type_nextevent_entrytwo.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Type_nextevent_entrytwo)
     self.Event_type_entrytwo.bind("<<ComboboxSelected>>", self.populate_next_event_detailstwo)
     self.populate_next_event_detailstwo()
     

     Owner= Label(Next_event, text="Owner")
     Owner.grid(row=4,column=0,padx=5,pady=5)
     self.entire_user_details=KBACKEND.get_the_userdetails()
     self.select_useronly=[row[0] for row in self.entire_user_details]
     self.Owner_entrytwo= ttk.Combobox(Next_event,width=30,values=self.select_useronly)
     self.Owner_entrytwo.grid(row=4,column=1,sticky="w",padx=5,pady=5)
     self.Owner_entrytwo.insert(0,current_user)
     #self.Owner_entrytwo.state(['disabled'])
     self.attach_context_menu(self.Owner_entrytwo)
     
     self.widgetseventttab=[]
     self.widgetseventttab.append(self.Event_type_entrytwo)
     self.widgetseventttab.append(self.Action_required_entrytwo)
     self.widgetseventttab.append(self.Date_created_Entrytwo)
     self.widgetseventttab.append(self.Time_created_entrytwo)
     self.widgetseventttab.append(self.Event_details_entrytwo)
     self.widgetseventttab.append(self.Date_nextevent_Entrytwo)
     self.widgetseventttab.append(self.Time_nextevent_entrytwo)
     self.widgetseventttab.append(self.Type_nextevent_entrytwo)
     self.widgetseventttab.append(self.Owner_entrytwo)

     for widget in self.widgetseventttab:
            widget.bind("<Tab>", self.focus_next_widgeteventone)
            widget.bind("<Shift-Tab>", self.focus_previous_widgeteventone)
    def focus_next_widgeteventone(self, event):
        """Move focus to the next widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetseventttab.index(widget)
        next_index = (current_index + 1) % len(self.widgetseventttab)
        self.widgetseventttab[next_index].focus_set()
        return "break"  # Prevent default behavior

    def focus_previous_widgeteventone(self, event):
        """Move focus to the previous widget in the entry_list."""
        widget = event.widget
        current_index = self.widgetseventttab.index(widget)
        previous_index = (current_index - 1) % len(self.widgetseventttab)
        self.widgetseventttab[previous_index].focus_set()
        return "break"
    
    def open_time_picker_event_final(self, event):
        # Create new window for time selection
        self.time_windoweventone = tk.Toplevel(self.root)
        self.time_windoweventone.title("Select Time")
        self.time_windoweventone.grab_set()
        
        root_x = self.root.winfo_x()
        root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
        offset_x = root_x + 50  # You can adjust this offset value
        offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
        self.time_windoweventone.geometry(f"250x170+{offset_x}+{offset_y}")  

        # Styling the popup window (Center alignment, padding)
        self.time_windoweventone.configure(bg="lightblue")
        frame = ttk.Frame(self.time_windoweventone, padding=10)
        frame.grid(row=0, column=0, padx=20, pady=20)

        # Hour and Minute selection
        hours = [f"{i:02}" for i in range(24)]  # Hours: 00 to 23
        minutes = [f"{i:02}" for i in range(0, 60, 5)]  # Minutes: 00, 05, 10, ..., 55

        # Dropdown for Hour
        ttk.Label(frame, text="Hour").grid(row=0, column=0, padx=5, pady=5, sticky='w')
        self.hour_comboboxeventone = ttk.Combobox(frame, values=hours, width=5)
        self.hour_comboboxeventone.grid(row=0, column=1, padx=5, pady=5)
        self.hour_comboboxeventone.set(datetime.now().strftime("%H"))

        # Dropdown for Minute
        ttk.Label(frame, text="Minute").grid(row=1, column=0, padx=5, pady=5, sticky='w')
        self.minute_comboboxeventone = ttk.Combobox(frame, values=minutes, width=5)
        self.minute_comboboxeventone.grid(row=1, column=1, padx=5, pady=5)
        self.minute_comboboxeventone.set(datetime.now().strftime("%M"))

        # Confirm Button to set the selected time
        confirm_button = ttk.Button(self.time_windoweventone, text="Set Time", command=self.set_timeevent_final)
        confirm_button.grid(row=2, column=0, padx=10, pady=10)

        # Make the popup movable and independent
        
        self.time_windoweventone.grab_set()  # Prevent interaction with main window until popup is closed
        
    # Function to set the time in the entry box
    def set_timeevent_final(self):
        selected_hour = self.hour_comboboxeventone.get()
        selected_minute = self.minute_comboboxeventone.get()

        # Format time as HH:MM
        formatted_time = f"{selected_hour}:{selected_minute}"

        # Set the formatted time in the modifiedtime entry and close the popup
        self.Time_nextevent_entrytwo.config(state='normal')  # Allow editing temporarily
        self.Time_nextevent_entrytwo.delete(0, tk.END)  # Clear current value
        self.Time_nextevent_entrytwo.insert(0, formatted_time)  # Insert selected time
        self.Time_nextevent_entrytwo.config(state='readonly')  # Make it readonly again

        # Close the popup window
        self.time_windoweventone.destroy()


    def populate_next_event_detailstwo(self, event=None):
     selected_event_type = self.Event_type_entrytwo.get()
    
     # Find the corresponding details for the selected event type
     for row in self.event_typesinfotwo:
        if row[1] == selected_event_type:
            next_event_id = row[2]
            if next_event_id is None:  # If there is no next_event_id
                # Set Type_nextevent_entry to the selected event type
                self.Type_nextevent_entrytwo.set(selected_event_type)
                # Set Date_nextevent_Entry to the current date
                current_date = datetime.now().strftime("%d/%m/%Y")
                self.Date_nextevent_Entrytwo.set_date(current_date)
                # Set Time_nextevent_entry to the current time
                current_time = datetime.now().strftime("%H:%M")
                self.Time_nextevent_entrytwo.delete(0, 'end')  # Clear previous value
                self.Time_nextevent_entrytwo.insert(0, current_time)
            else:
                # Find the corresponding description for the next_event_id
                for item in self.typetwo:
                    if item[0] == next_event_id:
                        self.Type_nextevent_entrytwo.set(item[1])
                        minutes = item[3]  # Use minutes from item[3]
                        if minutes > 1440:  # If duration exceeds one day
                            # Calculate the number of days and remaining minutes
                            days = minutes // 1440
                            remaining_minutes = minutes % 1440
                            # Calculate the adjusted date
                            next_date = datetime.now() + timedelta(days=days)
                            date_str = next_date.strftime("%d/%m/%Y")
                            # Populate Date_nextevent_Entry
                            self.Date_nextevent_Entrytwo.set_date(date_str)
                            # Get the current time
                            current_time_str = self.Time_created_entrytwo.get()
                            current_time = datetime.strptime(current_time_str, "%H:%M")
                            # Add remaining minutes to current time
                            adjusted_time = current_time + timedelta(minutes=remaining_minutes)
                        else:
                            # Get the current time
                            current_time_str = self.Time_created_entrytwo.get()
                            current_time = datetime.strptime(current_time_str, "%H:%M")
                            # Add minutes to current time
                            adjusted_time = current_time + timedelta(minutes=minutes)
                        # Format adjusted time
                        adjusted_time_str = adjusted_time.strftime("%H:%M")
                        # Populate Time_nextevent_entry
                        self.Time_nextevent_entrytwo.delete(0, 'end')  # Clear previous value
                        self.Time_nextevent_entrytwo.insert(0, adjusted_time_str)
                        break
            break

    def event_functionalitytwo(self,index):
       if index==1:
          self.exit_the_events()
       elif index==2:
          self.add_the_events_toinci()
    
    def exit_the_events(self):
       self.events_window.destroy()
    def add_the_events_toinci(self):
     i_number=self.Numberentryy.get()
     KBACKEND.generate_event_numbertwo(i_number)

     date_str = self.Date_created_Entrytwo.get()  # Get date as string
     time_str = self.Time_created_entrytwo.get()  # Get time as string

     # Combine date and time strings into a single datetime string
     datetime_str = f"{date_str} {time_str}"

     # Convert the datetime string to a datetime object
     datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

     First_event=self.Event_type_entrytwo.get()
     for row in self.event_typesinfotwo:    
        if row[1] == First_event:
            First_event_tostore = row[0]
            break
         
     Event_text=self.Event_details_entrytwo.get("1.0", tk.END)
     second_event= self.Type_nextevent_entrytwo.get()
     for row in self.typetwo:    
         if row[1] == second_event:
            Second_event_tostore = row[0]
            break
     datee_str= self.Date_nextevent_Entrytwo.get()
     timee_str=self.Time_nextevent_entrytwo.get()
        # Combine date and time strings into a single datetime string
     datetime_strr = f"{datee_str} {timee_str}"
     # Convert the datetime string to a datetime object
     datetime_objj = datetime.strptime(datetime_strr, "%d/%m/%Y %H:%M")
     Created_by= self.Action_required_entrytwo.get()
     Owner=self.Owner_entrytwo.get()

     KBACKEND.insert_more_events(i_number,datetime_obj,First_event_tostore,Event_text
                                     ,Second_event_tostore,datetime_objj,Created_by,Owner)
     
     self.events_window.destroy()
     
     last_updated_event= KBACKEND.retrieve_updated_event(i_number)

      ## Clear existing data from Kerride_table
     self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())

     if last_updated_event:
        for incidents in last_updated_event:
        # Retrieve attribute values for each incident
         incident_date = incidents.get("Incident Date")
         Customer=incidents.get("Customer")
         registration = incidents.get("Registration")
         I_no=incidents.get("Incident No")
         Status=incidents.get("Status")
         Category=incidents.get("Category")
         loca=incidents.get("Location")
         Charg=incidents.get("Charge")
         Locat= incidents.get("Locationn")
         Owner=incidents.get("Owner")
         Creator=incidents.get("Creator")
         Next_Event_DT=incidents.get("Next_Event_DT")
         if Next_Event_DT is not None:
          Next_Event_Date = Next_Event_DT.date()
          Next_Event_Time = Next_Event_DT.time()
         else:
          Next_Event_Date = None  # or a default value
          Next_Event_Time = None
         # Insert the incident into Kerride_table
         self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locat, registration,I_no,Category,loca,Charg,Status,Owner,Creator,Next_Event_Date,Next_Event_Time))
     self.populate_kerride_table()

     event_details= KBACKEND.fetch_all_eventstwo(i_number)
     self.eventss_tree.delete(*self.eventss_tree.get_children())
        
       
     if event_details:
          for event in event_details:
             Event_created= event.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= event.get('Notes')
             Last_updated= event.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= event.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= event.get('Event_Description')
             Next_Event_Description= event.get('Next_Event_Description')




             self.eventss_tree.insert("", "end", values=(Created_date,Created_time,"",Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,"",Follow_up_date,follow_up_time,"",Next_Event_Description))
        
             self.populate_events_tree()
    
    def clicking_the_costlinestwo(self,event):
       selected_item = self.Table_treepone.selection()
       if selected_item:
         # Extract the index of the selected item
         item_index = self.Table_treepone.index(selected_item[0])

         Line_added = item_index + 1

         PO_Number= self.Approvalentrypone.get()

         open_costline_details= KBACKEND.open_costlines_page(PO_Number,Line_added)

         self.open_costlinespage_with_clickedrowtwo(open_costline_details)
    
    def open_costlinespage_with_clickedrowtwo(self,open_costline_details):
       
     self.costline_windowclickone = tk.Toplevel(self.root)
     self.costline_windowclickone.title("Cost Line Form")
     self.costline_windowclickone.resizable(False,False)

     root_x = self.root.winfo_x()
     root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
     offset_x = root_x + 50  # You can adjust this offset value
     offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
     self.costline_windowclickone.geometry(f"800x620+{offset_x}+{offset_y}")

      #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_windowclickone, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png"]
     tool_tips=["Exit the Window"]
     for idcost, (path,tooltip_text) in enumerate(zip(image_paths,tool_tips), start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcost: self.costline_iconsclickone(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         ToolTip(icon_button, tooltip_text)

     
     dataframe = Frame(self.costline_windowclickone, bd=3, relief=tk.RIDGE)
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=35, width=780, height=90)

     Reg_details= self.Reg_no_entrypone.get()
     Reg_no = Label(dataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.costlineregclickone = ttk.Entry(dataframe,width=18)
     self.costlineregclickone.grid(row=0, column=1,padx=10,pady=3)
     self.costlineregclickone.insert(0,Reg_details)
     self.attach_context_menu(self.costlineregclickone)
     self.costlineregclickone.state(['disabled'])
     
     Repairer_name=self.Repairerentrypone.get()
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=2)
     self.costlinerepclickone = ttk.Entry(dataframe, width=18)
     self.costlinerepclickone.grid(row=0, column=3,padx=10,pady=3)
     self.costlinerepclickone.insert(0,Repairer_name)
     self.attach_context_menu(self.costlinerepclickone)
     self.costlinerepclickone.state(['disabled'])
     
     System_number= self.Approvalentrypone.get()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=4)
     self.systemcostclickone = ttk.Entry(dataframe, width=18)
     self.systemcostclickone.grid(row=0, column=5,padx=10,pady=3)
     self.systemcostclickone.insert(0,System_number)
     self.attach_context_menu(self.systemcostclickone)
     self.systemcostclickone.state(['disabled'])
     
     Ododetails=self.Odometerentrypone.get()
     Odometerveh = Label(dataframe, text="Vehicle Odometer:")
     Odometerveh.grid(row=1, column=0,pady=5)
     self.odovehcostclickone = ttk.Entry(dataframe, width=18)
     self.odovehcostclickone.grid(row=1, column=1)
     self.odovehcostclickone.insert(0,Ododetails)
     self.attach_context_menu(self.odovehcostclickone)
     self.odovehcostclickone.state(['disabled'])
     
     Repairer_accountdetails= self.Accountentrypone.get()
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=1, column=2,pady=5)
     self.repaccocostclickone = ttk.Entry(dataframe, width=18)
     self.repaccocostclickone.grid(row=1, column=3)
     self.repaccocostclickone.insert(0,Repairer_accountdetails)
     self.attach_context_menu(self.repaccocostclickone)
     self.repaccocostclickone.state(['disabled'])

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=1,column=4)
     self.Line_createdentryclickone=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentryclickone.grid(row=1,column=5)
     if open_costline_details is not None:
      self.Line_createdentryvalueclickone= open_costline_details.get('Line_Added')
     else:
        self.Line_createdentryvalueclickone= None
     if self.Line_createdentryvalueclickone:
      self.Line_createdentryclickone.set_date(self.Line_createdentryvalueclickone)
     else:
      self.Line_createdentryclickone.set_date(None)

     self.Line_createdentryclickone.state(['disabled'])

     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=2,column=0)
     self.Line_createdbyclickone= ttk.Entry(dataframe,width=18)
     self.Line_createdbyclickone.grid(row=2,column=1)
     if open_costline_details is not None:
        self.Line_createdbyclickvalueone= open_costline_details.get('Added_By')
     else:
        self.Line_createdbyclickvalueone= None
     self.Line_createdbyclickone.insert(0, self.Line_createdbyclickvalueone if self.Line_createdbyclickvalueone is not None else"")
     self.Line_createdbyclickone.state(['disabled'])

     Seconddataframe = Frame(self.costline_windowclickone, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=125, width=780, height=70)

     Reason = Label(Seconddataframe, text="Types:")
     Reason.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Reasoncosttypesclickone = ttk.Combobox(Seconddataframe,width=20)
     self.Reasoncosttypesclickone.grid(row=0, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Reasoncosttypesclickidone= open_costline_details.get('Type_ID')
        self.Reasoncosttypesclickdescone= open_costline_details.get('Type_Desc')
        self.reasoncosttypesclickvalueone = f"{self.Reasoncosttypesclickidone}-{self.Reasoncosttypesclickdescone}" if self.Reasoncosttypesclickidone and self.Reasoncosttypesclickdescone else None
     else:
        self.reasoncosttypesclickvalueone= None
     self.Reasoncosttypesclickone.insert(0,self.reasoncosttypesclickvalueone if self.reasoncosttypesclickvalueone is not None else"")
     self.attach_context_menu(self.Reasoncosttypesclickone)
     self.Reasoncosttypesclickone.state(['disabled'])

     RTS = Label(Seconddataframe, text="Category:")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategoryclickone = ttk.Entry(Seconddataframe,width=20)
     self.rtscostcategoryclickone.grid(row=0, column=3,padx=10,pady=3)
     if open_costline_details is not None:
        self.rtscostcategoryidone= open_costline_details.get('Category_ID')
        self.rtscostcategorydescone= open_costline_details.get('Cat_Desc')
        self.rtscostcategoryclickvalueone=f"{self.rtscostcategoryidone}-{self.rtscostcategorydescone}" if self.rtscostcategoryidone and self.rtscostcategorydescone else None
     else:
        self.rtscostcategoryclickvalueone= None
     self.rtscostcategoryclickone.insert(0,self.rtscostcategoryclickvalueone if self.rtscostcategoryclickvalueone is not None else"")
     self.attach_context_menu(self.rtscostcategoryclickone)
     self.rtscostcategoryclickone.state(['disabled'])

     category_label = tk.Label(Seconddataframe, text="Products:")
     category_label.grid(row=0, column=4)

     self.category_productsclickone = ttk.Combobox(Seconddataframe, width=20)
     self.category_productsclickone.grid(row=0, column=5, padx=15, pady=3)
     if open_costline_details is not None:
      self.costlineproductidone=open_costline_details.get('Product_ID')
      self.costlineproductdescone=open_costline_details.get('Product_Desc')
      self.costlineproductsvalueone=f"{self.costlineproductidone}-{self.costlineproductdescone}" if self.costlineproductidone and self.costlineproductdescone else None
     else:
      self.costlineproductsvalueone=None
     self.category_productsclickone.insert(0,self.costlineproductsvalueone if self.costlineproductsvalueone is not None else"")
     self.attach_context_menu(self.category_productsclickone)
     self.category_productsclickone.state(['disabled'])
     
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscostclickone = ttk.Entry(Seconddataframe, width=18)
     self.analysiscostclickone.grid(row=1, column=1)
     if open_costline_details is not None:
        self.analysiscostclickvalueone= open_costline_details.get('Pf_depot')
     else:
        self.analysiscostclickvalueone=None
     self.analysiscostclickone.insert(0,self.analysiscostclickvalueone if self.analysiscostclickvalueone is not None else"")
     self.attach_context_menu(self.analysiscostclickone)
     self.analysiscostclickone.state(['disabled'])

     Thirddataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=195, width=780, height=50)

     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscostclickone = ttk.Entry(Thirddataframe,width=13)
     self.Partscostclickone.grid(row=0, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Partscostclickvalueone= open_costline_details.get('Parts_cost')
     else:
        self.Partscostclickvalueone= None
     self.Partscostclickone.insert(0,self.Partscostclickvalueone if self.Partscostclickvalueone is not None else"")
     self.attach_context_menu(self.Partscostclickone)
     self.Partscostclickone.state(['disabled'])
     
     Labour_Hours= Label(Thirddataframe,text="Labour Hours:")
     Labour_Hours.grid(row=0,column=2)
     self.Labour_Hoursclickone= ttk.Entry(Thirddataframe,width=13)
     self.Labour_Hoursclickone.grid(row=0,column=3,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labour_Hoursclickonevalue= open_costline_details.get('Labour_Hours')
     else:
        self.Labour_Hoursclickonevalue=None
     self.Labour_Hoursclickone.insert(0,self.Labour_Hoursclickonevalue if self.Labour_Hoursclickonevalue is not None else"")
     self.attach_context_menu(self.Labour_Hoursclickone)
     self.Labour_Hoursclickone.state(['disabled'])

     Labour_Rate=Label(Thirddataframe,text="Labour Rate")
     Labour_Rate.grid(row=0,column=4)
     self.Labour_Rateclickone=ttk.Entry(Thirddataframe,width=13)
     self.Labour_Rateclickone.grid(row=0,column=5,padx=15, pady=3)
     if open_costline_details is not None:
        self.Labour_Rateclickonevalue= open_costline_details.get('Labour_Rate')
     else:
        self.Labour_Rateclickonevalue=None
     self.Labour_Rateclickone.insert(0,self.Labour_Rateclickonevalue if self.Labour_Rateclickonevalue is not None else "0.00")
     self.attach_context_menu(self.Labour_Rateclickone)
     self.Labour_Rateclickone.state(['disabled'])


     Labour = Label(Thirddataframe, text="Labour Value:")
     Labour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Labourcostclickone = ttk.Entry(Thirddataframe,width=13)
     self.Labourcostclickone.grid(row=0, column=7,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labourcostclickvalueone= open_costline_details.get('labour_cost')
     else:
        self.Labourcostclickvalueone= None
     self.Labourcostclickone.insert(0,self.Labourcostclickvalueone if self.Labourcostclickvalueone is not None else"")
     self.attach_context_menu(self.Labourcostclickone)
     self.Labourcostclickone.state(['disabled'])

     fourthdataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Recharge")
     fourthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fourthdataframe.place(x=0, y=245, width=780, height=80)

     Parts_Uplift=Label(fourthdataframe,text="Parts Uplift")
     Parts_Uplift.grid(row=0,column=0)
     self.Parts_Upliftclickone= ttk.Entry(fourthdataframe,width=13)
     self.Parts_Upliftclickone.grid(row=0,column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Parts_Upliftclickvalueone= open_costline_details.get('Parts_Uplift')
     else:
        self.Parts_Upliftclickvalueone=None
     self.Parts_Upliftclickone.insert(0,self.Parts_Upliftclickvalueone if self.Parts_Upliftclickvalueone is not None else"")
     self.attach_context_menu(self.Parts_Upliftclickone)
     self.Parts_Upliftclickone.state(['disabled'])

     RechParts = Label(fourthdataframe, text="Rech.Parts:")
     RechParts.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechcostclickone = ttk.Entry(fourthdataframe,width=13)
     self.Rechcostclickone.grid(row=0, column=3,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechcostclickvalueone= open_costline_details.get('Recharge_parts')
     else:
        self.Rechcostclickvalueone= None
     self.Rechcostclickone.insert(0,self.Rechcostclickvalueone if self.Rechcostclickvalueone is not None else"")
     self.attach_context_menu(self.Rechcostclickone)
     self.Rechcostclickone.state(['disabled'])

     Labour_Uplift= Label(fourthdataframe,text="Labour Uplift")
     Labour_Uplift.grid(row=0,column=4)
     self.Labour_Upliftclickone= ttk.Entry(fourthdataframe,width=13)
     self.Labour_Upliftclickone.grid(row=0,column=5,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labour_Upliftclickvalueone=open_costline_details.get('Labour_Uplift')
     else:
        self.Labour_Upliftclickvalueone=None
     self.Labour_Upliftclickone.insert(0,self.Labour_Upliftclickvalueone if self.Labour_Upliftclickvalueone is not None else"")
     self.attach_context_menu(self.Labour_Upliftclickone)
     self.Labour_Upliftclickone.state(['disabled'])


     Rechlabour = Label(fourthdataframe, text="Rech.labour:")
     Rechlabour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechlabcostclickone = ttk.Entry(fourthdataframe,width=11)
     self.Rechlabcostclickone.grid(row=0, column=7,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechlabcostclickvalueone= open_costline_details.get('Recharge_labour')
     else:
        self.Rechlabcostclickvalueone= None
     self.Rechlabcostclickone.insert(0,self.Rechlabcostclickvalueone if self.Rechlabcostclickvalueone is not None else"")
     self.attach_context_menu(self.Rechlabcostclickone)
     self.Rechlabcostclickone.state(['disabled'])

     Rechposted = Label(fourthdataframe, text="Rech.posted:")
     Rechposted.grid(row=1, column=0)
     
     self.rechposted_varclickone = tk.BooleanVar()
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechpostedcostclickone = ttk.Checkbutton(fourthdataframe,variable=self.rechposted_varclickone)
     self.Rechpostedcostclickone.grid(row=1, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechpostedcostclickvalueone= open_costline_details.get('Recharge_invoiced')
     else:
        self.Rechpostedcostclickvalueone= None
     if self.Rechpostedcostclickvalueone == 'Y':
        checkbox_checked = True
     else:
         checkbox_checked = False
     self.rechposted_varclickone.set(checkbox_checked)
     self.Rechpostedcostclickone.state(['disabled'])

     Rechposteddate = Label(fourthdataframe, text="Rech.posted date:")
     Rechposteddate.grid(row=1, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechposteddatecostclickone = ttk.Entry(fourthdataframe, width=12)
     self.Rechposteddatecostclickone.grid(row=1, column=3,padx=15,pady=3)

     if open_costline_details is not None:
        self.Rechposteddatecostclickvalueone= open_costline_details.get('Recharge_posted')
     else:
        self.Rechposteddatecostclickvalueone= None

     # Format the date to dd/mm/yyyy
     if self.Rechposteddatecostclickvalueone is not None:
      if isinstance(self.Rechposteddatecostclickvalueone, datetime):
        # Format the date to dd/mm/yyyy
        formatted_date = self.Rechposteddatecostclickvalueone.strftime("%d/%m/%Y")
      else:
        formatted_date = ""  # Handle case where the value is not a datetime object
         
     else:
      formatted_date = ""

     # Insert the formatted date into the Entry widget
     self.Rechposteddatecostclickone.insert(0, formatted_date)
     self.Rechposteddatecostclickone.state(['disabled'])
     
     #self.Rechposteddatecostclickone.insert(0,self.Rechposteddatecostclickvalueone if self.Rechposteddatecostclickvalueone is not None else"")
     #self.Rechposteddatecostclickone.state(['disabled'])

     
     Customer_PO= self.Customer_Ponumone.get()
     Customerreference = Label(fourthdataframe, text="Customer ref:")
     Customerreference.grid(row=1, column=4)
     self.customerreferencecostclickone = ttk.Entry(fourthdataframe,width=11)
     self.customerreferencecostclickone.grid(row=1, column=5,padx=15,pady=3)
     self.customerreferencecostclickone.insert(0,Customer_PO if Customer_PO is not None else"")
     self.customerreferencecostclickone.state(['disabled'])

     fifthdataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=375, width=780, height=115)

     self.notescostclickone= tk.Text(fifthdataframe,width=80, height='5',wrap='word')
     self.notescostclickone.grid(row=0,column=0,sticky='w',padx=5)
     if open_costline_details is not None:
        self.notescostclickvalueone= open_costline_details.get('Notes')
     else:
        self.notescostclickvalueone= None
     self.notescostclickone.insert("1.0",self.notescostclickvalueone if self.notescostclickvalueone is not None else"")
     self.attach_context_menu(self.notescostclickone)
     self.notescostclickone['state']='disabled'

     Sixthdataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Recharge text")
     Sixthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Sixthdataframe.place(x=0, y=490, width=780, height=115)

     self.rechargecostclickone= tk.Text(Sixthdataframe,width=80, height='5',wrap='word')
     self.rechargecostclickone.grid(row=0,column=0,sticky='w',padx=5)
     if open_costline_details is not None:
        self.rechargecostclickvalueone= open_costline_details.get('Recharge_text')
     else:
        self.rechargecostclickvalueone= None
     self.rechargecostclickone.insert("1.0",self.rechargecostclickvalueone if self.rechargecostclickvalueone is not None else"")
     self.rechargecostclickone['state']='disabled'
     
     Seventhdataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Customer Specifics")
     Seventhdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seventhdataframe.place(x=0, y=325, width=780, height=50)

     self.Customer_specificsclickone=ttk.Entry(Seventhdataframe,width=100)
     self.Customer_specificsclickone.grid(row=0,column=2)

     cust_id=self.Customer_Identryy.get()
     result=KBACKEND.check_customer_specific(cust_id)
     if result:
        self.Customer_specificsclickone.delete(0, tk.END)
        self.Customer_specificsclickone.insert(0,"This Customer had SPECIAL RECHARGE RATES")
     else:
        self.Customer_specificsclickone.delete(0, tk.END)
        self.Customer_specificsclickone.insert(0,"This Customer did not have SPECAL RECHARGE RATES")
     self.Customer_specificsclickone.state(['disabled'])
       
    def costline_iconsclickone(self,index):
       if index==1:
          self.close_the_Second_costline()
    
    def close_the_Second_costline(self):
       self.costline_windowclickone.destroy()
       
    
    def populate_top_purchase_order(self):
       self.costlinestable.delete(*self.costlinestable.get_children())

       Reg_Number= self.text1.get()

       Purchase_orders=KBACKEND.retrieve_all_purchase_and_populate(Reg_Number)

       if Purchase_orders:
        for incident in Purchase_orders:
           Repaired= incident.get("Repaired")
           if Repaired is not None:
            Repaired_date = Repaired.date()
           else:
            print("Repaired is None, cannot access 'date' attribute.")
            Repaired_date = None  # or some default value           
           Odometer=incident.get("Odometer")
           Supplier_Name= incident.get("Supplier")
           Incident_Link= incident.get("Incident_Link")
           Total_Parts=incident.get("Total_parts")
           Total_labours=incident.get("Total_labours")
           Total_cost= Total_Parts + Total_labours
           Recharge_parts= incident.get("Recharge_parts")
           Recharge_labours= incident.get("Recharge_labours")
           Total_Recharge= Recharge_parts+ Recharge_labours
           PO_number= incident.get("Approval")
           Products=incident.get("Products")

           self.costlinestable.insert("", "end", values=(Repaired_date,Odometer,Supplier_Name,Incident_Link,
                                                         Total_cost,Total_Recharge,PO_number,Products))
    
    def populate_all_the_costlines(self):
       self.Table_treep.delete(*self.Table_treep.get_children())

       Approval_number=self.Approvalentryp.get()

       All_cost_lines= KBACKEND.populate_all_the_cost_lines(Approval_number)

       if All_cost_lines:
          for incident in All_cost_lines:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel


             self.Table_treep.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
             
    def populate_top_purchase_order_two(self):
       self.costlinestableone.delete(*self.costlinestableone.get_children())

       Reg_Number= self.reistrationentry.get()

       Purchase_orders=KBACKEND.retrieve_all_purchase_and_populate(Reg_Number)

       if Purchase_orders:
        for incident in Purchase_orders:
           Repaired= incident.get("Repaired")
           if Repaired is not None:
            Repaired_date = Repaired.date()
           else:
            print("Repaired is None, cannot access 'date' attribute.")
            Repaired_date = None  # or some default value           
           Odometer=incident.get("Odometer")
           Supplier_Name= incident.get("Supplier")
           Incident_Link= incident.get("Incident_Link")
           Total_Parts=incident.get("Total_parts")
           Total_labours=incident.get("Total_labours")
           Total_cost= Total_Parts + Total_labours
           Recharge_parts= incident.get("Recharge_parts")
           Recharge_labours= incident.get("Recharge_labours")
           Total_Recharge= Recharge_parts+ Recharge_labours
           PO_number= incident.get("Approval")
           Products=incident.get("Products")

           self.costlinestableone.insert("", "end", values=(Repaired_date,Odometer,Supplier_Name,Incident_Link,
                                                         Total_cost,Total_Recharge,PO_number,Products))
    def populate_supplier_detailspinsert(self,event=None):
        selected_supplier= self.Repairerentrypone.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.Accountentrypone.delete(0,tk.END)
              self.Accountentrypone.insert(0,row[0])    

    def populate_all_the_costlines_two(self):
       self.Table_treepone.delete(*self.Table_treepone.get_children())

       Approval_number=self.Approvalentrypone.get()

       All_cost_lines= KBACKEND.populate_all_the_cost_lines_two(Approval_number)
       if All_cost_lines:
          for incident in All_cost_lines:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel


             self.Table_treepone.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
    def populate_the_post_incident_reports(self):
       Incident_Number=self.Numberentryy.get()
       Post_incident_report=KBACKEND.fetch_lastpost_reports_and_insert(Incident_Number)

       self.Post_incident_treee.delete(*self.Post_incident_treee.get_children())

       if Post_incident_report:
          for post_details in Post_incident_report:
             Inci_Number= post_details.get("I_number")
             Date_time= post_details.get("Report_Created")
             if Date_time is not None:
              Date = Date_time.date()
              Time = Date_time.time()
             else:
               Date = None  # or a default value
               Time = None
             Created= post_details.get("Created_By")
             Incident_Category= post_details.get("Inc_Category_ID")
             Commentss= post_details.get("Comments")

             self.Post_incident_treee.insert("", "end", values=(Incident_Number,Date,Time,Created,Incident_Category,Commentss))   




       

       
       




     
         



    

    # Giving the functionalities for the icons such as exit and save 
    def open_icon_windowthird(self,index):
        if index == 1:
            self.close_the_third_window()
        elif index == 2:
            self.save_the_details()   
        
    def close_the_third_window(self):
        self.purchase_order.destroy()  
    def save_the_details():
        pass

    

    #This closes the first window and exits the application.
    def close_the_window(self):
        if messagebox.askokcancel("Quit", "Do you want to quit?"):
          self.root.destroy()

    
    #Right click options#
    def copy(self):
        selected_text = self.root.clipboard_get()
        self.root.clipboard_clear()
        self.root.clipboard_append(selected_text)

    def cut(self):
        if self.root.focus_get():
            selected_text = self.root.focus_get().selection_get()
            self.root.focus_get().delete(tk.SEL_FIRST, tk.SEL_LAST)
            self.root.clipboard_clear()
            self.root.clipboard_append(selected_text)

    def paste(self):
        text_to_paste = self.root.clipboard_get()
        self.root.focus_get().insert(tk.INSERT, text_to_paste)

    
    def undo(self):
        if self.undo_stack:
            previous_state = self.undo_stack.pop()
            self.Regtext1.delete(0, tk.END)
            self.Regtext1.insert(0, previous_state)

    def attach_context_menu(self, entry):
        # Create a context menu
        context_menu = tk.Menu(self.root, tearoff=0)
        context_menu.add_command(label="Copy", command=self.copy)
        context_menu.add_command(label="Cut", command=self.cut)
        context_menu.add_command(label="Paste", command=self.paste)
        context_menu.add_command(label="Undo", command=self.undo)
        # Attach context menu to the Entry widget
        def show_context_menu(event):
            context_menu.tk_popup(event.x_root, event.y_root)

        entry.bind("<Button-3>", show_context_menu)

    def open_purchase_history_page(self):
       self.history_window= tk.Toplevel(self.root)
       self.history_window.title("Purchase History")
       self.history_window.resizable(False,False)

       root_x = self.root.winfo_x()
       root_y = self.root.winfo_y()

        # Calculate the position of the registration window based on the root window's position
       offset_x = root_x + 50  # You can adjust this offset value
       offset_y = root_y + 50  # You can adjust this offset value

       # Set the position of the registration window to be relative to the main window
       self.history_window.geometry(f"800x600+{offset_x}+{offset_y}")

       icon_box = tk.Frame(self.history_window, relief=tk.RIDGE, borderwidth=3)
       icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

        # You can add icons below menus using PhotoImage or other methods.
        # For demonstration purposes, let's create 13 small image icons.
       image_paths = ["icon1.png"]
       tooltips = ["Exit the Window"]
    
       for idhistory, (path, tooltip_text)  in enumerate(zip(image_paths, tooltips), start=1):
            image = Image.open(path)
            image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
            photo = ImageTk.PhotoImage(image)
            icon_button = tk.Button(icon_box, image=photo, command=lambda index=idhistory: self.open_history_window(index))
            icon_button.image = photo
            icon_button.pack(side=tk.LEFT, padx=5, pady=2)  # Reduce pady value

            ToolTip(icon_button, tooltip_text)
       dataframe = LabelFrame(self.history_window, bd=3, relief=tk.RIDGE,text="Filter forwards")
       dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
       dataframe.place(x=0, y=40, width=780, height=115) 
       
      
       lb1 = Label(dataframe, text="Registration", padx=10)
       lb1.grid(row=0, column=0)
       self.Regtext1history = Entry(dataframe, width=18)
       self.Regtext1history.grid(row=0, column=1)
       self.attach_context_menu(self.Regtext1history)
       
       
       self.Supplier_details_search=KBACKEND.fetch_supplier_details()
       self.onlysupplierno=[row[1] for row in self.Supplier_details_search]
       lb2 = Label(dataframe, text="Supplier Name", padx=10)
       lb2.grid(row=0, column=2)
       self.supplierhistory = ttk.Combobox(dataframe, width=16,values=self.onlysupplierno)
       self.supplierhistory.grid(row=0, column=3)
       self.supplierhistory.bind("<KeyRelease>", self.filter_supplier_list_history)
       self.attach_context_menu(self.supplierhistory)

       lb6 = Label(dataframe, text="Date-From", padx=10,pady=5)
       lb6.grid(row=1, column=0)
       self.Datefromhistory = DateEntry(dataframe, width=15, background='darkblue', foreground='white', borderwidth=2, date_pattern='yyyy-mm-dd')
       self.Datefromhistory.delete(0, "end")
       self.Datefromhistory.grid(row=1, column=1)
       
       lb6hist = Label(dataframe, text="Date-To", padx=10,pady=5)
       lb6hist.grid(row=1, column=2)
       self.Datetohistory = DateEntry(dataframe, width=15, background='darkblue', foreground='white', borderwidth=2, date_pattern='yyyy-mm-dd')
       self.Datetohistory.delete(0, "end")
       self.Datetohistory.grid(row=1, column=3)

       lb3hist = Label(dataframe, text="RTS Description", padx=10,pady=5)
       lb3hist.grid(row=0, column=4)
       self.descriptionhistory = Entry(dataframe, width=30)
       self.descriptionhistory.grid(row=0, column=5)
       self.attach_context_menu(self.descriptionhistory)

       lb3approval = Label(dataframe, text="Approval-From", padx=10,pady=5)
       lb3approval.grid(row=2, column=0)
       self.Approvalfromhistory = Entry(dataframe, width=18)
       self.Approvalfromhistory.grid(row=2, column=1)
       self.attach_context_menu(self.Approvalfromhistory)

       lb3approvalto = Label(dataframe, text="Approval-To", padx=10,pady=5)
       lb3approvalto.grid(row=2, column=2)
       self.Approvaltohistory = Entry(dataframe, width=18)
       self.Approvaltohistory.grid(row=2, column=3)
       self.attach_context_menu(self.Approvaltohistory)

       self.clear_button_history = ttk.Button(dataframe, text="Clear All",width=10,command=self.clear_filters_history)
       self.clear_button_history.grid(row=2, column=4)

       
       self.attach_events_two()
       

       Detailsframe= LabelFrame(self.history_window, relief=tk.RIDGE,text="Details")
       Detailsframe.place(x=0,y=155,width=780,height=440)

       scrollbar_x = ttk.Scrollbar(Detailsframe, orient=HORIZONTAL)
       scrollbar_y = ttk.Scrollbar(Detailsframe, orient=VERTICAL)

       self.history_table = ttk.Treeview(Detailsframe, column=("Registration", "Created", "Odometer",
                                                            "RTS Description", "Net Value", "Recharge", "Approval", 
                                                            "Supplier No", "Supplier Name"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
    
       self.history_table.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

       scrollbar_x.config(command=self.history_table.xview)
       scrollbar_y.config(command=self.history_table.yview)

       self.history_table.heading("Registration", text="Registration")
       self.history_table.heading("Created", text="Created Date")
       self.history_table.heading("Odometer", text="Odometer")
       self.history_table.heading("RTS Description", text="RTS Description")
       self.history_table.heading("Net Value", text="Net Value")
       self.history_table.heading("Recharge", text="Recharge")
       self.history_table.heading("Approval", text="Approval")
       self.history_table.heading("Supplier No", text="Supplier No")
       self.history_table.heading("Supplier Name", text="Supplier Name")
      

      # Set Treeview to display column headings only
       self.history_table["show"] = "headings"

       self.history_table.column("Registration",width=80)
       self.history_table.column("Created", width=70)
       self.history_table.column("Odometer", width=90)
       self.history_table.column("RTS Description", width=150)
       self.history_table.column("Net Value", width=70)
       self.history_table.column("Recharge", width=70)
       self.history_table.column("Approval", width=85)
       self.history_table.column("Supplier No", width=90)
       self.history_table.column("Supplier Name", width=120)

       scrollbar_y.pack(side=RIGHT, fill=Y)
       scrollbar_x.pack(side=BOTTOM, fill=X)
       # Pack the Treeview widget
       self.history_table.pack(side=LEFT, fill=BOTH, expand=True)
       self.history_table.bind("<MouseWheel>", self.on_scroll)

       self.populate_the_history_table()
    def filter_supplier_list_history(self, event):
        # Function to filter supplier list based on user input
        current_text = self.supplierhistory.get()
        if current_text == '':
            self.supplierhistory['values'] = self.onlysupplierno
        else:
            filtered_suppliers = [supplier for supplier in self.onlysupplierno if current_text.lower() in supplier.lower()]
            self.supplierhistory['values'] = filtered_suppliers
    def open_history_window(self,index):
       if index==1:
          self.exit_the_history_window()
    def exit_the_history_window(self):
       self.history_window.destroy()
    def attach_events_two(self):
        self.Regtext1history.bind("<KeyRelease>", self.filter_history_table)
        self.supplierhistory.bind("<<ComboboxSelected>>", self.filter_history_table)
        self.descriptionhistory.bind("<KeyRelease>", self.filter_history_table)
        self.Datefromhistory.bind("<<DateEntrySelected>>", self.filter_history_table)
        self.Datetohistory.bind("<<DateEntrySelected>>", self.filter_history_table)
        self.Approvalfromhistory.bind("<FocusOut>", self.filter_history_table)
        self.Approvaltohistory.bind("<FocusOut>", self.filter_history_table)
    def clear_filters_history(self):
     # Clear all filter inputs
     self.Regtext1history.delete(0, "end")
     self.supplierhistory.delete(0, "end")
     self.descriptionhistory.delete(0, "end")
     self.Datefromhistory.delete(0,"end")
     self.Datetohistory.delete(0,"end")
     self.Approvalfromhistory.delete(0, "end")
     self.Approvaltohistory.delete(0, "end")
     

     # Repopulate table with all data
     self.populate_the_history_table()
    def debounce(self, func, delay=300):
        last_call_time = [0]

        def debounced_func(event):
            now = self.root.winfo_fpixels('1i')
            if now - last_call_time[0] > delay:
                func(event)
            last_call_time[0] = now

        return debounced_func


    def populate_the_history_table(self, filter_criteria=None,start=0, chunk_size=100):
        # Clear the existing table

        if start == 0:
         self.history_table.delete(*self.history_table.get_children())

        # Get filter criteria if none is provided
        if filter_criteria is None:
            filter_criteria = self.get_filter_criteria_two()

        # Retrieve the full history data
        result = KBACKEND.retrieving_the_history_data()

        filtered_incidents = [history for history in result if self.passes_filter_two(history, filter_criteria)]

         # Paginate the incidents to load only a chunk at a time
        incidents_chunk = filtered_incidents[start:start + chunk_size]

        

        # Populate only the filtered results
        if incidents_chunk:
            for history in incidents_chunk:
                    Reg = history.get("Reg", "")
                    Date = history.get("Date", "")
                    Odo = history.get("Odo", "")
                    Rts = history.get("Rts", "")
                    Net_Value = history.get("Net value", "")
                    Rech = history.get("Rech", "")
                    Approval = history.get("Approval", "")
                    Supplier = history.get("Supplier", "")
                    Supplier_Name = history.get("Supplier Name", "")

                    # Insert row into the table only if it passes the filter
                    self.history_table.insert("", "end", values=(Reg, Date, Odo, Rts, Net_Value, Rech, Approval, Supplier, Supplier_Name))
               

    def get_filter_criteria_two(self):
        return {
            "Registration": self.Regtext1history.get().strip(),
            "Supplier_No": self.supplierhistory.get().strip(),
            "Rts": self.descriptionhistory.get().strip(),
            "Date From": self.Datefromhistory.get_date() if self.Datefromhistory.get() else None,
            "Date To": self.Datetohistory.get_date() if self.Datetohistory.get() else None,
            "Approval From": self.Approvalfromhistory.get().strip(),
            "Approval To": self.Approvaltohistory.get().strip()
        }
    
    from datetime import datetime,date

    def passes_filter_two(self, history, filter_criteria):
     # Extract filter criteria
     filter_registration = filter_criteria["Registration"].lower() if filter_criteria["Registration"] else ""
     filter_supplier_no = filter_criteria["Supplier_No"].lower() if filter_criteria["Supplier_No"] else ""
     filter_rts = filter_criteria["Rts"].lower() if filter_criteria["Rts"] else ""
     filter_date_from = filter_criteria["Date From"]
     filter_date_to = filter_criteria["Date To"]
     filter_approval_from = filter_criteria["Approval From"]
     filter_approval_to = filter_criteria["Approval To"]
     
     

     # Extract data from the history entry
     history_registration = (history.get("Reg", "") or "").strip().lower()
     history_supplier_no = (history.get("Supplier Name", "") or "").strip().lower()
     history_rts = (history.get("Rts", "") or "").strip().lower()
     history_date = history.get("Date")
     history_approval = history.get("Approval")

      # Convert history_date to date if it's a datetime object
     if isinstance(history_date, datetime):
        history_date = history_date.date()
    
     # Convert filter_date_from and filter_date_to to date if they are strings
     if isinstance(filter_date_from, str):
        try:
            filter_date_from = datetime.strptime(filter_date_from, '%Y-%m-%d').date()
        except ValueError:
            filter_date_from = None
     if isinstance(filter_date_to, str):
        try:
            filter_date_to = datetime.strptime(filter_date_to, '%Y-%m-%d').date()
        except ValueError:
            filter_date_to = None

     # Convert filter_approval_from and filter_approval_to to integers if they are strings
     if isinstance(filter_approval_from, str):
        try:
            filter_approval_from = int(filter_approval_from)
        except ValueError:
            filter_approval_from = None
     if isinstance(filter_approval_to, str):
        try:
            filter_approval_to = int(filter_approval_to)
        except ValueError:
            filter_approval_to = None

     # Perform filtering checks
     if filter_registration and filter_registration not in history_registration:
        return False
     if filter_supplier_no and filter_supplier_no not in history_supplier_no:
        return False
     if filter_rts and filter_rts not in history_rts:
        return False

     # Handle date filtering
     if filter_date_from is not None and filter_date_to is not None:
        if history_date is None or not isinstance(history_date, date):
            return False
        if not (filter_date_from <= history_date <= filter_date_to):
            return False
     elif filter_date_from is not None:
        if history_date is None or not isinstance(history_date, date):
            return False
        if history_date != filter_date_from:
            return False
     elif filter_date_to is not None:
        if history_date is None or not isinstance(history_date, date):
            return False
        if history_date > filter_date_to:
            return False

     # Handle approval range filtering
     if filter_approval_from is not None and filter_approval_to is not None:
        if history_approval is None or not isinstance(history_approval, int):
            return False
        if not (filter_approval_from <= history_approval <= filter_approval_to):
            return False
     elif filter_approval_from is not None:
        if history_approval is None or not isinstance(history_approval, int):
            return False
        if history_approval != filter_approval_from:
            return False
     elif filter_approval_to is not None:
        if history_approval is None or not isinstance(history_approval, int):
            return False
        if history_approval > filter_approval_to:
            return False

     return True
    def filter_history_table(self, event=None):
        filter_criteria = self.get_filter_criteria_two()
        self.populate_the_history_table(filter_criteria)
    def on_scroll(self, event):
     """Handler for scrollbar movement to trigger loading more rows."""
     # Get the position of the scrollbar
     if self.history_table.yview()[1] >= 0.95:  # Near the bottom
        # Calculate how many rows have been loaded so far
        loaded_rows = len(self.history_table.get_children())
        # Load more rows from the next chunk
        self.populate_the_history_table(start=loaded_rows)
 
    










if __name__ == "__main__":
 import KBACKEND
 root = tk.Tk()
 login_window = KerridgeReplacement(root)
 root.mainloop()


