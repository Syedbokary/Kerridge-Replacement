import re
import tkinter as tk
from tkinter import LEFT, messagebox,Entry,Text,DISABLED
from tkinter import Frame, LabelFrame,Label,Checkbutton,Button,HORIZONTAL,VERTICAL,BOTTOM,RIGHT,X,Y,BOTH
from tkinter import font
from PIL import Image, ImageTk
from tkinter import ttk 
from tkcalendar import DateEntry
from getpass import getuser
import datetime
from datetime import datetime, timedelta
import webbrowser
import KBACKEND


class KerridgeReplacement:
    
    current_user=getuser()
    KBACKEND.adduser_or_justleave(current_user)
    def __init__(self, root):
        self.root = root
        self.root.title("Kerridge Replacement Application")
        self.root.geometry("800x630")
        self.root.resizable(False, False)

        self.form_window = None
      
        # Initialize your UI
         
        # Add icons within a box
        self.add_icon_box()

        # Add a DataFrame below the icons
        self.add_data_frame()

        self.undo_stack = []
        
        self.incieve=False
        self.incieveone=False

        self.original_uplift_percentage = 0  # Variable to store the original uplift value
        #self.original_rechcost = 0.00
         
       
    #Creating the top 13 icons with images
    def add_icon_box(self):
        # Create a container (Frame) for the icons with a border
        icon_box = tk.Frame(self.root, relief=tk.RIDGE, borderwidth=3)
        icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

        # You can add icons below menus using PhotoImage or other methods.
        # For demonstration purposes, let's create 13 small image icons.
        image_paths = ["icon1.png","icon2.png","extract.png"]
    
        for ida, path in enumerate(image_paths, start=1):
            image = Image.open(path)
            image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
            photo = ImageTk.PhotoImage(image)
            icon_button = tk.Button(icon_box, image=photo, command=lambda index=ida: self.open_icon_window(index))
            icon_button.image = photo
            icon_button.pack(side=tk.LEFT, padx=5, pady=2)  # Reduce pady value
    
        
    #Creating all the dataframes for the first page 
    def add_data_frame(self):
        # Create a DataFrame below the icons
        dataframe = LabelFrame(self.root, bd=3, relief=tk.RIDGE,text="Filter forwards")
        dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
        dataframe.place(x=0, y=40, width=780, height=128) 

        #================Legend frame================================#

        Legendframe= LabelFrame(self.root, relief=tk.RIDGE, text="Legend")
        Legendframe.place(x=0,y=168,width=780,height=80)

        #=================Details Frame===============================#

        Detailsframe= LabelFrame(self.root, relief=tk.RIDGE,text="Details")
        Detailsframe.place(x=0,y=248,width=780,height=380)

       #===================Creating Lables and Text Fields=============================#
        
        lb1 = Label(dataframe, text="Registration", padx=10)
        lb1.grid(row=0, column=0)
        self.Regtext1 = Entry(dataframe, width=18)
        self.Regtext1.grid(row=0, column=1)
        self.attach_context_menu(self.Regtext1)
        
        Customer_details=KBACKEND.get_cust_name()
        self.Customer_details= [row[0] for row in Customer_details]
        lb2 = Label(dataframe, text="Customer", padx=10)
        lb2.grid(row=0, column=2)
        self.custext2 = Entry(dataframe, width=18)
        self.custext2.grid(row=0, column=3)
        self.attach_context_menu(self.custext2)
        
        lb3 = Label(dataframe, text="Owner", padx=5)
        lb3.grid(row=0, column=4)
        self.text3 = Entry(dataframe, width=18)
        self.text3.grid(row=0, column=5)
        self.attach_context_menu(self.text3)

        lb4 = Label(dataframe, text="Creator", padx=5)
        lb4.grid(row=0, column=6)
        self.text4 = Entry(dataframe, width=18)
        self.text4.grid(row=0, column=7)
        self.attach_context_menu(self.text4)

        # Incident Type-Cat
        catdetails=KBACKEND.fetch_cat_details()
        self.catdetails= [row[1] for row in catdetails]
        lb5 = Label(dataframe, text="Defect Cat", padx=5,pady=5)
        lb5.grid(row=1, column=0)
        self.text5 = ttk.Combobox(dataframe, values= self.catdetails, width=15)
        self.text5.grid(row=1, column=1)
        self.attach_context_menu(self.text5)
        
        #Incident Type- Loc
        locationdetails= KBACKEND.fetch_Location_details()
        self.locationdetails= [row[1] for row in locationdetails]
        locationlabel= Label(dataframe,text="Location", padx=5)
        locationlabel.grid(row=1,column=2)
        self.I_location=ttk.Combobox(dataframe,values=self.locationdetails,width=15)
        self.I_location.grid(row=1,column=3)
        self.attach_context_menu(self.I_location)

        #Incident Type- Charge
        Chargedetails=KBACKEND.fetch_charge_details()
        self.chargedetails=[row[1] for row in Chargedetails]
        chargelabel=Label(dataframe,text="Recharge",padx=5)
        chargelabel.grid(row=1,column=4)
        self.I_charge=ttk.Combobox(dataframe,values=self.chargedetails,width=15)
        self.I_charge.grid(row=1,column=5)
        self.attach_context_menu(self.I_charge)
        # Incident date
        lb6 = Label(dataframe, text="Incident date", padx=5)
        lb6.grid(row=1, column=6)
        self.text6 = DateEntry(dataframe, width=15, background='darkblue', foreground='white', borderwidth=2, date_pattern='yyyy-mm-dd')
        self.text6.grid(row=1, column=7)
        #self.text6.set_date(None)
        self.text6.delete(0, "end")
        self.attach_context_menu(self.text6)

        #status
        self.Statusdetails= KBACKEND.fetch_status_details()
        self.stats= [row[1] for row in self.Statusdetails]
        lb7=Label(dataframe,text="Status",padx=5)
        lb7.grid(row=2, column=0)
        self.text7= ttk.Combobox(dataframe,values=self.stats,width=15)
        self.text7.grid(row=2,column=1,padx=5,pady=5)
        self.attach_context_menu(self.text7)
        

        #closed
        self.is_closed= tk.BooleanVar()
        self.text11= Checkbutton(dataframe,variable=self.is_closed,width=2,command=self.filter_kerride_table)
        self.text11.grid(row=2,column=2)
        self.lb8=Label(dataframe,text="Closed")
        self.lb8.grid(row=2, column=3)
        self.attach_context_menu(self.text11)

        #Locations

        lb8= Label(dataframe,text="PF Depot")
        lb8.grid(row=2,column=4)
        self.text12=Entry(dataframe,width=18)
        self.text12.grid(row=2,column=5)
        self.attach_context_menu(self.text12)

        lb9= Label(dataframe,text="Incident_No")
        lb9.grid(row=2,column=6)
        self.text13=Entry(dataframe,width=18)
        self.text13.grid(row=2,column=7)
        self.attach_context_menu(self.text12)
        
        
        self.attach_events()

        
        self.clear_button = ttk.Button(dataframe, text="Clear All",width=10,command=self.clear_filters)
        self.clear_button.grid(row=3, column=7)

        #self.clearbutton = ttk.Button(dataframe, text="Extract Data",command=self.extract_data)
        #self.clearbutton.grid(row=3, column=7)


        #Creating Buttons in the legend frame
        #OverdueButton
        #Creating Buttons in the legend frame
        #OverdueButton
        style = ttk.Style()
        style.configure("Bold.TEntry", foreground="black", font=("Helvetica", 10, "bold"))
        self.bold_font = font.Font(family="Helvetica", size=10, weight="bold")
        btnoverdue = Button(Legendframe, text="Overdue", fg="White", bg="red", width=11, height=1, padx=2, pady=6,
                    command=lambda: self.populate_kerride_table(filter_type="overdue"))
        btnoverdue.grid(row=0, column=0)
        self.entry_red_count = ttk.Entry(Legendframe, width=10,style="Bold.TEntry")
        self.entry_red_count.grid(row=1, column=0)
        self.entry_red_count.configure(foreground="black", font=self.bold_font)

# Half Hour Button
        bthalfhour = Button(Legendframe, text="1/2 Hour", fg="White", bg="Fuchsia", width=10, height=1, padx=2, pady=6,
                    command=lambda: self.populate_kerride_table(filter_type="half_hour"))
        bthalfhour.grid(row=0, column=1)
        self.entry_fuchsia_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_fuchsia_count.grid(row=1, column=1)
        self.entry_fuchsia_count.configure(foreground="black", font=self.bold_font)

# One Hour Button
        btnonehour = Button(Legendframe, text="1 Hour", fg="White", bg="Dark Green", width=10, height=1, padx=2, pady=6,
                    command=lambda: self.populate_kerride_table(filter_type="one_hour"))
        btnonehour.grid(row=0, column=2)
        self.entry_dark_green_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_dark_green_count.grid(row=1, column=2)
        self.entry_dark_green_count.configure(foreground="black", font=self.bold_font)

# Four Hours Button
        btnfourhours = Button(Legendframe, text="4 Hours", fg="White", bg="Black", width=10, height=1, padx=2, pady=6,
                      command=lambda: self.populate_kerride_table(filter_type="four_hours"))
        btnfourhours.grid(row=0, column=3)
        self.entry_black_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_black_count.grid(row=1, column=3)
        self.entry_black_count.configure(foreground="black", font=self.bold_font)

# One Day Button
        btnOneday = Button(Legendframe, text="1 day", fg="White", bg="Green", width=10, height=1, padx=2, pady=6,
                   command=lambda: self.populate_kerride_table(filter_type="one_day"))
        btnOneday.grid(row=0, column=4)
        self.entry_green_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_green_count.grid(row=1, column=4)
        self.entry_green_count.configure(foreground="black", font=self.bold_font)

# Over One Day Button
        btnOverOneday = Button(Legendframe, text="Over 1 day", fg="White", bg="Blue", width=10, height=1, padx=2, pady=6,
                       command=lambda: self.populate_kerride_table(filter_type="over_one_day"))
        btnOverOneday.grid(row=0, column=5)
        self.entry_blue_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_blue_count.grid(row=1, column=5)
        self.entry_blue_count.configure(foreground="black", font=self.bold_font)

# Closed Button
        btnClosed = Button(Legendframe, text="Closed", fg="White", bg="Dark Grey", width=10, height=1, padx=2, pady=6,
                   command=lambda: self.populate_kerride_table(filter_type="closed"))
        btnClosed.grid(row=0, column=6)
        self.entry_dark_grey_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_dark_grey_count.grid(row=1, column=6)
        self.entry_dark_grey_count.configure(foreground="black", font=self.bold_font)

        btnClearFilters = Button(Legendframe, text="Clear Filters", fg="White", bg="Purple", width=10, height=1, padx=2, pady=6,
                         command=lambda: self.populate_kerride_table(filter_type=None))
        btnClearFilters.grid(row=0, column=8)

        btnClearFilters = Button(Legendframe, text="None", fg="White", bg="Violet", width=10, height=1, padx=2, pady=6,
                         command=lambda: self.populate_kerride_table(filter_type="no_event"))
        btnClearFilters.grid(row=0, column=7)
        self.entry_violet_count = ttk.Entry(Legendframe, width=11,style="Bold.TEntry")
        self.entry_violet_count.grid(row=1, column=7)
        self.entry_violet_count.configure(foreground="black", font=self.bold_font)
        
        #==================================Table==================================================#
        #==================Scrollbar==================#
        
        # Create the scrollbars
       # Create the scrollbars
        scrollbar_x = ttk.Scrollbar(Detailsframe, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(Detailsframe, orient=VERTICAL)

        # Create the Treeview widget
        self.root.Kerride_table = ttk.Treeview(Detailsframe, column=("Incident Date", "Customer", "Location",
                                                            "Registration", "Incident No", "Cat", "Loca", 
                                                            "Rech", "Status", "Owner", "Creator", "Due Date", "Time"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
    
        self.root.Kerride_table.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        # Attach the scrollbar commands to the scrollbar widgets
        scrollbar_x.config(command=self.root.Kerride_table.xview)
        scrollbar_y.config(command=self.root.Kerride_table.yview)

        # Set column headings
        self.root.Kerride_table.heading("Incident Date", text="Incident Date")
        self.root.Kerride_table.heading("Customer", text="Customer")
        self.root.Kerride_table.heading("Location", text="Location")
        self.root.Kerride_table.heading("Registration", text="Registration")
        self.root.Kerride_table.heading("Incident No", text="Incident no")
        self.root.Kerride_table.heading("Cat", text="Cat")
        self.root.Kerride_table.heading("Loca", text="Loca")
        self.root.Kerride_table.heading("Rech", text="Rech")
        self.root.Kerride_table.heading("Status", text="Status")
        self.root.Kerride_table.heading("Owner", text="Owner")
        self.root.Kerride_table.heading("Creator", text="Creator")
        self.root.Kerride_table.heading("Due Date", text="Due Date")
        self.root.Kerride_table.heading("Time", text="Time")

        # Set Treeview to display column headings only
        self.root.Kerride_table["show"] = "headings"

        # Set column widths
        self.root.Kerride_table.column("Incident Date", width=76)
        self.root.Kerride_table.column("Customer", width=110)
        self.root.Kerride_table.column("Location", width=70)
        self.root.Kerride_table.column("Registration", width=70)
        self.root.Kerride_table.column("Incident No", width=63)
        self.root.Kerride_table.column("Cat", width=38)
        self.root.Kerride_table.column("Loca", width=38)
        self.root.Kerride_table.column("Rech", width=38)
        self.root.Kerride_table.column("Status", width=45)
        self.root.Kerride_table.column("Owner", width=60)
        self.root.Kerride_table.column("Creator", width=60)
        self.root.Kerride_table.column("Due Date", width=85)
        self.root.Kerride_table.column("Time", width=60)
        
        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.root.Kerride_table.pack(side=LEFT, fill=BOTH, expand=True)

        # Bind the function to the Treeview widget after table creation
        self.root.Kerride_table.bind("<ButtonRelease-1>", self.change_row_color)

    
        self.populate_kerride_table()
    


    def attach_events(self):
        self.Regtext1.bind("<KeyRelease>", self.filter_kerride_table)
        self.custext2.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.custext2.bind("<KeyRelease>", self.filter_kerride_table)
        self.text3.bind("<KeyRelease>", self.filter_kerride_table)
        self.text4.bind("<KeyRelease>", self.filter_kerride_table)
        self.text5.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.I_location.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.I_charge.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.text6.bind("<<DateEntrySelected>>", self.filter_kerride_table)
        self.text7.bind("<<ComboboxSelected>>", self.filter_kerride_table)
        self.text12.bind("<KeyRelease>", self.filter_kerride_table)
        self.text13.bind("<KeyRelease>", self.filter_kerride_table)

    

    #opening an another window from first page icons 
    def open_icon_window(self, index):
        if index == 2:
            self.open_registration_window()
        elif index == 1:
            self.close_the_window()
        elif index==3:
           username=getuser()
           if KBACKEND.is_authority_level_sufficienttwo(username):
            self.open_costlines_without_incidents()
           else:
              messagebox.showwarning("Warning","The user is unable to create purchase orders unless an incident is linked.")
    
    
        # Add more conditions for other icons as needed
    
    #=======================Second page which is icon_2 window starts=====================#
    #Creating a registration window
    def open_registration_window(self):
     self.registration_window = tk.Toplevel(self.root)
     self.registration_window.title("Find Customer")
     self.registration_window.geometry("300x70")
     self.registration_window.resizable(False, False)

      # Get the dimensions of the main window
     main_window_width = self.root.winfo_width()
     main_window_height = self.root.winfo_height()

     # Calculate the center coordinates
     x = self.root.winfo_rootx() + main_window_width // 2 - 150
     y = self.root.winfo_rooty() + main_window_height // 2 - 35

     # Set the registration window's geometry to be positioned at the center
     self.registration_window.geometry(f"+{x}+{y}")

    # Create label and entry field for registration number
     label = Label(self.registration_window, text="Enter Registration No:")
     label.grid(row=0, column=0)

     self.entry = Entry(self.registration_window)
     self.entry.grid(row=0, column=1)

        # Create buttons
     ok_button = Button(self.registration_window, text="OK", command= self.populate_registration)
     ok_button.grid(row=1, column=0)
     self.registration_window.bind('<Return>', self.on_enter_pressed)

     cancel_button = Button(self.registration_window, text="Cancel", command=self.registration_window.destroy)
     cancel_button.grid(row=1, column=1)

    def on_enter_pressed(self, event):
        self.populate_registration()
    
    #Making the entered registration number to populate in my registration number field in incident form
    def populate_registration(self):
        reg_no=self.entry.get()
        if reg_no:
         result = KBACKEND.fetch_details_from_database(reg_no)
        if result:
            self.registration_window.destroy()
            self.open_icon1_window(reg_no)  
        # Populate Entry widgets with fetched details
            self.text1.delete(0, tk.END)
            self.text2.delete(0,tk.END)
            self.Fleet_entry.delete(0, tk.END)
            self.Customer_Identry.delete(0, tk.END)
            self.Cust_Name_Entry.delete(0, tk.END)
            self.Contract_No_Entry.delete(0, tk.END)
            self.location_1.delete(0, tk.END)
            self.Depotentry.delete(0, tk.END)

            self.text1.insert(0, reg_no)
            self.Fleet_entry.insert(0, result[1])
            self.text2.insert(0,result[2])
            self.Customer_Identry.insert(0, result[4])
            self.Cust_Name_Entry.insert(0,result[5]) 
            self.Contract_No_Entry.insert(0,result[3])
            self.location_1.insert(0,result[6])
            self.populate_location_description()
            self.Depotentry.insert(0,result[7])

            fleetno= self.Fleet_entry.get()
            result=KBACKEND.getmileage(fleetno)

            self.Odo.delete(0, tk.END)

            self.Odo.insert(0, result[0] )
            self.Odo.state(['disabled'])

        else:
            messagebox.showwarning("Warning", "Invalid registration number.")
            #self.registration_window.destroy()

        #else:
            #messagebox.showwarning("Warning", "Please enter a registration number.")

    
    def open_icon1_window(self, reg_no):

     self.icon1_window= tk.Toplevel(self.root)
     self.icon1_window.title("Incident Detail Form")
     self.icon1_window.geometry("800x660")  # Adjust the width and height as needed
     self.icon1_window.resizable(False,False)

     main_window_width = self.root.winfo_width()
     main_window_height = self.root.winfo_height()

     # Calculate the center coordinates
     x = self.root.winfo_rootx()
     y = self.root.winfo_rooty()

        # Set the icon1_window's geometry to be positioned exactly on top of the main window
     self.icon1_window.geometry(f"+{x}+{y}")
    #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.icon1_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

    # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon14.png", "icon15.png", "icon16.png","icon17.png"]
     for idb, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idb: self.open_icon_windowsecond(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)
    
    
    # Create frames for each page
         self.main_page = Frame(self.icon1_window)
         self.events_page = Frame(self.icon1_window)
         self.postincident_page = Frame(self.icon1_window)

    # Function to show main page
     def show_main_page():
        self.main_page.pack(fill="both", expand=True)
        self.events_page.pack_forget()
        self.postincident_page.pack_forget()

    # Function to show events page
     def show_events_page():
      self.main_page.pack_forget()
      self.events_page.pack(fill="both", expand=True)
      self.postincident_page.pack_forget()
      self.open_next_window()

     def show_postincident_page():
      self.main_page.pack_forget()
      self.events_page.pack_forget()
      self.postincident_page.pack(fill="both",expand=True)
    
     show_main_page()

      #Creating Buttons Frame for second pagE
     Buttonframe= Frame(self.icon1_window, relief=tk.RIDGE,)
     Buttonframe.place(x=0,y=27,width=780,height=40)

    # Create buttons
     main_button = tk.Button(Buttonframe, text="MAIN", command=show_main_page)
     main_button.pack(side=tk.LEFT, padx=1, pady=2)

     events_button = tk.Button(Buttonframe, text="EVENTS", command=show_events_page)
     events_button.pack(side=tk.LEFT, padx=1, pady=2)

     Post_button = tk.Button(Buttonframe, text="VIEW POST REPORT", command=show_postincident_page)
     Post_button.pack(side=tk.LEFT, padx=1, pady=2)

     self.post_incident_reports=tk.Button(Buttonframe, text="Post Incident Reports",command=self.post_incident_reports_action)
     #post_incident_reports.pack(side=tk.RIGHT,padx=1,pady=2)

    # Main page components
     #First Data Frame for Vehicle Details
     dataframe = LabelFrame(self.main_page, bd=3, relief=tk.RIDGE,text="Vehicle Details")
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=29, width=780, height=100) 

     # Assuming you have a list of registration numbers
     Reg_no = Label(dataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.text1 = Entry(dataframe,width=15)
     self.text1.insert(0, reg_no)
     self.text1.grid(row=0, column=1)
     self.attach_context_menu(self.text1)
     
     #Creating an Entry for page 2
     self.text2 = Entry(dataframe, width=30)
     self.text2.grid(row=0, column=2,padx=70)
     self.attach_context_menu(self.text2)
     
     #Creating a Label and Entry for Driver name:

     self.lb3 = Label(dataframe, text="Driver name:",fg="Red")
     #self.lb3.grid(row=0, column=3)
     self.Driverentry = Entry(dataframe, width=18)
     #self.Driverentry.grid(row=0, column=4)
     self.attach_context_menu(self.Driverentry)

     #Creating a Label and Entry for Fleet No:
     Fleet_No=Label(dataframe, text="Fleet No:")
     Fleet_No.grid(row=1, column=0,pady=6)
     self.Fleet_entry=Entry(dataframe,width=15)
     self.Fleet_entry.grid(row=1,column=1)
     self.attach_context_menu(self.Fleet_entry)

     #Button to view fleet information.

     self.view_fleet = Button(dataframe, text="View fleet info",width=12,command=self.open_fleet_info)
     self.view_fleet.grid(row=2, column=0,padx=20)
     self.base_url = "http://igloouk/Igloo"

     #Creating a Label and Entry for Vehicle loaded:
     vehicle=Label(dataframe,text="Vehicle Loaded")
     vehicle.grid(row=2,column=1,padx=10) 
     self.Vehicle_loaded_var= tk.BooleanVar()
     self.Vehicle_loaded=Checkbutton(dataframe,width=2,variable=self.Vehicle_loaded_var)
     self.Vehicle_loaded.grid(row=2,column=2,sticky='w')
     

     #Creating another Entry for page 2
     text2 = Entry(dataframe, width=30)
     text2.grid(row=1, column=2,padx=80)
     
     #Creating a Label and Entry for Driver Phone:

     self.lb3phone = Label(dataframe, text="Phone:",fg="Red")
     #self.lb3phone.grid(row=1, column=3)
     self.Driverphone = Entry(dataframe, width=18)
     #self.Driverphone.grid(row=1, column=4)
     self.attach_context_menu(self.Driverphone)
    
     #Second Data Frame for Customer and Company Details 
     Customer= LabelFrame(self.main_page, bd=3, relief=tk.RIDGE,text="Customer/Company Details")
     Customer.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Customer.place(x=0,y=130,width=780,height=100)

     #Creating Label for ID and entry
     Customer_Id = Label(Customer, text="Customer_ID:", padx=3, pady=3)
     Customer_Id.grid(row=0, column=0)
     self.Customer_Identry= Entry(Customer, width=14)
     self.Customer_Identry.grid(row=0, column=1)
     self.attach_context_menu(self.Customer_Identry)

     #Creating Label for Cust_Name and entry
     Cust_Name = Label(Customer, text="Name:", padx=3, pady=3)
     Cust_Name.grid(row=0, column=2)
     self.Cust_Name_Entry= Entry(Customer, width=14)
     self.Cust_Name_Entry.grid(row=0, column=3)
     self.attach_context_menu(self.Cust_Name_Entry)   
     #Creating Label for Contract_No and Entry
     
     Contract_No = Label(Customer, text="Contract_No:", padx=3, pady=3)
     Contract_No.grid(row=0, column=4)
     self.Contract_No_Entry= Entry(Customer, width=14)
     self.Contract_No_Entry.grid(row=0, column=5)
     self.attach_context_menu(self.Contract_No_Entry)
     
      #Creating Label for Contact_Tel and Entry

     self.Contact_Tel = Label(Customer, text="Contact_Tel:", padx=3, pady=3,fg="red")
     self.Contact_Tel.grid(row=1, column=2)
     self.Contact_Tel_Entry= Entry(Customer, width=14)
     self.Contact_Tel_Entry.grid(row=1, column=3)
     self.attach_context_menu(self.Contact_Tel_Entry)

    #Creating Label for Contact_Email and Entry

     self.Contact_Email = Label(Customer, text="Contact_Email:", padx=3, pady=3,fg="red")
     self.Contact_Email.grid(row=1, column=4)
     self.Contact_Email_Entry= Entry(Customer, width=14)
     self.Contact_Email_Entry.grid(row=1, column=5)
     self.attach_context_menu(self.Contact_Email_Entry)

      #Creating Label for Contact_Email and Entry

     Contact_Name_Label=Label(Customer, text="Contact_Name:",fg='red', padx=3, pady=3)
     Contact_Name_Label.grid(row=0, column=6)
     self.Contact_Name_Entry= Entry(Customer, width=14)
     self.Contact_Name_Entry.grid(row=0, column=7)
     self.attach_context_menu(self.Contact_Name_Entry)

     #Creating Label for Customer_Defect_No and Entry

     Customer_DefNO=Label(Customer, text="Cust_Def_No:", padx=3, pady=3)
     Customer_DefNO.grid(row=1, column=6)
     self.Customer_defno_Entry= Entry(Customer, width=14)
     self.Customer_defno_Entry.grid(row=1, column=7)
     self.attach_context_menu(self.Customer_defno_Entry)

      #Creating Label for Order_No and Entry

     #Creating Label for Contact_Method_ID AND Entry
     self.contactmeth= KBACKEND.fetch_contact_detais()
     self.contactdetails= [row[1] for row in self.contactmeth]
     Contact_Method_Id=Label(Customer,text="Contact_Method_ID*:",fg="red",padx=3,pady=3)
     Contact_Method_Id.grid(row=1,column=0)
     self.Contact_Method_Entry=ttk.Combobox(Customer,width=12,values=self.contactdetails)
     self.Contact_Method_Entry.grid(row=1,column=1)
     self.attach_context_menu(self.Contact_Method_Entry)
     #self.Contact_Method_Entry.bind("<<ComboboxSelected>>", self.on_contact_method_selected)

     #Creating Label for Depot
     Depot=Label(Customer,text="Customer Depot",padx=3,pady=3)
     Depot.grid(row=2,column=0)
     self.Depotentry=Entry(Customer,width=16)
     self.Depotentry.grid(row=2,column=1)
     self.attach_context_menu(self.Depotentry)

     #Creating a frame for incident details 
      
     Incident_details= LabelFrame(self.main_page, bd=3, relief=tk.RIDGE,text="Incident Details")
     Incident_details.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_details.place(x=0,y=230,width=780,height=345)

     #Creating a label and entry field for location
     Location= Label(Incident_details, text="Location:")
     Location.grid(row=0, column=0,pady=(0,25),sticky='w')
     self.locaentry= Text(Incident_details,width=40, height='3',wrap='word')
     self.locaentry.grid(row=0,column=1,columnspan=2,sticky='w')
     self.attach_context_menu(self.locaentry)
     
     self.view_map = Button(Incident_details, text="View map",width=12,command=self.open_map)
     self.view_map.grid(row=0, column=2,padx=3)
     self.home_url = "https://www.google.com/maps"
     #Creating a label and Entry for Number

     Number= Label(Incident_details,text="Number:")
     Number.grid(row=0,column=3,padx=1)
     self.Numberentry=Entry(Incident_details,width=15)
     gen_number=KBACKEND.generate_new_i_number()
     self.Numberentry.insert(0, gen_number)
     self.Numberentry.grid(row=0,column=4)
     self.attach_context_menu(self.Numberentry)
     
     #Creating Label and Entry for Date
     Date = Label(Incident_details, text="Date", padx=5)
     Date.grid(row=1, column=3,padx=20,pady=4)
     self.datee= DateEntry(Incident_details, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.datee.grid(row=1, column=4,sticky='w')
     self.attach_context_menu(self.datee)

     current_time = datetime.now().strftime("%H:%M")
     Time= Label(Incident_details,text= "Time",padx=5)
     Time.grid(row=2,column=3)
     self.modifiedtime= ttk.Entry(Incident_details,width=15)
     self.modifiedtime.grid(row=2, column=4,sticky='w')
     self.modifiedtime.insert(0,current_time)
     

     #Creating Label and Entry for Time 
     current_user=getuser()
     Created_by = Label(Incident_details, text="Created_By", padx=5)
     Created_by.grid(row=3, column=3)
     self.Time= ttk.Entry(Incident_details, width=15)
     self.Time.grid(row=3, column=4,sticky='w')
     self.Time.insert(0,current_user)
     self.Time.state(['disabled'])
     self.attach_context_menu(self.Time)


     #Creating Label and Entry for Odometer

     Odo= Label(Incident_details, text="Odometer", padx=5)
     Odo.grid(row=4, column=3)
     self.Odo= ttk.Entry(Incident_details, width=13)
     self.Odo.grid(row=4, column=4,sticky='w')
     self.attach_context_menu(self.Odo)
     
     

     #Creating Lable and Entry for Location:
     # Define the label
     self.Loca = tk.Label(Incident_details, text="Depot Loc:", padx=5)
     self.Loca.grid(row=5, column=3)

    # Define locaentry
     # Fetch data from the database using backend function
     rows = KBACKEND.fetch_locations_and_descriptions()
     self.locations = [row[0] for row in rows]  # First column values for dropdown

        # Define loca label

        # Define loca combobox
     self.location_1 = ttk.Combobox(Incident_details, values=self.locations, width=15)
     self.location_1.grid(row=5, column=4, sticky='w')
     self.attach_context_menu(self.location_1)
     

        # Define loca entry
     self.location_2 = tk.Entry(Incident_details, width=15)
     self.location_2.grid(row=6, column=4, sticky='w', columnspan=4)
     self.attach_context_menu(self.location_2)

     self.location_1.bind("<<ComboboxSelected>>", self.populate_location_description)
     

     #Creating a Lable and Entry for Type

     self.Catdetails=KBACKEND.fetch_cat_details()
     self.catdesc=[row[1] for row in self.Catdetails]
     

     Type= Label(Incident_details, text="Category *:",fg="red")
     Type.grid(row=1,column=0,padx=5,pady=6)
     self.CatEntry= ttk.Combobox(Incident_details, values=self.catdesc, width=13)
     self.CatEntry.grid(row=1, column=1, pady=4, sticky='w')
     self.attach_context_menu(self.CatEntry)
     
     loctype= Label(Incident_details, text="Incident Loc *:",fg="red")
     loctype.grid(row=2,column=0,padx=5,pady=6)
     self.Locdetils=KBACKEND.fetch_Location_details()
     self.locdesc= [row[1] for row in self.Locdetils]
     self.LolEntry=ttk.Combobox(Incident_details,values=self.locdesc,width=13)
     self.LolEntry.grid(row=2,column=1,pady=4,sticky='w')
     self.LolEntry.bind("<<ComboboxSelected>>", self.on_location_selected)
     self.attach_context_menu(self.LolEntry)

     Chartype= Label(Incident_details, text="Recharge *:",fg="red")
     Chartype.grid(row=3,column=0,padx=5,pady=2)
     self.Chardetails=KBACKEND.fetch_charge_details()
     self.chardesc=[row[1] for row in self.Chardetails]
     self.Chargeentry=ttk.Combobox(Incident_details,values=self.chardesc,width=13)
     self.Chargeentry.grid(row=3,column=1,pady=2,sticky='w')
     self.Chargeentry.bind("<<ComboboxSelected>>", self.on_recharge_selected)
     self.attach_context_menu(self.Chargeentry)

     #Creating a Label and Entry for Fault Description
     Fault= Label(Incident_details, text="Fault Desription:")
     Fault.grid(row=4, column=0, pady=(0,25),sticky='w')
     self.Faultentry= Text(Incident_details,width=40, height='3',wrap='word')
     self.Faultentry.grid(row=4,column=1,sticky='w')
     self.attach_context_menu(self.Faultentry)
     

     #Creating a Lable and Entry for Status
     self.statrows=KBACKEND.fetch_status_details()
     self.statusdescription= [row[1] for row in self.statrows]
     Statuss= Label(Incident_details, text="Status *:",fg="red")
     Statuss.grid(row=5,column=0,padx=2)
     self.StatussEntry= ttk.Combobox(Incident_details, values=self.statusdescription, width=25)
     self.StatussEntry.grid(row=5, column=1, padx=2,pady=2, sticky='w')
     self.StatussEntry.bind('<<ComboboxSelected>>', self.on_status_selected)
     self.on_status_selected()
     self.attach_context_menu(self.StatussEntry)


     #Creating Label and Entry for Attendance Deferred
     

     Attendance_Def= Label(Incident_details, text="Attendance_Deferred")
     Attendance_Def.grid(row=6,column=0)
     self.attendance_var=tk.BooleanVar()
     self.AttendanceEntry= ttk.Checkbutton(Incident_details, variable=self.attendance_var)
     self.AttendanceEntry.grid(row=6, column=1, sticky='w')
     
     Deff = Label(Incident_details, text='Deferred To')
     Deff.grid(row=7, column=0, padx=2, sticky='w')
     self.Deferred_To = DateEntry(Incident_details, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Deferred_To.grid(row=7, column=1, padx=2, sticky='w')
     self.attach_context_menu(self.Deferred_To)

     Deff_time=Label(Incident_details,text='Deferred To Time')
     Deff_time.grid(row=8,column=0,padx=2, sticky='w')
     self.Deferred_Time= Entry(Incident_details,width=15)
     self.Deferred_Time.grid(row=8,column=1,sticky='w')
     current_time = datetime.now().strftime("%H:%M")
     self.Deferred_Time.insert(0,current_time)
     self.attach_context_menu(self.Deferred_Time)

     whatwords = Label(Incident_details, text='Defect_loc_W3W')
     whatwords.grid(row=7, column=3 ,sticky='w')
     self.whatwordsentry = Entry(Incident_details, width=20)
     self.whatwordsentry.grid(row=7, column=4,sticky='w')  # Set columnspan to 2
     self.attach_context_menu(self.whatwordsentry)

     self.what= tk.Button(Incident_details, text="View map", width=12,command=self.open_what_map)
     self.what.grid(row=8, column=4, columnspan=2, pady=5)
     self.what_url = "https://what3words.com"


   
    #Creating Frame for Supplier details
     Supplier_details=LabelFrame(self.main_page,bd=3,relief=tk.RIDGE,text="Supplier Details")
     Supplier_details.pack(side=tk.TOP,padx=8,pady=3, anchor="nw")
     Supplier_details.place(x=0,y=575,width=780,height=50)

     #Creating label and Entry for Name:
     sup=KBACKEND.fetch_supplier_details()
     self.supplier = [row[1] for row in sup]

     Namesup= Label(Supplier_details, text="Supplier No:")
     Namesup.grid(row=0,column=0,padx=5)
     self.nameentry= ttk.Entry(Supplier_details,width=30)
     self.nameentry.grid(row=0,column=1,padx=5)
     self.attach_context_menu(self.nameentry)
     
      #Creating label and Entry for Contat:
     Contactsup= Label(Supplier_details, text="Supplier Name:")
     Contactsup.grid(row=0,column=2,padx=5,pady=5)
     self.Contactentry= ttk.Combobox(Supplier_details,values=self.supplier,width=30)
     self.Contactentry.grid(row=0,column=3,padx=5,pady=5)
     self.attach_context_menu(self.Contactentry)
     self.Contactentry.bind("<KeyRelease>", self.filter_supplier_list)
     self.Contactentry.bind("<<ComboboxSelected>>", self.populate_supplier_details)

     #Creating Label and Entry for phone 

     Phonesup= Label(Supplier_details, text="Phone:")
     Phonesup.grid(row=0,column=4,padx=5)
     self.Phoneentry= ttk.Entry(Supplier_details,width=20)
     self.Phoneentry.grid(row=0,column=5,padx=5)
     self.attach_context_menu(self.Phoneentry)
     
    # Events page components
     EventsFrame= LabelFrame(self.events_page, relief=tk.RIDGE,text="Events")
     EventsFrame.place(x=0,y=30,width=780,height=500)
    
     
     self.events_tree = ttk.Treeview(EventsFrame, columns=("Created", "Time1", "By1", "Event Type", "Event Action", "Notes", "Last Updated", "Time2","By2", "Follow-Up", "Time3","By3", "Action"),show="headings")
     self.events_tree.pack(fill="both", expand=True)

     self.events_tree.heading("Created", text="Created")
     self.events_tree.heading("Time1", text="Time1")
     self.events_tree.heading("By1", text="By1")
     self.events_tree.heading("Event Type", text="Event Type")
     self.events_tree.heading("Event Action", text="Event Action")
     self.events_tree.heading("Notes", text="Notes")
     self.events_tree.heading("Last Updated", text="Last Updated")
     self.events_tree.heading("Time2", text="Time2")
     self.events_tree.heading("By2",text="By2")
     self.events_tree.heading("Follow-Up", text="Follow-Up")
     self.events_tree.heading("Time3", text="Time3")
     self.events_tree.heading("By3",text="By3")
     self.events_tree.heading("Action", text="Action")

     self.events_tree.column("Created", width=90)
     self.events_tree.column("Time1", width=70)
     self.events_tree.column("By1", width=60)
     self.events_tree.column("Event Type", width=80)
     self.events_tree.column("Event Action", width=80)
     self.events_tree.column("Notes", width=200)
     self.events_tree.column("Last Updated", width=90)
     self.events_tree.column("Time2", width=70)
     self.events_tree.column("By2",width=60)
     self.events_tree.column("Follow-Up", width= 70)
     self.events_tree.column("Time3",width= 70)
     self.events_tree.column("By3",width= 60)
     self.events_tree.column("Action",width= 70)
     

     #Simulate adding some data to the tree
     self.scrollbar_y = ttk.Scrollbar(EventsFrame, orient="vertical", command=self.events_tree.yview)
     self.scrollbar_y.pack(side="right", fill="y")
     self.events_tree.configure(yscrollcommand=self.scrollbar_y.set)

     self.scrollbar_x = ttk.Scrollbar(EventsFrame, orient="horizontal", command=self.events_tree.xview)
     self.scrollbar_x.pack(side="bottom", fill="x")
     self.events_tree.configure(xscrollcommand=self.scrollbar_x.set)

     PostincidentFrame= LabelFrame(self.postincident_page, relief=tk.RIDGE,text="Post Incident Report")
     PostincidentFrame.place(x=0,y=30,width=780,height=300)

     self.Post_incident_tree = ttk.Treeview(PostincidentFrame, columns=("Incident_Number","Date","Time","Created By","Incident Category","Comments"),show="headings")
     self.Post_incident_tree.pack(fill="both", expand=True)

     self.Post_incident_tree.heading("Incident_Number", text="Incident_Number")
     self.Post_incident_tree.heading("Date", text="Date")
     self.Post_incident_tree.heading("Time", text="Time")
     self.Post_incident_tree.heading("Created By", text="Created By")
     self.Post_incident_tree.heading("Incident Category", text="Incident Category")
     self.Post_incident_tree.heading("Comments", text="Comments")
     

     self.Post_incident_tree.column("Incident_Number", width=90)
     self.Post_incident_tree.column("Date", width=70)
     self.Post_incident_tree.column("Time", width=60)
     self.Post_incident_tree.column("Created By", width=80)
     self.Post_incident_tree.column("Incident Category", width=80)
     self.Post_incident_tree.column("Comments", width=200)
     self.Post_incident_tree.bind("<<TreeviewSelect>>",self.clicking_the_postreportsone)
     
    def open_fleet_info(self):
            webbrowser.open(self.base_url)
    def open_map(self):
        address = self.locaentry.get("1.0", tk.END).strip()  # Get the text from the Text widget
        if not address:
            webbrowser.open(self.home_url)
        else:
            formatted_address = address.replace(" ", "+")
            map_url = f"https://www.google.com/maps/search/?api=1&query={formatted_address}"
            webbrowser.open(map_url)
    def open_what_map(self):
        address = self.whatwordsentry.get().strip()  # Get the text from the Entry widget
        if not address:
            webbrowser.open(self.what_url)
        else:
            formatted_address = address.replace(" ", ".")
            map_url = f"https://what3words.com/{formatted_address}"
            webbrowser.open(map_url)
    def filter_supplier_list(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Contactentry.get()
        if current_text == '':
            self.Contactentry['values'] = self.supplier
        else:
            filtered_suppliers = [supplier for supplier in self.supplier if current_text.lower() in supplier.lower()]
            self.Contactentry['values'] = filtered_suppliers
    #def on_contact_method_selected(self, event):
        #selected_method = self.Contact_Method_Entry.get()
        #if selected_method == 'Telephone':
            #self.show_contact_tel()
            #self.hide_contact_email()
        #elif selected_method == 'Email':
            #self.show_contact_email()
            #self.hide_contact_tel()

    #def show_contact_tel(self):
        #self.Contact_Tel.grid(row=1, column=2)
        #self.Contact_Tel_Entry.grid(row=1, column=3)
        #self.Contact_Tel.configure(fg='red')

    #def hide_contact_tel(self):
        #self.Contact_Tel.grid_forget()
        #self.Contact_Tel_Entry.grid_forget()

    #def show_contact_email(self):
        #self.Contact_Email.grid(row=1, column=4)
        #self.Contact_Email_Entry.grid(row=1, column=5)
        #self.Contact_Email.configure(fg='red')

    #def hide_contact_email(self):
        #self.Contact_Email.grid_forget()
        #self.Contact_Email_Entry.grid_forget()
    
    def post_incident_reports_action(self):
      self.open_next_window()
      self.post_window= tk.Toplevel(self.root)
      self.post_window.title("Post Incident Report Form")
      self.post_window.geometry("750x350") 
      self.post_window.resizable(False,False)

      icon_box = tk.Frame(self.post_window, relief=tk.RIDGE, borderwidth=3)
      icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

      # You can add icons below menus using PhotoImage or other methods.
      # For demonstration purposes, let's create 13 small image icons.
      image_paths = ["icon14.png", "icon15.png"]
      for idpost, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idpost: self.postwindowfunctions(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

      First_framepost= LabelFrame(self.post_window, bd=3, relief=tk.RIDGE,text="Post Incident Reports")
      First_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      First_framepost.place(x=0,y=30,width=700,height=120)
      
      Incident_Number=self.Numberentry.get()
      I_No=Label(First_framepost, text="Incident_Number:")
      I_No.grid(row=0, column=0,padx=5)
      self.Incidentnumber_entrypost=Entry(First_framepost,width=15)
      self.Incidentnumber_entrypost.grid(row=0,column=1,padx=5)
      self.Incidentnumber_entrypost.insert(0,Incident_Number)

      Date = Label(First_framepost, text="Date:")
      Date.grid(row=0, column=2,padx=5)
      self.datepost= DateEntry(First_framepost, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
      self.datepost.grid(row=0, column=3,sticky='w',padx=5)
      self.datepost.state(['disabled'])

      current_time = datetime.now().strftime("%H:%M")
      Time= Label(First_framepost,text= "Time:")
      Time.grid(row=0,column=4,padx=5)
      self.timepost= ttk.Entry(First_framepost,width=15)
      self.timepost.grid(row=0, column=5,sticky='w',padx=5,pady=8)
      self.timepost.insert(0,current_time)
      self.timepost.state(['disabled'])

      currentuser=getuser()
      Createdby= Label(First_framepost,text="Created By")
      Createdby.grid(row=1,column=0,padx=5)
      self.createdbypost= ttk.Entry(First_framepost)
      self.createdbypost.grid(row=1,column=1,padx=5)
      self.createdbypost.insert(0,currentuser)
      self.createdbypost.state(['disabled'])

      Inc= Label(First_framepost, text="Incident_Category:")
      Inc.grid(row=1, column=2,padx=5)
      self.Incpost= ttk.Entry(First_framepost, width=15)
      self.Incpost.grid(row=1, column=3,sticky='w')

      self.linked_postvar = tk.BooleanVar()
      self.linked_postvalue = tk.StringVar()
      self.Linkedpost=Checkbutton(First_framepost,width=2,variable=self.linked_postvar,command=self.toggle_post_entry)
      self.Linkedpost.grid(row=1,column=4,sticky='w',padx=3)
      Linked_Orders= Label(First_framepost,text="Final Costed")
      Linked_Orders.grid(row=1,column=5,padx=5,pady=5)

      self.catdetailsforpostincident=KBACKEND.fetch_cat_details()
      self.catdetailspost= [row[1] for row in self.catdetailsforpostincident]
      lb5 = Label(First_framepost, text="Defect Cat*",fg="red", padx=5,pady=5)
      lb5.grid(row=2, column=0)
      self.Categorypost = ttk.Combobox(First_framepost, values= self.catdetailspost, width=15)
      self.Categorypost.grid(row=2, column=1)

      self.verdictdetails=KBACKEND.fetch_verdict_details()
      self.verdictdetailspost=[row[1] for row in self.verdictdetails]
      lb6 = Label(First_framepost, text="PIR_Verdict*",fg="red", padx=5,pady=5)
      lb6.grid(row=2, column=2)
      self.PIR_verdict = ttk.Combobox(First_framepost, values= self.verdictdetailspost, width=15)
      self.PIR_verdict.grid(row=2, column=3)

      Second_framepost= Frame(self.post_window, bd=3, relief=tk.RIDGE)
      Second_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      Second_framepost.place(x=0,y=150,width=700,height=180)

      comments= Label(Second_framepost, text="Comments:")
      comments.grid(row=0, column=0,pady=5,sticky='w')
      self.commentspost= Text(Second_framepost,width=40, height='8',wrap='word')
      self.commentspost.grid(row=0,column=1,columnspan=2,sticky='w',pady=5)

      
    def toggle_post_entry(self):
        if self.linked_postvar.get():
            self.linked_postvalue.set("Y")
        else:
           self.linked_postvalue.set("N")



      
    
    def postwindowfunctions(self,index):
       if index==1:
          self.exit_the_post_incident_report()
       if index==2:
          self.save_the_post_incident_report()
    def exit_the_post_incident_report(self):
       self.post_window.destroy()
    def save_the_post_incident_report(self):
       Incident_Number=self.Incidentnumber_entrypost.get()
       date_str=self.datepost.get_date()
       time_str=self.timepost.get()

       current_time = datetime.strptime(time_str, "%H:%M").time()

       combined_datetime = datetime.combine(date_str, current_time)

       Created_By= self.createdbypost.get()

       Incident_cat=self.Incpost.get()

       Final_costed=self.linked_postvalue.get()

       Comments=self.commentspost.get("1.0", tk.END)

       category_post= self.Categorypost.get()
       if category_post is None or category_post == "":
          messagebox.showerror("Error", "Primary key attribute 'Defect_cat' requires a value.")
       else:
         for row in self.catdetailsforpostincident:
          if row[1] == category_post:
            category_post_value_to_store = row[0]
            break
       verdict_post=self.PIR_verdict.get()
       if verdict_post is None or verdict_post=="":
          messagebox.showerror("Error", "Primary key attribute 'PIR_Verdict' requires a value.")
       else:
          for row in self.verdictdetails:
             if row[1]== verdict_post:
               verdict_post_value_to_store=row[0]
               break

     

       KBACKEND.store_the_postincident_reports(Incident_Number,combined_datetime,Created_By,Incident_cat,
                                               Final_costed,Comments,category_post_value_to_store,verdict_post_value_to_store)
       
       Incident_Number= self.Numberentry.get()
       Post_incident_report=KBACKEND.fetch_lastpost_reports_and_insert(Incident_Number)

       self.Post_incident_tree.delete(*self.Post_incident_tree.get_children())

       if Post_incident_report:
          for post_details in Post_incident_report:
             #Inci_Number= post_details.get("I_number")
             Date_time= post_details.get("Report_Created")
             if Date_time is not None:
              Date = Date_time.date()
              Time = Date_time.time()
             else:
               Date = None  # or a default value
               Time = None
             Created= post_details.get("Created_By")
             Incident_Category= post_details.get("Inc_Category_ID")
             Commentss= post_details.get("Comments")

             self.Post_incident_tree.insert("", "end", values=(Incident_Number,Date,Time,Created,Incident_Category,Commentss))
             
             self.post_incident_reports.config(state=DISABLED)

    def on_status_selected(self, event=None):
        selected_status = self.StatussEntry.get()
        current_user=getuser()
        
        if selected_status == "Completed" and KBACKEND.is_authority_level_sufficient(current_user):
            self.post_incident_reports.pack(side=tk.RIGHT, padx=1, pady=2)
        else:
            self.post_incident_reports.pack_forget()
        if selected_status == "Closed": 
           Incident_Number = self.Numberentry.get()
           if not KBACKEND.fetch_postreports(Incident_Number):
                messagebox.showwarning("Warning", "Create a post incident report before closing the incident.")
                self.StatussEntry.set('')  # Clear the selection
           else:
               self.StatussEntry.set("Closed")
               #self.StatussEntry.state(['disabled'])
    def on_location_selected(self, event):
        selected_location = self.LolEntry.get()
        
        if selected_location == "Roadside":
            self.lb3.grid(row=0, column=3)
            self.Driverentry.grid(row=0, column=4)
            self.lb3phone.grid(row=1, column=3)
            self.Driverphone.grid(row=1, column=4)

        else:
            self.lb3.grid_remove()
            self.Driverentry.grid_remove()
            self.lb3phone.grid_remove()
            self.Driverphone.grid_remove()
    def clicking_the_postreportsone(self,event):
       selected_item = self.Post_incident_tree.selection()
       if selected_item:
         # Extract the index of the selected item
         #item_index = self.Table_treep.index(selected_item[0])

         Incident_Number= self.Numberentry.get()

         open_post_report_details= KBACKEND.fetch_lastpost_reports_and_inserttwo(Incident_Number)

         self.open_postreports_with_clickedrowone(open_post_report_details)
    def open_postreports_with_clickedrowone(self,open_post_report_details):
      self.post_windowclick= tk.Toplevel(self.root)
      self.post_windowclick.title("Post Incident Report Form")
      self.post_windowclick.geometry("750x350") 
      self.post_windowclick.resizable(False,False)

      First_framepost= LabelFrame(self.post_windowclick, bd=3, relief=tk.RIDGE,text="Post Incident Reports")
      First_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      First_framepost.place(x=0,y=30,width=700,height=120)
      
      Incident_Number=self.Numberentry.get()
      I_No=Label(First_framepost, text="Incident_Number:")
      I_No.grid(row=0, column=0,padx=5)
      self.Incidentnumber_entrypostclick=ttk.Entry(First_framepost,width=15)
      self.Incidentnumber_entrypostclick.grid(row=0,column=1,padx=5)
      self.Incidentnumber_entrypostclick.insert(0,Incident_Number)
      self.Incidentnumber_entrypostclick.state(['disabled'])

      Date = Label(First_framepost, text="Date:")
      Date.grid(row=0, column=2,padx=5)
      self.datepostclick= DateEntry(First_framepost, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
      self.datepostclick.grid(row=0, column=3,sticky='w',padx=5)
      if open_post_report_details is not None:
         self.datepostvalueclick= open_post_report_details.get("Report_Created")
      else:
         self.datepostvalueclick=None
      self.datevalueclick= self.datepostvalueclick.date()
      self.datepostclick.set_date(self.datevalueclick)
      self.datepostclick.state(['disabled'])

      Time= Label(First_framepost,text= "Time:")
      Time.grid(row=0,column=4,padx=5)
      self.timepostclick= ttk.Entry(First_framepost,width=15)
      self.timepostclick.grid(row=0, column=5,sticky='w',padx=5,pady=8)
      if open_post_report_details is not None:
         self.timepostclickvalue= open_post_report_details.get("Report_Created")
      else:
         self.timepostclickvalue= None
      self.timevalueclick= self.timepostclickvalue.time()
      self.timepostclick.insert(0,self.timevalueclick)
      self.timepostclick.state(['disabled'])

      
      Createdby= Label(First_framepost,text="Created By")
      Createdby.grid(row=1,column=0,padx=5)
      self.createdbypostclick= ttk.Entry(First_framepost)
      self.createdbypostclick.grid(row=1,column=1,padx=5)
      if open_post_report_details is not None:
       self.createdbypostclickvalue= open_post_report_details.get("Created_By")
      else:
         self.createdbypostclickvalue=None
      self.createdbypostclick.insert(0,self.createdbypostclickvalue)
      self.createdbypostclick.state(['disabled'])
      

      Inc= Label(First_framepost, text="Incident_Category:")
      Inc.grid(row=1, column=2,padx=5)
      self.Incpostclick= ttk.Entry(First_framepost, width=15)
      self.Incpostclick.grid(row=1, column=3,sticky='w')
      if open_post_report_details is not None:
         self.Incpostclickvalue=open_post_report_details.get("Inc_Category_ID")
      else:
         self.Incpostclickvalue= None
      self.Incpostclick.insert(0,self.Incpostclickvalue)
      self.Incpostclick.state(['disabled'])

      self.linked_postvarclick = tk.BooleanVar()
      self.Linkedpostclick=ttk.Checkbutton(First_framepost,width=2,variable=self.linked_postvarclick)
      self.Linkedpostclick.grid(row=1,column=4,sticky='w',padx=3)
      if open_post_report_details is not None:
         self.Linkedpostclickvalue= open_post_report_details.get("Linked_Orders")
      else:
         self.Linkedpostclickvalue= None
      if self.Linkedpostclickvalue=='Y':
         checkbox=True
      else:
         checkbox=False
      self.linked_postvarclick.set(checkbox)
      self.Linkedpostclick.state(['disabled'])
      Linked_Orders= Label(First_framepost,text="Final Costed")
      Linked_Orders.grid(row=1,column=5,padx=5,pady=5)

      self.catdetailsforpostincidentclick=KBACKEND.fetch_cat_details()
      self.catdetailspostclick= [row[1] for row in self.catdetailsforpostincidentclick]
      lb5 = Label(First_framepost, text="Defect Cat*",fg="red", padx=5,pady=5)
      lb5.grid(row=2, column=0)
      self.Categorypostclick = ttk.Combobox(First_framepost, values= self.catdetailspostclick, width=15)
      self.Categorypostclick.grid(row=2, column=1)
      if open_post_report_details is not None:
         self.Categorypostclickvalue= open_post_report_details.get("Category")
      else:
         self.Categorypostclickvalue= None
      self.Categorypostclick.insert(0,self.Categorypostclickvalue)
      self.Categorypostclick.state(['disabled'])

      self.verdictdetailsclick=KBACKEND.fetch_verdict_details()
      self.verdictdetailspostclick=[row[1] for row in self.verdictdetailsclick]
      lb6 = Label(First_framepost, text="PIR_Verdict*",fg="red", padx=5,pady=5)
      lb6.grid(row=2, column=2)
      self.PIR_verdictclick = ttk.Combobox(First_framepost, values= self.verdictdetailspostclick, width=13)
      self.PIR_verdictclick.grid(row=2, column=3)
      if open_post_report_details is not None:
         self.PIR_verdictclickvalue=open_post_report_details.get("Verdict")
      else:
         self.PIR_verdictclickvalue=None
      self.PIR_verdictclick.insert(0,self.PIR_verdictclickvalue)
      self.PIR_verdictclick.state(['disabled'])

      Second_framepost= Frame(self.post_windowclick, bd=3, relief=tk.RIDGE)
      Second_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      Second_framepost.place(x=0,y=150,width=700,height=180)

      comments= Label(Second_framepost, text="Comments:")
      comments.grid(row=0, column=0,pady=5,sticky='w')
      self.commentspostclick= tk.Text(Second_framepost,width=40, height='8',wrap='word')
      self.commentspostclick.grid(row=0,column=1,columnspan=2,sticky='w',pady=5)
      if open_post_report_details is not None:
         self.commentspostclickvalue= open_post_report_details.get("Comments")
      else:
         self.commentspostclickvalue=None
      self.commentspostclick.insert("1.0",self.commentspostclickvalue)
      self.commentspostclick['state']='disabled'

            
    #Creating Event list for the third icon
    def create_event_list(self):
     self.icon3_window= tk.Toplevel(self.root)
     self.icon3_window.title("Event Detail Form")
     self.icon3_window.geometry("800x600") 
     self.icon3_window.resizable(False,False)

     Incident_Event= Frame(self.icon3_window, bd=3, relief=tk.RIDGE)
     Incident_Event.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Event.place(x=0,y=30,width=600,height=100)
     
     #Creating Label and Entry for Event Type, Action required inside Incident Event frame
     self.event_typesinfo= KBACKEND.fetch_event_types()
     self.eventtypedetails= [row[1] for row in self.event_typesinfo]
     Event_type= Label(Incident_Event, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entry= ttk.Combobox(Incident_Event,values=self.eventtypedetails,width=20)
     self.Event_type_entry.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Event_type_entry)
     self.Event_another_entry= Entry(Incident_Event,width=50)
     self.Event_another_entry.grid(row=0,column=2,sticky="w")
     self.attach_context_menu(self.Event_another_entry)

     current_user=getuser()
     Action_required= Label(Incident_Event, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entry= ttk.Entry(Incident_Event,width=30)
     self.Action_required_entry.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entry.insert(0, current_user)
     self.Action_required_entry.state(['disabled'])
     self.attach_context_menu(self.Action_required_entry)
     
     Owner= Label(Incident_Event, text="Owner")
     Owner.grid(row=2,column=0,padx=5,pady=5)
     self.Owner_entry= ttk.Entry(Incident_Event,width=30)
     self.Owner_entry.grid(row=2,column=1,sticky="w",padx=5,pady=5)
     self.Owner_entry.insert(0,current_user)
     self.Owner_entry.state(['disabled'])
     self.attach_context_menu(self.Owner_entry)

     Created= LabelFrame(self.icon3_window,bd=3, relief=tk.RIDGE,text="Created")
     Created.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Created.place(x=610,y=30,width=180,height=120)
     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Created, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entry= DateEntry(Created, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entry.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_created_Entry)
     #Time
     Time_created= Label(Created,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entry= Entry(Created,width=9)
     current_time = datetime.now().strftime("%H:%M")
     self.Time_created_entry.grid(row=1,column=1,sticky="w")
     self.Time_created_entry.insert(0, current_time)
     self.attach_context_menu(self.Time_created_entry)


     Event_text=Frame(self.icon3_window,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entry= Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entry.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.attach_context_menu(self.Event_details_entry)



     


     Next_event= LabelFrame(self.icon3_window,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)
     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entry= DateEntry(Next_event, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_nextevent_Entry.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_nextevent_Entry)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entry= Entry(Next_event,width=9)
     self.Time_nextevent_entry.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Time_nextevent_entry)
     

     self.type=KBACKEND.fetch_event_types()
     self.typedetails= [row[1] for row in self.type]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entry= ttk.Combobox(Next_event,values=self.typedetails,width=20)
     self.Type_nextevent_entry.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Type_nextevent_entry)
     self.Event_type_entry.bind("<<ComboboxSelected>>", self.populate_next_event_details)
     self.populate_next_event_details()
     self.Type_another_entry= Entry(Next_event,width=40)
     self.Type_another_entry.grid(row=3,column=2,sticky="w")
     self.attach_context_menu(self.Type_another_entry)

     #defining functionalities for icons in the event details page 
     icon_box = tk.Frame(self.icon3_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

    # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     images = ["icon 21.png","icon 22.png"]
     for idd, path in enumerate(images, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idd: self.event_functionality(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

    def event_functionality(self,index):
        if index == 1:
            self.exit()
        elif index == 2:
            self.save()
    def exit(self):
         self.icon3_window.destroy()

    def save(self):
        
        Incident_No= self.Numberentry.get()
        KBACKEND.generate_event_number(Incident_No)
        date_str = self.Date_created_Entry.get()  # Get date as string
        time_str = self.Time_created_entry.get()  # Get time as string

        # Combine date and time strings into a single datetime string
        datetime_str = f"{date_str} {time_str}"

        # Convert the datetime string to a datetime object
        datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

        First_event=self.Event_type_entry.get()
        for row in self.event_typesinfo:    
         if row[1] == First_event:
            First_event_tostore = row[0]
            break
         
        Event_text=self.Event_details_entry.get("1.0", tk.END)
        second_event= self.Type_nextevent_entry.get()
        for row in self.type:    
         if row[1] == second_event:
            Second_event_tostore = row[0]
            break
        datee_str= self.Date_nextevent_Entry.get()
        timee_str=self.Time_nextevent_entry.get()
         # Combine date and time strings into a single datetime string
        datetime_strr = f"{datee_str} {timee_str}"
        # Convert the datetime string to a datetime object
        datetime_objj = datetime.strptime(datetime_strr, "%d/%m/%Y %H:%M")
        Created_by= self.Action_required_entry.get()
        Owner=self.Owner_entry.get()
        KBACKEND.store_event_details(Incident_No,datetime_obj,First_event_tostore,Event_text
                                     ,Second_event_tostore,datetime_objj,Created_by,Owner)
        getting_ino= KBACKEND.giving_i_no_to_events()
        if getting_ino:
           for incident_details in getting_ino:
              incident_no= incident_details.get("I_Number")
              if incident_no is not None:
               last_incievent= KBACKEND.retrievevents(incident_no)
               if last_incievent:
                for incidents in last_incievent:
                 print("Processing incident:", incidents)
       
                incident_date = incidents.get("Incident Date")
                Customer=incidents.get("Customer")
                registration = incidents.get("Registration")
                I_no=incidents.get("Incident No")
                Status=incidents.get("Status")
                Category=incidents.get("Category")
                loca=incidents.get("Location")
                Charg=incidents.get("Charge")
                Locat= incidents.get("Locationn")
                Owner=incidents.get("Owner")
                Next_Event_DT=incidents.get("Next_Event_DT")
                if Next_Event_DT is not None:
                 Next_Event_Date = Next_Event_DT.date()
                 Next_Event_Time = Next_Event_DT.time()
                else:
                 Next_Event_Date = None  # or a default value
                 Next_Event_Time = None
        # Insert the incident into Kerride_table
                 self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locat, registration,I_no,Category,loca,Charg,Status,Owner,Next_Event_Date,Next_Event_Time))
        self.clear_filters()
       
        
        
              
              
        event_details= KBACKEND.fetch_all_events(Incident_No)
        self.events_tree.delete(*self.events_tree.get_children())
        
       
        if event_details:
          for event in event_details:
             Event_created= event.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= event.get('Notes')
             Last_updated= event.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= event.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= event.get('Event_Description')
             Next_Event_Description= event.get('Next_Event_Description')
             Created= event.get('Created_By')
             Own= event.get('Owner')


             self.events_tree.insert("", "end", values=(Created_date,Created_time,Created,Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,Own,Follow_up_date,follow_up_time,Own,Next_Event_Description))
             
             self.events_tree.bind("<<TreeviewSelect>>", self.on_roww_selected)
        self.populate_eventstree_table()

    def on_roww_selected(self,event):
        selected_item = self.events_tree.selection()
        
        if selected_item:
         # Extract the index of the selected item
         item_index = self.events_tree.index(selected_item[0])

         # Event number is the index + 1 (since event numbers start from 1)
         event_no = item_index + 1

         # Get the incident number from the entry
         incident_no=self.Numberentry.get()

         fetch_event_detailsthree= KBACKEND.fetch_data_for_eventthree(incident_no,event_no)

         self.open_eventspagethree_with_clickedrow(fetch_event_detailsthree)        
        
    def open_eventspagethree_with_clickedrow(self,fetch_event_detailsthree):
     
     self.event_windows= tk.Toplevel(self.root)
     self.event_windows.title("Event Detail Form")
     self.event_windows.geometry("800x600") 
     self.event_windows.resizable(False,False)

     Incident_Eventt= Frame(self.event_windows, bd=3, relief=tk.RIDGE)
     Incident_Eventt.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Eventt.place(x=0,y=30,width=600,height=100)

     self.eventsinfothree= KBACKEND.fetch_event_types()
     self.eventtypesinformationthree= [row[1] for row in self.eventsinfothree]
     Event_type= Label(Incident_Eventt, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entryythree= ttk.Combobox(Incident_Eventt,values=self.eventtypesinformationthree,width=20)
     self.Event_type_entryythree.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.Event_type_valuethree= fetch_event_detailsthree.get("Event_Type")
     self.Event_type_entryythree.set(self.Event_type_valuethree if self.Event_type_valuethree is not None else"")
     self.Event_type_entryythree.state(['disabled'])
     self.attach_context_menu(self.Event_type_entryythree)

     self.Event_another_entryythree= Entry(Incident_Eventt,width=50,state='disabled')
     self.Event_another_entryythree.grid(row=0,column=2,sticky="w")
     self.attach_context_menu(self.Event_another_entryythree)

     
     Action_required= Label(Incident_Eventt, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entryythree= ttk.Entry(Incident_Eventt,width=30)
     self.Action_required_entryythree.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entryyvaluethree=fetch_event_detailsthree.get("Createdby")
     self.Action_required_entryythree.insert(0,self.Action_required_entryyvaluethree if self.Action_required_entryyvaluethree
                                        is not None else"")
     self.Action_required_entryythree.state(['disabled'])
     self.attach_context_menu(self.Action_required_entryythree)
     
     Owner= Label(Incident_Eventt, text="Owner")
     Owner.grid(row=2,column=0,padx=5,pady=5)
     self.Owner_entryythree= ttk.Entry(Incident_Eventt,width=30)
     self.Owner_entryythree.grid(row=2,column=1,sticky="w",padx=5,pady=5)
     self.Ownerentryyvaluethree= fetch_event_detailsthree.get("Owner")
     self.Owner_entryythree.insert(0,self.Ownerentryyvaluethree if self.Ownerentryyvaluethree is not None else"")
     self.Owner_entryythree.state(['disabled'])
     self.attach_context_menu(self.Owner_entryythree)

     Created= LabelFrame(self.event_windows,bd=3, relief=tk.RIDGE,text="Created")
     Created.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Created.place(x=610,y=30,width=180,height=120)

     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Created, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entryythree= DateEntry(Created, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entryythree.grid(row=0, column=1,sticky='w')
     self.Date_created_Entryyvaluethree= fetch_event_detailsthree.get("Createddate")
     self.Date_created_datethree= self.Date_created_Entryyvaluethree.date()
     self.Date_created_Entryythree.set_date(self.Date_created_datethree if self.Date_created_datethree is not None else"")
     self.Date_created_Entryythree.state(['disabled'])
     self.attach_context_menu(self.Date_created_Entryythree)
     #Time
     Time_created= Label(Created,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entryythree= ttk.Entry(Created,width=9)
     self.Time_created_entryythree.grid(row=1,column=1,sticky="w")
     self.Time_created_entryyvaluethree= fetch_event_detailsthree.get("Createddate")
     self.Time_created_timethree=self.Time_created_entryyvaluethree.time()
     self.Time_created_entryythree.insert(0,self.Time_created_timethree if self.Time_created_timethree is not None else"")
     self.Time_created_entryythree.state(['disabled'])
     self.attach_context_menu(self.Time_created_entryythree)
     


     Event_text=Frame(self.event_windows,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entryythree= tk.Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entryythree.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.Event_detailsvaluethree= fetch_event_detailsthree.get("Eventtext")
     self.Event_details_entryythree.insert("1.0",self.Event_detailsvaluethree if self.Event_detailsvaluethree is not None else"")
     self.Event_details_entryythree['state'] = 'disabled'
     self.attach_context_menu(self.Event_details_entryythree)

     

     


     Next_event= LabelFrame(self.event_windows,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)

     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entryythree= DateEntry(Next_event, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_nextevent_Entryythree.grid(row=0, column=1,sticky='w')
     self.Date_nextevent_Entryyvaluethree=fetch_event_detailsthree.get("Nexteventdate")
     self.Date_nextevent_datethree= self.Date_nextevent_Entryyvaluethree.date()
     self.Date_nextevent_Entryythree.set_date(self.Date_nextevent_datethree if self.Date_nextevent_datethree is not None else"")
     self.Date_nextevent_Entryythree.state(['disabled'])
     self.attach_context_menu(self.Date_nextevent_Entryythree)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entryythree= Entry(Next_event,width=9)
     self.Time_nextevent_entryythree.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Time_nextevent_entryyvaluethree= fetch_event_detailsthree.get("Nexteventdate")
     self.Time_nextevent_timethree= self.Time_nextevent_entryyvaluethree.time()
     self.Time_nextevent_entryythree.insert(0,self.Time_nextevent_timethree if self.Time_nextevent_timethree is not None else"")
     self.Time_nextevent_entryythree['state'] = 'disabled'
     self.attach_context_menu(self.Time_nextevent_entryythree)


     self.typethree=KBACKEND.fetch_event_types()
     self.typedetailsthree= [row[1] for row in self.typethree]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entryythree= ttk.Combobox(Next_event,values=self.typedetailsthree,width=20)
     self.Type_nextevent_entryythree.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.Typenextevent_valuethree= fetch_event_detailsthree.get("Nexteventtype")
     self.Type_nextevent_entryythree.state(['disabled'])
     self.Type_nextevent_entryythree.set(self.Typenextevent_valuethree if self.Typenextevent_valuethree is not None else"")
     self.attach_context_menu(self.Type_nextevent_entryythree)
     
    
     self.Type_another_entryythree= ttk.Entry(Next_event,width=40)
     self.Type_another_entryythree.grid(row=3,column=2,sticky="w")
     self.Type_another_entryythree.state(['disabled'])
     self.attach_context_menu(self.Type_another_entryythree)

     
    




       

    #defining functionalities for the icons in the second page 
    def open_icon_windowsecond(self,index):
        if index == 2:
            self.open_next_window()
        elif index == 1:
            self.close_the_second_window()
        elif index==3:
            self.create_event_list() 
        elif index==4:
            self.create_costandpurchaseorders()
    
         
        
    # Define a function to populate Kerride_table with all incidents from the database
    def populate_kerride_table(self,filter_criteria=None,filter_type=None):
     red_rows = []
     fuchsia_rows = []
     dark_green_rows = []
     black_rows = []
     green_rows = []
     blue_rows = []
     dark_grey_rows = []
     violet_rows=[]

     red_count = 0
     fuchsia_count = 0
     dark_green_count = 0
     black_count = 0
     green_count = 0
     blue_count = 0
     dark_grey_count = 0
     violet_count = 0
     
     self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())
    
     all_incidents = KBACKEND.retrieve_all_incidents()

     if filter_criteria is None:
            filter_criteria = self.get_filter_criteria()
     if all_incidents:
        for incident in all_incidents: 
         incident_datetime_s = incident.get("Incident Date")
         # Split the datetime string at the space character to extract the date part
         date_part = incident_datetime_s.date()
         registration = incident.get("Registration")
         Customer=incident.get("Customer")
         I_no=incident.get("Incident No")
         Status=incident.get("Status")
         Cat=incident.get("Category")
         loc=incident.get("Location")
         Char=incident.get("Charge")
         location=incident.get("Locationn")
         Owner= incident.get("Owner")
         Creator=incident.get("Creator")
         Next_Event_Datetime=incident.get("Next_Event_Date")
         
         if Next_Event_Datetime is not None:
          Next_Event_Date = Next_Event_Datetime.date()
          Next_Event_Time = Next_Event_Datetime.time()
          time_difference = Next_Event_Datetime - datetime.now()

         else:
          Next_Event_Date = None  # or a default value
          Next_Event_Time = None  # or a default value
          #time_difference=None
          
          
         row_data = (incident_datetime_s, Customer, location, registration, I_no, Cat, loc, Char, Status, Owner, Creator, Next_Event_Date, Next_Event_Time)

        
         # Filter logic
         if self.passes_filter(incident, filter_criteria):
          if Next_Event_Datetime is None:
            #tag = "Violet"
            violet_rows.append(row_data)
          elif Next_Event_Datetime and Next_Event_Datetime < datetime.now() and Status.lower() != 'x':
             #tag = "red"
             red_rows.append(row_data)
          elif time_difference.total_seconds() <= 1800 and Status.lower() != 'x':  # 30 minutes ago
            #tag = "Fuchsia"
            fuchsia_rows.append(row_data)
          elif -1800 <= time_difference.total_seconds() <= 3600 and Status.lower() != 'x':  # Between 30 minutes and 1 hour
            #tag = "Dark Green"
            dark_green_rows.append(row_data)
          elif 3600 <= time_difference.total_seconds() <= 14400 and Status.lower() != 'x':  # Between 1 and 4 hours
            #tag = "Black"
            black_rows.append(row_data)
          elif 14400 <= time_difference.total_seconds() <= 86400 and Status.lower() != 'x': # Between 4 hours and 1 day
            #tag = "Green"
            green_rows.append(row_data)
          elif time_difference.total_seconds() >= 86400 and Status.lower() != 'x':  # More than 1 day
            #tag = "Blue"
            blue_rows.append(row_data)
          #else:
            #tag = "black"  # Default color
          if Status.lower() == 'x':
            #tag = "Dark Grey"
            dark_grey_rows.append(row_data)

        for row_data in red_rows:
         red_count += 1
        for row_data in fuchsia_rows:
         fuchsia_count += 1
        for row_data in dark_green_rows:
         dark_green_count += 1
        for row_data in black_rows:
         black_count += 1
        for row_data in green_rows:
         green_count += 1
        for row_data in blue_rows:
         blue_count += 1
        for row_data in dark_grey_rows:
         dark_grey_count += 1
        for row_data in violet_rows:
         violet_count += 1
        
        if filter_type is None:
            # Show all rows
            for row_data in red_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("red",))
            for row_data in fuchsia_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Fuchsia",))
            for row_data in dark_green_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Dark Green",))
            for row_data in black_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Black",))
            for row_data in green_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Green",))
            for row_data in blue_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Blue",))
            for row_data in dark_grey_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Dark Grey",))
            for row_data in violet_rows:
                self.root.Kerride_table.insert("", "end", values=row_data, tags=("Violet",))
        else:
            # Show only filtered rows
            if filter_type == "overdue":
                for row_data in red_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("red",))
                    
            elif filter_type == "half_hour":
                for row_data in fuchsia_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Fuchsia",))
            elif filter_type == "one_hour":
                for row_data in dark_green_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Dark Green",))
            elif filter_type == "four_hours":
                for row_data in black_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Black",))
            elif filter_type == "one_day":
                for row_data in green_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Green",))
            elif filter_type == "over_one_day":
                for row_data in blue_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Blue",))
            elif filter_type == "closed":
                for row_data in dark_grey_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Dark Grey",))
            elif filter_type == "no_event":
                for row_data in violet_rows:
                    self.root.Kerride_table.insert("", "end", values=row_data, tags=("Violet",))

     bold_font = font.Font(size=10,weight="bold")
     self.root.Kerride_table.tag_configure('red', background='white', foreground='red',font=bold_font)
     self.root.Kerride_table.tag_configure('Fuchsia', background='white', foreground='Fuchsia',font=bold_font)
     self.root.Kerride_table.tag_configure('Dark Green', background='white', foreground='Dark Green',font=bold_font)
     self.root.Kerride_table.tag_configure('Black', background='white', foreground='Black',font=bold_font)
     self.root.Kerride_table.tag_configure('Green', background='white', foreground='Green',font=bold_font)
     self.root.Kerride_table.tag_configure('Blue', background='white', foreground='Blue',font=bold_font)
     self.root.Kerride_table.tag_configure('Dark Grey', background='white', foreground='Dark Grey',font=bold_font)
     self.root.Kerride_table.tag_configure('Violet', background='white', foreground='Violet',font=bold_font)
     
     self.entry_red_count.config(state='normal')
     self.entry_red_count.delete(0, 'end')
     self.entry_red_count.insert('end', str(red_count))
     self.entry_red_count.config(state='disabled')

     self.entry_fuchsia_count.config(state='normal')
     self.entry_fuchsia_count.delete(0, 'end')
     self.entry_fuchsia_count.insert('end', str(fuchsia_count))
     self.entry_fuchsia_count.config(state='disabled')

     self.entry_dark_green_count.config(state='normal')
     self.entry_dark_green_count.delete(0, 'end')
     self.entry_dark_green_count.insert('end', str(dark_green_count))
     self.entry_dark_green_count.config(state='disabled')

     self.entry_black_count.config(state='normal')
     self.entry_black_count.delete(0, 'end')
     self.entry_black_count.insert('end', str(black_count))
     self.entry_black_count.config(state='disabled')

     self.entry_green_count.config(state='normal')
     self.entry_green_count.delete(0, 'end')
     self.entry_green_count.insert('end', str(green_count))
     self.entry_green_count.config(state='disabled')

     self.entry_blue_count.config(state='normal')
     self.entry_blue_count.delete(0, 'end')
     self.entry_blue_count.insert('end', str(blue_count))
     self.entry_blue_count.config(state='disabled')

     self.entry_dark_grey_count.config(state='normal')
     self.entry_dark_grey_count.delete(0, 'end')
     self.entry_dark_grey_count.insert('end', str(dark_grey_count))
     self.entry_dark_grey_count.config(state='disabled')

     self.entry_violet_count.config(state='normal')
     self.entry_violet_count.delete(0, 'end')
     self.entry_violet_count.insert('end', str(violet_count))
     self.entry_violet_count.config(state='disabled')
     return 
     #else:
      #print("No incidents found in the database.")
     
         
    def get_filter_criteria(self):
         return {
            "Registration": self.Regtext1.get(),
            "Customer": self.custext2.get(),
            "Owner": self.text3.get(),
            "Creator": self.text4.get(),
            "Category": self.text5.get(),
            "Location": self.I_location.get(),
            "Charge": self.I_charge.get(),
            "Incident Date": self.text6.get_date() if self.text6.get() else None,
            "Status": self.text7.get(),
            "Closed": self.is_closed.get(),
            "Locations": self.text12.get(),
            "I_Number": self.text13.get()
        }
    def passes_filter(self, incident, filter_criteria):
        incident_registration = incident.get("Registration", "")
        if filter_criteria["Registration"] and filter_criteria["Registration"].lower() not in (incident_registration.lower() if incident_registration else ""):
            return False

        incident_customer = incident.get("Customer", "")
        if filter_criteria["Customer"] and filter_criteria["Customer"].lower() not in (incident_customer.lower() if incident_customer else ""):
         return False

        incident_owner = incident.get("Owner", "")
        if filter_criteria["Owner"] and filter_criteria["Owner"].lower() not in (incident_owner.lower() if incident_owner else ""):
         return False

        incident_creator = incident.get("Creator", "")
        if filter_criteria["Creator"] and filter_criteria["Creator"].lower() not in (incident_creator.lower() if incident_creator else ""):
         return False

        incident_category = incident.get("Cat_Desc", "")
        if filter_criteria["Category"] and filter_criteria["Category"].lower() not in (incident_category.lower() if incident_category else ""):
         return False

        incident_location = incident.get("Loc_Desc", "")
        if filter_criteria["Location"] and filter_criteria["Location"].lower() not in (incident_location.lower() if incident_location else ""):
         return False

        incident_charge = incident.get("Char_Desc", "")
        if filter_criteria["Charge"] and filter_criteria["Charge"].lower() not in (incident_charge.lower() if incident_charge else ""):
         return False

        incident_date = incident.get("Incident Date")
        if filter_criteria["Incident Date"] and filter_criteria["Incident Date"] != (incident_date.date() if incident_date else None):
         return False

        incident_status = incident.get("Status_Desc", "")
        if filter_criteria["Status"] and filter_criteria["Status"].lower() not in (incident_status.lower() if incident_status else ""):
         return False

        if filter_criteria["Closed"] and not (incident_status.lower() == "closed" if incident_status else False):
         print("Filtered out due to 'Closed' checkbox")
         return False

        incident_locationn = incident.get("Locationn", "")
        if filter_criteria["Locations"] and filter_criteria["Locations"].lower() not in (incident_locationn.lower() if incident_locationn else ""):
         return False

        incident_number = incident.get("Incident No")
        if filter_criteria["I_Number"] and filter_criteria["I_Number"].lower() not in (str(incident_number).lower() if incident_number else ""):
         return False


        return True 
    def filter_kerride_table(self, event=None):
        self.populate_kerride_table()
    
   
    def clear_filters(self):
     # Clear all filter inputs
     self.Regtext1.delete(0, "end")
     self.custext2.delete(0, "end")
     self.text3.delete(0, "end")
     self.text4.delete(0, "end")
     self.text5.set('')
     self.I_location.set('')
     self.I_charge.set('')
     self.text6.delete(0, "end")
     self.text7.delete(0, "end")
     self.text12.delete(0, "end")
     self.text13.delete(0, "end")
     self.is_closed.set(0)

     # Repopulate table with all data
     self.populate_kerride_table()
    
    
    def open_next_window(self):
     reg_no = self.text1.get()
     I_number=self.Numberentry.get()
     driver_name = self.Driverentry.get()
     drivertel=self.Driverphone.get()
     created= self.Time.get()
     # Getting the selected date from the DateEntry widget
     selected_date = self.datee.get_date()
    
    # Getting the current time
     current_time_str = self.modifiedtime.get()

     current_time = datetime.strptime(current_time_str, "%H:%M").time()
    
    # Combining selected date and current time into a datetime object
     combined_datetime = datetime.combine(selected_date, current_time)
    
     contact_method= self.Contact_Method_Entry.get()
     if contact_method is None or contact_method == "":
      messagebox.showerror("Error", " 'Contact Method' requires a value.")
     else:
         for row in self.contactmeth:
          if row[1] == contact_method:
            contact_methodd = row[0]
            break
     
     
     
     
     contactname=self.Contact_Name_Entry.get()
     if not contactname:
        messagebox.showerror("Error", "Contact Name is an Mandatory field")
     contacttel=self.Contact_Tel_Entry.get()
     contactemail=self.Contact_Email_Entry.get()
     if contact_method == "Telephone" and (not contacttel):
            messagebox.showerror("Error", "Telephone is required for this incident.")
     elif contact_method=="Email" and (not contactemail):
          messagebox.showerror("Error", "Email is required for this incident.")
     Defect_loc= self.locaentry.get("1.0", tk.END)
     faultdesc=self.Faultentry.get("1.0", tk.END)
     cat_selected = self.CatEntry.get()
     if cat_selected is None or cat_selected == "":
      messagebox.showerror("Error", "'Category' requires a value.")
     else:
        for row in self.Catdetails:
         if row[1] == cat_selected:
            cat_value_to_store = row[0]
            break

     lol = self.LolEntry.get()
     if lol is None or lol == "":
      messagebox.showerror("Error", "'Location' requires a value.")
     else:
        for row in self.Locdetils:
         if row[1] == lol:
            lol_value_to_store = row[0]
            break
     if lol == "Roadside" and (not driver_name or not drivertel):
            messagebox.showerror("Error", "Driver name and phone are required for Roadside incidents.")
     
     charge = self.Chargeentry.get()
     if charge is None or charge == "":
      messagebox.showerror("Error", "'Recharge' requires a value.")
     else:
        for row in self.Chardetails:
         if row[1] == charge:
            char_value_to_store = row[0]
            break

     status = self.StatussEntry.get()
     if status is None or status == "":
      messagebox.showerror("Error", "'Status' requires a value.")
     else:
      for row in self.statrows:
        if row[1] == status:
            stat_value_store = row[0]
            break

     odo= self.Odo.get()
     attendance=self.attendance_var.get()

     Deferred_date = self.Deferred_To.get()

     Deferred_time=self.Deferred_Time.get()
    
    # Getting the current time
     datetime_str = f"{Deferred_date} {Deferred_time}"

    # Convert the datetime string to a datetime object
     combined_deferred = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")
    
    # Combining selected date and current time into a datetime object
     what3=self.whatwordsentry.get()

     vehicle_loaded= self.Vehicle_loaded_var.get()

     fleet= self.Fleet_entry.get()

     makemodel=self.text2.get()
     
     custid=self.Customer_Identry.get()
     custname=self.Cust_Name_Entry.get()
     contractno=self.Contract_No_Entry.get()
     locat= self.location_1.get()
     depo= self.Depotentry.get()
     defectno=self.Customer_defno_Entry.get()
     supplier_no= self.nameentry.get()
     customer_name=self.Cust_Name_Entry.get()
     depot_name=self.location_2.get()


     KBACKEND.store_registration(reg_no, I_number, driver_name,created,combined_datetime,contact_methodd,contactname,
                                 contacttel,contactemail,drivertel,Defect_loc,faultdesc,cat_value_to_store,lol_value_to_store,
                                 char_value_to_store,stat_value_store,odo,attendance,combined_deferred,what3,fleet,custid,contractno,locat,defectno,supplier_no,vehicle_loaded,
                                 customer_name,depot_name)
    
     last_incident = KBACKEND.retrieve_last_incident()
     print("last_incident:", last_incident)
     

     ## Clear existing data from Kerride_table
     self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())
     
     if last_incident:
        for incidents in last_incident:
         print("Processing incident:", incidents)
        # Retrieve attribute values for each incident
         #print("Last incident data:", last_incident)
         incident_date = incidents.get("Incident Date")
         Customer=incidents.get("Customer")
         registration = incidents.get("Registration")
         I_no=incidents.get("Incident No")
         Status=incidents.get("Status")
         Category=incidents.get("Category")
         loca=incidents.get("Location")
         Charg=incidents.get("Charge")
         Locat= incidents.get("Locationn")
         Owner=incidents.get("Owner")
         Next_Event_DT=incidents.get("Next_Event_DT")
         if Next_Event_DT is not None:
          Next_Event_Date = Next_Event_DT.date()
          Next_Event_Time = Next_Event_DT.time()
         else:
          Next_Event_Date = None  # or a default value
          Next_Event_Time = None
         


        # Insert the incident into Kerride_table
         self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locat, registration,I_no,Category,loca,Charg,Status,Owner,Next_Event_Date,Next_Event_Time))
        self.clear_filters()
    def populate_location_description(self, event=None):
        selected_location = self.location_1.get()
        rows = KBACKEND.fetch_locations_and_descriptions()
        for row in rows:
            if row[0] == selected_location:
                self.location_2.delete(0, tk.END)
                self.location_2.insert(0, row[1])
                break
    def populate_supplier_details(self,event=None):
        selected_supplier= self.Contactentry.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.nameentry.delete(0,tk.END)
              self.Phoneentry.delete(0,tk.END)
              self.nameentry.insert(0,row[0])
              self.Phoneentry.insert(0,row[2])

    def populate_eventstree_table(self):
      self.events_tree.delete(*self.events_tree.get_children())
      Incident_No=self.Numberentry.get()
      event_details= KBACKEND.fetch_all_events_oncemore(Incident_No)
      if event_details:
       for event in event_details:
             Event_created= event.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= event.get('Notes')
             Last_updated= event.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= event.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= event.get('Event_Description')
             Next_Event_Description= event.get('Next_Event_Description')
             Created= event.get('Created_By')
             Own= event.get('Owner')


             self.events_tree.insert("", "end", values=(Created_date,Created_time,Created,Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,Own,Follow_up_date,follow_up_time,Own,Next_Event_Description))
             
             
    
   
    def populate_next_event_details(self, event=None):
     selected_event_type = self.Event_type_entry.get()
    
     # Find the corresponding details for the selected event type
     for row in self.event_typesinfo:
        if row[1] == selected_event_type:
            next_event_id = row[2]
            if next_event_id is None:  # If there is no next_event_id
                # Set Type_nextevent_entry to the selected event type
                self.Type_nextevent_entry.set(selected_event_type)
                # Set Date_nextevent_Entry to the current date
                current_date = datetime.now().strftime("%d/%m/%Y")
                self.Date_nextevent_Entry.set_date(current_date)
                # Set Time_nextevent_entry to the current time
                current_time = datetime.now().strftime("%H:%M")
                self.Time_nextevent_entry.delete(0, 'end')  # Clear previous value
                self.Time_nextevent_entry.insert(0, current_time)
            else:
                # Find the corresponding description for the next_event_id
                for item in self.type:
                    if item[0] == next_event_id:
                        self.Type_nextevent_entry.set(item[1])
                        minutes = item[3]  # Use minutes from item[3]
                        if minutes > 1440:  # If duration exceeds one day
                            # Calculate the number of days and remaining minutes
                            days = minutes // 1440
                            remaining_minutes = minutes % 1440
                            # Calculate the adjusted date
                            next_date = datetime.now() +timedelta(days=days)
                            date_str = next_date.strftime("%d/%m/%Y")
                            # Populate Date_nextevent_Entry
                            self.Date_nextevent_Entry.set_date(date_str)
                            # Get the current time
                            current_time_str = self.Time_created_entry.get()
                            current_time = datetime.strptime(current_time_str, "%H:%M")
                            # Add remaining minutes to current time
                            adjusted_time = current_time + timedelta(minutes=remaining_minutes)
                        else:
                            # Get the current time
                            current_time_str = self.Time_created_entry.get()
                            current_time = datetime.strptime(current_time_str, "%H:%M")
                            # Add minutes to current time
                            adjusted_time = current_time + timedelta(minutes=minutes)
                        # Format adjusted time
                        adjusted_time_str = adjusted_time.strftime("%H:%M")
                        # Populate Time_nextevent_entry
                        self.Time_nextevent_entry.delete(0, 'end')  # Clear previous value
                        self.Time_nextevent_entry.insert(0, adjusted_time_str)
                        break
            break









    


     

    
        
            
    def close_the_second_window(self):
        self.icon1_window.destroy()




#==================================End of Second page except closing the window command================#
    
# Starting the third page which is the Purchase order form 
    

    def create_costandpurchaseorders(self):
        self.open_next_window()
        self.purchasehistory = tk.Toplevel(self.root)
        self.purchasehistory.title("Maintenance Control")
        self.purchasehistory.geometry("800x615")  # Adjust the width and height as needed
        self.purchasehistory.resizable(False, False)

        icon_box = tk.Frame(self.purchasehistory, relief=tk.RIDGE, borderwidth=3)
        icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

        image_paths = ["icon 18.png","icon 19.png"]
        for idcost, path in enumerate(image_paths, start=1):
            image = Image.open(path)
            image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
            photo = ImageTk.PhotoImage(image)
            icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcost: self.initilisecostlinefunctionalities(index))
            icon_button.image = photo
            icon_button.pack(side=tk.LEFT, padx=5, pady=2)

        # Create frames for each page
        self.Historyp = Frame(self.purchasehistory)
        self.Maintenance_Controlp = Frame(self.purchasehistory)

        def show_History():
            self.Maintenance_Controlp.pack_forget()
            self.Historyp.pack(fill="both", expand=True)

        def show_maintenance():
            self.Maintenance_Controlp.pack(fill="both", expand=True)
            self.Historyp.pack_forget()

        show_History()

        # Creating Buttons Frame for second page
        Buttonframe = Frame(self.purchasehistory, relief=tk.RIDGE)
        Buttonframe.place(x=0, y=27, width=780, height=40)

        # Create buttons
        hist_button = tk.Button(Buttonframe, text="History", command=show_History)
        hist_button.pack(side=tk.LEFT, padx=1, pady=2)

        maintain_button = tk.Button(Buttonframe, text="Maintenance Control", command=show_maintenance)
        maintain_button.pack(side=tk.LEFT, padx=1, pady=2)

        dataframe = Label(self.Historyp, bd=3, relief=tk.RIDGE)
        dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
        dataframe.place(x=0, y=29, width=780, height=180) 

        scrollbar_x = ttk.Scrollbar(dataframe, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(dataframe, orient=VERTICAL)

        self.costlinestable = ttk.Treeview(dataframe, column=("Repaired", "Odometer", "Supplier_Name",
                                                             "Incident_Link", "Total_Parts_Cost", 
                                                            "Total_Recharge","Approval"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        self.costlinestable.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.costlinestable.xview)
        scrollbar_y.config(command=self.costlinestable.yview)

        # Set column headings
        self.costlinestable.heading("Repaired", text="Repaired")
        self.costlinestable.heading("Odometer", text="Odometer")
        self.costlinestable.heading("Supplier_Name", text="Supplier_Name")
        self.costlinestable.heading("Incident_Link", text="Incident_Link")
        self.costlinestable.heading("Total_Parts_Cost", text="Total_Parts_Cost")
        self.costlinestable.heading("Total_Recharge", text="Total_Recharge")
        self.costlinestable.heading("Approval", text="Approval")

        # Set Treeview to display column headings only
        self.costlinestable["show"] = "headings"

        # Set column widths
        self.costlinestable.column("Repaired", width=80)
        self.costlinestable.column("Odometer", width=70)
        self.costlinestable.column("Supplier_Name", width=80)
        self.costlinestable.column("Incident_Link", width=90)
        self.costlinestable.column("Total_Parts_Cost", width=90)
        self.costlinestable.column("Total_Recharge", width=90)
        self.costlinestable.column("Approval", width=80)
        
        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.costlinestable.pack(side=LEFT, fill=BOTH, expand=True)
        
        self.populate_top_purchase_order()
        self.costlinestable.bind("<ButtonRelease-1>", self.onclick_for_purchaseorder_table)

        self.Approvalframep = tk.Frame(self.purchasehistory, bd=3, relief=tk.RIDGE)
        self.Approvalframep.place(x=0, y=250, width=780, height=150)

        # Creating frame for the 3 buttons
        self.Approval_Issuep = tk.Frame(self.Approvalframep)
        self.Invoice_Detailsp = tk.Frame(self.Approvalframep)
        self.Misccp = tk.Frame(self.Approvalframep)
        
        # Function to show approval page
        def show_Approval():
            self.Approval_Issuep.place(x=0, y=40, width=780, height=110)
            self.Invoice_Detailsp.place_forget()
            self.Misccp.place_forget()
        
        # Function to show invoice details page
        def show_Invoice_Details():
            self.Approval_Issuep.place_forget()
            self.Invoice_Detailsp.place(x=0, y=40, width=780, height=110)
            self.Misccp.place_forget()
        
        # Function to show misc page
        def show_Miscc():
            self.Approval_Issuep.place_forget()
            self.Invoice_Detailsp.place_forget()
            self.Misccp.place(x=0, y=40, width=780, height=110)
        
        show_Approval()
        
        # Creating Buttons Frame for second page
        Buttonframe = tk.Frame(self.Approvalframep, relief=tk.RIDGE)
        Buttonframe.place(x=0, y=8, width=780, height=30)
        
        # Create buttons
        Approval_button = tk.Button(Buttonframe, text="Approval Issue", command=show_Approval)
        Approval_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        Invoice_details_button = tk.Button(Buttonframe, text="Invoice Details", command=show_Invoice_Details)
        Invoice_details_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        Miscc_button = tk.Button(Buttonframe, text="Misc", command=show_Miscc)
        Miscc_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        # Creating data frame for Approval Issue
        Repairerdataframe = tk.Frame(self.Approval_Issuep, bd=3, relief=tk.RIDGE)
        Repairerdataframe.place(x=0, y=0, width=765, height=100)
        
        # Creating data frame for Invoice Details
        Invoicedataframe = tk.Frame(self.Invoice_Detailsp, bd=3, relief=tk.RIDGE)
        Invoicedataframe.place(x=0, y=0, width=765, height=100)

     
        #Creating a label and combobox entry for Repairer 
        sup=KBACKEND.fetch_supplier_details()
        self.supplierp = [row[1] for row in sup]
        Repairer= Label(Repairerdataframe, text="Supplier Name:")
        Repairer.grid(row=0,column=0,padx=5,pady=5)
        insert_supplier=self.Contactentry.get()
        self.Repairerentryp= ttk.Combobox(Repairerdataframe,values=self.supplierp,width=20)
        self.Repairerentryp.grid(row=0,column=1,sticky="w",padx=5,pady=5)
        self.attach_context_menu(self.Repairerentryp)
        self.Repairerentryp.insert(0,insert_supplier if insert_supplier is not None else"")
        self.Repairerentryp.bind("<KeyRelease>", self.filter_supplier_list_three)
        self.Repairerentryp.bind("<<ComboboxSelected>>", self.populate_supplier_detailsp)
        

      
        #Creating a label and combobox entry for Account
        Account= Label(Repairerdataframe, text="Account:")
        Account.grid(row=0,column=2,padx=5,pady=5)
        self.Accountentryp= ttk.Entry(Repairerdataframe,width=20)
        self.Accountentryp.grid(row=0,column=3,sticky="w",padx=5,pady=5)
        self.attach_context_menu(self.Accountentryp)
        self.populate_supplier_detailsp()

        
        #Creating a Label and Entry for Approval
        Approval_number= KBACKEND.generate_purchase_order_number()
        Approval= Label(Repairerdataframe,text="Approval:")
        Approval.grid(row=0,column=4,padx=5,pady=5)
        self.Approvalentryp= ttk.Entry(Repairerdataframe,width= 20)
        self.Approvalentryp.grid(row=0,column=5,sticky="w",padx=5,pady=3)
        self.Approvalentryp.insert(0,Approval_number)
        self.attach_context_menu(self.Approvalentryp)
        self.Approvalentryp.state(['disabled'])

        #Creating a Label and Entry for Issued:
        Issued = Label(Repairerdataframe, text="Issued:")
        Issued.grid(row=1, column=0,padx=5,pady=5)
        self.Issuedentryp= DateEntry(Repairerdataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.Issuedentryp.grid(row=1, column=1,padx=5,pady=5,sticky='w')
        self.attach_context_menu(self.Issuedentryp)
        
        current_user=getuser()
        Po_created= Label(Repairerdataframe,text="Created_By:")
        Po_created.grid(row=1,column=2,padx=5,pady=5)
        self.Po_createdby= ttk.Entry(Repairerdataframe,width=20)
        self.Po_createdby.grid(row=1,column=3,padx=5,pady=5)
        self.Po_createdby.insert(0,current_user)
        self.Po_createdby.state(['disabled'])
        self.attach_context_menu(self.Po_createdby)

        Fleet_details= self.Fleet_entry.get()
        Fleet_Number=Label(Repairerdataframe, text="Fleet_No:")
        Fleet_Number.grid(row=1,column=4,padx=5,pady=5)
        self.fleetnumbercost= Entry(Repairerdataframe,width=20)
        self.fleetnumbercost.grid(row=1,column=5,padx=5,pady=5)
        self.fleetnumbercost.insert(0,Fleet_details)
        self.attach_context_menu(self.fleetnumbercost)

        #Creating a Label and Entry for Odometer
        Ododetails=self.Odo.get()
        Odometer= Label(Repairerdataframe,text="Odometer:")
        Odometer.grid(row=2,column=0,padx=5,pady=5)
        self.Odometerentryp= ttk.Entry(Repairerdataframe,width= 20)
        self.Odometerentryp.grid(row=2,column=1,padx=5,pady=5,sticky="w")
        self.Odometerentryp.insert(0,Ododetails)
        self.attach_context_menu(self.Odometerentryp)
        self.Odometerentryp.state(['disabled'])

         #Creating a Label and Entry for Repaired:
        Repaired = Label(Repairerdataframe, text="Repaired:")
        Repaired.grid(row=2, column=2,padx=5,pady=5)
        self.Repairedentryp= DateEntry(Repairerdataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.Repairedentryp.grid(row=2, column=3,padx=5,pady=5,sticky='w')
        self.attach_context_menu(self.Repairedentryp)

        Order_Category= Label(Repairerdataframe,text="Order_Category")
        Order_Category.grid(row=2,column=4,padx=5,pady=5,sticky='w')
        self.Order_cat= Entry(Repairerdataframe,width=20)
        self.Order_cat.grid(row=2,column=5,padx=5,pady=5,sticky='w')
        self.attach_context_menu(self.Order_cat)

        #Creating fields for the Invoice details dataframe

        Customer_Po= Label(Invoicedataframe,text="Customer Po:")
        Customer_Po.grid(row=0,column=0,padx=5,pady=5,sticky='w')
        self.Customer_Ponum= Entry(Invoicedataframe,width=20)
        self.Customer_Ponum.grid(row=0,column=1,padx=5,pady=5,sticky='w')
        self.attach_context_menu(self.Customer_Ponum)

        kofax= Label(Invoicedataframe,text="Kofax Scan_No:")
        kofax.grid(row=0,column=2,padx=5,pady=5,sticky='w')
        self.Kofaxno= Entry(Invoicedataframe,width=20)
        self.Kofaxno.grid(row=0,column=3,padx=5,pady=5,sticky='w')
        self.attach_context_menu(self.Kofaxno)

        Igloo= Label(Invoicedataframe,text="Igloo Invoice_No:")
        Igloo.grid(row=0,column=4,padx=5,pady=5,sticky='w')
        self.Igloono= Entry(Invoicedataframe,width=20)
        self.Igloono.grid(row=0,column=5,padx=5,pady=5,sticky='w')
        self.attach_context_menu(self.Igloono)

        Table= Frame(self.purchasehistory, bd=3,relief=tk.RIDGE)
        Table.place(x=0,y=400,width=780,height=140)

        scrollbar_x = ttk.Scrollbar(Table, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(Table, orient=VERTICAL)

        self.Table_treep = ttk.Treeview(Table, columns=("Types", "Category","Products", "Parts_Cost", "Labour_Cost", "Total_Cost", "Rech_Parts","Rech_Labour" ,"Total_Recharge"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        
        self.Table_treep.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.Table_treep.xview)
        scrollbar_y.config(command=self.Table_treep.yview)

        

        self.Table_treep.heading("Types", text="Types")
        self.Table_treep.heading("Category", text="Category")
        self.Table_treep.heading("Products", text="Products")
        self.Table_treep.heading("Parts_Cost", text="Parts_Cost")
        self.Table_treep.heading("Labour_Cost", text="Labour_Cost")
        self.Table_treep.heading("Total_Cost",text="Total_Cost")
        self.Table_treep.heading("Rech_Parts", text="Rech_Parts")
        self.Table_treep.heading("Rech_Labour", text="Rech_Labour")
        self.Table_treep.heading("Total_Recharge", text="Total_Recharge")

        self.Table_treep["show"] = "headings"
    
        self.Table_treep.column("Types", width=90)
        self.Table_treep.column("Category", width=90)
        self.Table_treep.column("Products", width=90)
        self.Table_treep.column("Parts_Cost", width=90)
        self.Table_treep.column("Labour_Cost", width=90)
        self.Table_treep.column("Total_Cost", width=90)
        self.Table_treep.column("Rech_Parts", width=90)
        self.Table_treep.column("Rech_Labour", width=90)
        self.Table_treep.column("Total_Recharge", width=90)

        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.Table_treep.pack(fill="both", expand=True)

        self.Table_treep.bind("<<TreeviewSelect>>", self.clicking_the_costlines)
        self.populate_all_the_costlines()

        Addcostline= Frame(self.purchasehistory, bd=3,relief=tk.RIDGE)
        Addcostline.place(x=0,y=540,width=780,height=50)

        Invoice_details_button = tk.Button(Addcostline, text="Add Costline",command=self.add_costline)
        Invoice_details_button.pack(side=tk.RIGHT, padx=1, pady=2)

        #Delete_details_button = tk.Button(Addcostline, text="Delete Costline", command=self.delete_costline)
        #Delete_details_button.pack(side=tk.RIGHT, padx=1, pady=2)

        ##############----###########Creating Entries for Maintainence Control####################

        Maindataframemaintainence= Frame(self.Maintenance_Controlp,bd=3, relief=tk.RIDGE)
        Maindataframemaintainence.pack(side=tk.TOP,padx=8,pady=3, anchor='nw')
        Maindataframemaintainence.place(x=0,y=33,width=780,height=65)

        #Creating Label and Entry for Reg no 
        reg_entry=self.text1.get()
        Reg_no= Label(Maindataframemaintainence,text="Reg_no:")
        Reg_no.grid(row=0,column=0)
        self.Reg_no_entryp = Entry(Maindataframemaintainence, width=30)
        self.Reg_no_entryp.grid(row=0, column=1)
        self.Reg_no_entryp.insert(0,reg_entry)
        self.attach_context_menu(self.Reg_no_entryp)

        #Creating Label and Entry for Vehicle 
        Vehicle= self.text2.get()
        Vehicle_main= Label(Maindataframemaintainence,text= "Vehicle:")
        Vehicle_main.grid(row=0,column=2)
        self.Vehicle_main_entryp= Entry(Maindataframemaintainence,width=35)
        self.Vehicle_main_entryp.grid(row=0,column=3,sticky='w')
        self.Vehicle_main_entryp.insert(0,Vehicle)
        self.attach_context_menu(self.Vehicle_main_entryp)

        #Creating a new dataframe below Main dataframe

        Agreementframe= Frame(self.Maintenance_Controlp,bd=3, relief=tk.RIDGE)
        Agreementframe.pack(side=tk.TOP,padx=8,pady=3, anchor='nw')
        Agreementframe.place(x=0,y=98,width=780,height=70)

        #Create Label and entry for Agreement inside the dataframe
        Contract_number=self.Contract_No_Entry.get()
        Agreement= Label(Agreementframe,text="Agreement:")
        Agreement.grid(row=0,column=0,padx=5,pady=5)
        self.Agreemententryp= Entry(Agreementframe,width=30)
        self.Agreemententryp.grid(row=0,column=1,padx=5,pady=5)
        self.Agreemententryp.insert(0,Contract_number)
        self.attach_context_menu(self.Agreemententryp)

        #Create Label and entry for Customer
        Customer_name= self.Cust_Name_Entry.get()
        Customer= Label(Agreementframe,text="Customer:")
        Customer.grid(row=0,column=2,padx=5,pady=5)
        self.Customerentryp= Entry(Agreementframe,width=50)
        self.Customerentryp.grid(row=0, column=3, padx=5, pady=5)
        self.Customerentryp.insert(0,Customer_name)
        self.attach_context_menu(self.Customerentryp)

    def filter_supplier_list_three(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Repairerentryp.get()
        if current_text == '':
            self.Repairerentryp['values'] = self.supplierp
        else:
            filtered_suppliers = [supplier for supplier in self.supplierp if current_text.lower() in supplier.lower()]
            self.Repairerentryp['values'] = filtered_suppliers


       
    def add_costline(self):
     
     self.save_the_purchase_information()
        
        # Add a new row with default values
     self.costline_window = tk.Toplevel(self.root)
     self.costline_window.title("Cost Line Form")
     self.costline_window.geometry("800x620") 
     self.costline_window.resizable(False,False)

     #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png", "icon24.png"]
     for idcost, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcost: self.costline_icons(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

     dataframe = Frame(self.costline_window, bd=3, relief=tk.RIDGE)
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=35, width=780, height=90)

     Reg_details= self.Reg_no_entryp.get()
     Reg_no = Label(dataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.costlinereg = Entry(dataframe,width=18)
     self.costlinereg.grid(row=0, column=1,padx=10,pady=3)
     self.costlinereg.insert(0,Reg_details)
     self.attach_context_menu(self.costlinereg)
     
     Repairer_name=self.Repairerentryp.get()
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=2)
     self.costlinerep = Entry(dataframe, width=18)
     self.costlinerep.grid(row=0, column=3,padx=10,pady=3)
     self.costlinerep.insert(0,Repairer_name)
     self.attach_context_menu(self.costlinerep)
     
     System_number= self.Approvalentryp.get()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=4)
     self.systemcost = ttk.Entry(dataframe, width=18)
     self.systemcost.grid(row=0, column=5,padx=10,pady=3)
     self.systemcost.insert(0,System_number)
     self.attach_context_menu(self.systemcost)
     self.systemcost.state(['disabled'])
     
     Ododetails=self.Odometerentryp.get()
     Odometerveh = Label(dataframe, text="Vehicle Odometer:")
     Odometerveh.grid(row=1, column=0,pady=5)
     self.odovehcost = ttk.Entry(dataframe, width=18)
     self.odovehcost.grid(row=1, column=1)
     self.odovehcost.insert(0,Ododetails)
     self.attach_context_menu(self.odovehcost)
     self.odovehcost.state(['disabled'])
     
     Repairer_accountdetails= self.Accountentryp.get()
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=1, column=2,pady=5)
     self.repaccocost = Entry(dataframe, width=18)
     self.repaccocost.grid(row=1, column=3)
     self.repaccocost.insert(0,Repairer_accountdetails)
     self.attach_context_menu(self.repaccocost)

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=1,column=4)
     self.Line_createdentry=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentry.grid(row=1,column=5)
     self.Line_createdentry.state(['disabled'])
     
     current_user=getuser()
     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=2,column=0)
     self.Line_createdby= ttk.Entry(dataframe,width=18)
     self.Line_createdby.grid(row=2,column=1)
     self.Line_createdby.insert(0,current_user)
     self.Line_createdby.state(['disabled'])

     Seconddataframe = Frame(self.costline_window, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=125, width=780, height=70)
  
     Reason = Label(Seconddataframe, text="Types:")
     Reason.grid(row=0, column=0)
     Po_Types=KBACKEND.Fetch_PO_Types()
     formatted_data = [f"{row[0]} - {row[1]}" for row in Po_Types]
     self.Reasoncosttypes = ttk.Combobox(Seconddataframe,width=20,values=formatted_data)
     self.Reasoncosttypes.grid(row=0, column=1,padx=15,pady=3)
     self.Reasoncosttypes.bind("<<ComboboxSelected>>", self.update_rtscostcategory)

       # Format data


     RTS = Label(Seconddataframe, text="Category:")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategory = ttk.Combobox(Seconddataframe,width=20)
     self.rtscostcategory.grid(row=0, column=3,padx=10,pady=3)
     self.attach_context_menu(self.rtscostcategory)
     self.rtscostcategory.bind("<<ComboboxSelected>>",self.update_rtscostproducts)
     self.rtscostcategory.bind("<KeyRelease>", self.filter_rts_category)


     category_label = tk.Label(Seconddataframe, text="Products:")
     category_label.grid(row=0, column=4)

     self.category_cost = ttk.Combobox(Seconddataframe, width=20)
     self.category_cost.grid(row=0, column=5, padx=15, pady=3)
     self.category_cost.bind("<KeyRelease>", self.filter_rts_products)
     self.attach_context_menu(self.category_cost)

     
     
     Pfdepot= self.location_2.get()
     rowss = KBACKEND.fetch_locations_and_descriptions()
     self.depotdetails = [row[1] for row in rowss]  # First column values for dropdown
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscost = ttk.Combobox(Seconddataframe, width=20,values=self.depotdetails)
     self.analysiscost.grid(row=1, column=1)
     self.analysiscost.set(Pfdepot)
     self.analysiscost.bind("<<ComboboxSelected>>", self.on_depot_selected)
     self.attach_context_menu(self.analysiscost)



     Thirddataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=195, width=780, height=50)

     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscost = Entry(Thirddataframe,width=13)
     self.Partscost.grid(row=0, column=1,padx=15,pady=3)
     self.Partscost.insert(0,"0.00")
     self.Partscost.bind("<KeyRelease>", self.on_parts_cost_changed)
     self.attach_context_menu(self.Partscost)


     Labour_Hours= Label(Thirddataframe,text="Labour Hours:")
     Labour_Hours.grid(row=0,column=2)
     self.Labour_Hours= Entry(Thirddataframe,width=13)
     self.Labour_Hours.grid(row=0,column=3,padx=15,pady=3)
     self.attach_context_menu(self.Labour_Hours)

     Labour_Rate=Label(Thirddataframe,text="Labour Rate")
     Labour_Rate.grid(row=0,column=4)
     self.Labour_Rate=Entry(Thirddataframe,width=13)
     self.Labour_Rate.grid(row=0,column=5,padx=15, pady=3)
     self.Labour_Rate.insert(0,"0.00")
     self.attach_context_menu(self.Labour_Rate)
                       
     Labour = Label(Thirddataframe, text="Labour Value:")
     Labour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Labourcost = Entry(Thirddataframe,width=13)
     self.Labourcost.grid(row=0, column=7,padx=15,pady=3)
     self.Labourcost.insert(0,"0.00")
     self.attach_context_menu(self.Labourcost)

     fourthdataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Recharge")
     fourthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fourthdataframe.place(x=0, y=245, width=780, height=80)

     Parts_Uplift=Label(fourthdataframe,text="Parts Uplift")
     Parts_Uplift.grid(row=0,column=0)
     self.Parts_Uplift= ttk.Entry(fourthdataframe,width=13)
     self.Parts_Uplift.grid(row=0,column=1,padx=15,pady=3)
     self.Parts_Uplift.bind("<FocusOut>", self.on_parts_cost_changed)
     #self.Parts_Uplift.bind("<Control-z>", self.undo_parts_uplift)
     self.attach_context_menu(self.Parts_Uplift)
     
     self.Parts_Uplift.bind("<Double-1>", self.reset_to_original) 

     RechParts = Label(fourthdataframe, text="Rech.Parts:")
     RechParts.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechcost = Entry(fourthdataframe,width=13)
     self.Rechcost.grid(row=0, column=3,padx=15,pady=3)
     self.Rechcost.insert(0,"0.00")
     self.attach_context_menu(self.Rechcost)
     self.Rechcost.bind("<KeyRelease>", self.on_rechcost_changed)

     Labour_Uplift= Label(fourthdataframe,text="Labour Uplift")
     Labour_Uplift.grid(row=0,column=4)
     self.Labour_Uplift= ttk.Entry(fourthdataframe,width=13)
     self.Labour_Uplift.grid(row=0,column=5,padx=15,pady=3)
     self.Labour_Uplift.bind("<Double-1>", self.reset_labour_uplift)
     #self.Labour_Uplift.bind("<Control-z>", self.undo_labour_uplift)

     Rechlabour = Label(fourthdataframe, text="Rech.labour:")
     Rechlabour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechlabcost = Entry(fourthdataframe,width=11)
     self.Rechlabcost.grid(row=0, column=7,padx=15,pady=3)
     self.Rechlabcost.insert(0,"0.00")
     self.attach_context_menu(self.Rechlabcost)
     #self.Rechlabcost.bind("<FocusOut>", self.on_rechlabcost_changed)

     self.on_depot_selected()

     Rechposted = Label(fourthdataframe, text="Rech.posted:")
     Rechposted.grid(row=1, column=0)
     
     self.rechposted_var = tk.BooleanVar()
     self.rechposted_value = tk.StringVar()
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechpostedcost = Checkbutton(fourthdataframe,variable=self.rechposted_var, command=self.toggle_date_entry)
     self.Rechpostedcost.grid(row=1, column=1,padx=15,pady=3)
     self.attach_context_menu(self.Rechpostedcost)

     Rechposteddate = Label(fourthdataframe, text="Rech.posted date:")
     Rechposteddate.grid(row=1, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechposteddatecost = DateEntry(fourthdataframe, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Rechposteddatecost.grid(row=1, column=3,padx=15,pady=3)
     self.Rechposteddatecost.set_date(datetime.now().strftime("%d/%m/%Y"))  # Set to a valid date first
     self.Rechposteddatecost._top_cal.withdraw()  # Hide the calendar popup initially
     self.clear_date_entry()
     self.attach_context_menu(self.Rechposteddatecost)

     Customerreference = Label(fourthdataframe, text="Customer ref:")
     Customerreference.grid(row=1, column=4)

     self.customerreferencecost = Entry(fourthdataframe,width=11)
     self.customerreferencecost.grid(row=1, column=5,padx=15,pady=3)

     fifthdataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=375, width=780, height=115)

     self.notescost= Text(fifthdataframe,width=80, height='5',wrap='word')
     self.notescost.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.notescost)

     Sixthdataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Recharge text")
     Sixthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Sixthdataframe.place(x=0, y=490, width=780, height=115)

     self.rechargecost= Text(Sixthdataframe,width=80, height='5',wrap='word')
     self.rechargecost.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.rechargecost)

     Seventhdataframe = LabelFrame(self.costline_window, bd=3, relief=tk.RIDGE,text="Customer Specifics")
     Seventhdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seventhdataframe.place(x=0, y=325, width=780, height=50)

     self.Customer_specifics=Entry(Seventhdataframe,width=100,fg="Red")
     self.Customer_specifics.grid(row=0,column=2)

     cust_id=self.Customer_Identry.get()
     result=KBACKEND.check_customer_specific(cust_id)
     if result:
        self.Customer_specifics.delete(0, tk.END)
        self.Customer_specifics.insert(0,result)
     else:
        self.Customer_specifics.delete(0, tk.END)
        self.Customer_specifics.insert(0,"CUSTOMER Does not have SPECAL RECHARGE RATES")
     
     
        
        

    def on_recharge_selected(self, event):
     self.current_selection = self.Chargeentry.get()

    def on_depot_selected(self, event=None):
     if self.current_selection == "RECHARGE":
        self.update_uplift()
        self.check_supplier_conditions()

    def update_uplift(self):
     depot_name = self.analysiscost.get()
     print(f"Depot Name: {depot_name}")
     parts_uplift = KBACKEND.fetch_uplift_forparts(depot_name)
     self.original_uplift_percentage = parts_uplift
     print(f"Parts Uplift: {parts_uplift}")
     self.Parts_Uplift.delete(0, tk.END)
     self.Parts_Uplift.insert(0, f"{parts_uplift}.00%")
           
            
    def on_parts_cost_changed(self, event):
     if self.current_selection == "RECHARGE":
        try:
            parts_cost = float(self.Partscost.get())
            parts_uplift_text = self.Parts_Uplift.get()
            parts_uplift = float(parts_uplift_text.replace('%', ''))
            uplift_amount = parts_cost * (parts_uplift / 100)
            total_cost = parts_cost + uplift_amount
            self.Rechcost.delete(0, tk.END)
            self.Rechcost.insert(0, "{:.2f}".format(total_cost))
            self.original_rechcost = total_cost
        except ValueError:
            pass

    def on_rechcost_changed(self, event):
     if self.current_selection == "RECHARGE":
        try:
            rech_cost = float(self.Rechcost.get())
            parts_cost = float(self.Partscost.get())
            if parts_cost > 0:
                uplift_percentage = ((rech_cost - parts_cost) / parts_cost) * 100
                self.Parts_Uplift.delete(0, tk.END)
                self.Parts_Uplift.insert(0, "{:.2f}%".format(uplift_percentage))
            else:
                Depot_Name = self.analysiscost.get()
                print(f"Depot Name: {Depot_Name}")
                parts_uplift = KBACKEND.fetch_uplift_forparts(Depot_Name)
                self.Parts_Uplift.delete(0, tk.END)
                self.Parts_Uplift.insert(0, f"{parts_uplift}%")
                #self.Parts_Uplift.insert(0, "{:.2f}%".format(parts_uplift))

        except ValueError:
            print("Invalid input for Rechcost or Parts Cost.")
    def reset_to_original(self, event):
     self.Parts_Uplift.delete(0, tk.END)
     self.Parts_Uplift.insert(0, f"{self.original_uplift_percentage}%")
    
     self.Rechcost.delete(0, tk.END)
     self.Rechcost.insert(0, "{:.2f}".format(self.original_rechcost))

     self.Parts_Uplift.icursor(tk.END)
     self.Parts_Uplift.selection_clear()

    def check_supplier_conditions(self):
     supplier_name = self.costlinerep.get()

     if self.current_selection == "RECHARGE" and supplier_name == "Petit Forestier Holding":
        self.handle_pp_holding_scenario()
     elif self.current_selection == "RECHARGE" and supplier_name != "Petit Forestier Holding":
        self.handle_other_supplier_scenario()

    def handle_pp_holding_scenario(self):
     Depot_Name = self.analysiscost.get()
     labour_rate = KBACKEND.fetch_labourrate_forlabours(Depot_Name)
     self.Labour_Rate.delete(0, tk.END)
     self.Labour_Rate.insert(0, "{:.2f}".format(labour_rate))
     self.Labour_Hours.bind("<KeyRelease>", self.calculate_labour_cost_for_pp_holding)
     self.original_labour_uplift_percentage = 0.0
     self.calculate_labour_cost_for_pp_holding()

    def calculate_labour_cost_for_pp_holding(self, event=None):
     try:
        labour_rate = float(self.Labour_Rate.get())
        labour_hours = float(self.Labour_Hours.get())
        labour_cost = labour_rate * labour_hours
        self.Labourcost.delete(0, tk.END)
        self.Labourcost.insert(0, "{:.2f}".format(labour_cost))
        self.Rechlabcost.delete(0, tk.END)
        self.Rechlabcost.insert(0, "{:.2f}".format(labour_cost))
        self.original_rechlabcost = labour_cost 
     except ValueError:
        print("Invalid input for labour rate or hours.")

    def handle_other_supplier_scenario(self):
     Depot_Name=self.analysiscost.get()
     labour_uplift = KBACKEND.fetch_labouruplift_forlabours(Depot_Name)
     self.Labour_Uplift.delete(0, tk.END)
     self.Labour_Uplift.insert(0, "{:.2f}%".format(labour_uplift))
     self.Labour_Rate.bind("<KeyRelease>", self.calculate_labour_cost_with_uplift)
     self.Labour_Hours.bind("<KeyRelease>", self.calculate_labour_cost_with_uplift)
     self.Labour_Uplift.bind("<FocusOut>", self.calculate_labour_cost_with_uplift)
     self.original_labour_uplift_percentage = labour_uplift 
     self.calculate_labour_cost_with_uplift()

    def calculate_labour_cost_with_uplift(self, event=None):
     try:
        labour_rate = float(self.Labour_Rate.get())
        labour_hours = float(self.Labour_Hours.get())
        labour_uplift_text = self.Labour_Uplift.get()
        labour_uplift = float(labour_uplift_text.replace('%', ''))
        labour_cost = labour_rate * labour_hours
        self.Labourcost.delete(0, tk.END)
        self.Labourcost.insert(0, "{:.2f}".format(labour_cost))
        uplift_amount = labour_cost * (labour_uplift / 100)
        rech_lab_cost = labour_cost + uplift_amount
        self.Rechlabcost.delete(0, tk.END)
        self.Rechlabcost.insert(0, "{:.2f}".format(rech_lab_cost))
        self.original_rechlabcost = rech_lab_cost
     except ValueError:
        print("Invalid input for labour rate, hours, or uplift.")

    #def on_rechlabcost_changed(self, event):
        #rech_lab_cost = float(self.Rechlabcost.get())
        #labour_cost = float(self.Labourcost.get())
        
        #if labour_cost > 0:
            # Calculate uplift percentage
            #labour_uplift_percentage = ((rech_lab_cost - labour_cost) / labour_cost) * 100
            
            # Update Labour_Uplift entry
            #self.Labour_Uplift.delete(0, tk.END)
            #self.Labour_Uplift.insert(0, "{:.2f}%".format(labour_uplift_percentage))
        #else:
            # If labour cost is 0 or negative, keep Labour_Uplift as is
            #pass

    #def on_rechlabcost_changed(self, event):
     #if self.current_selection == "RECHARGE":
        #supplier_name = self.costlinerep.get()  # Get the supplier name
        
        #if supplier_name == "Petit Forestier Holding":
            # For "Petit Forestier Holding", just update Rechlabcost without calculating uplift
            #try:
                #rech_lab_cost = float(self.Rechlabcost.get())
                # Save the original Rechlabcost value if it's being updated
                #self.original_rechlabcost = rech_lab_cost
                # Update Rechlabcost with the new value
                #self.Rechlabcost.delete(0, tk.END)
                #self.Rechlabcost.insert(0, "{:.2f}".format(rech_lab_cost))
                
                # Optional: Clear or set Labour_Uplift to 0% if required
                #self.Labour_Uplift.delete(0, tk.END)
                #self.Labour_Uplift.insert(0, "0.00%")
                
            #except ValueError:
                #print("Invalid input for Rechlabcost.")
        
        #else:
            # For other suppliers, calculate uplift based on the new Rechlabcost
            #try:
                #rech_lab_cost = float(self.Rechlabcost.get())
                #labour_cost = float(self.Labourcost.get())
                
                # Calculate uplift percentage if labour cost is greater than 0
                #if labour_cost > 0:
                    #uplift_percentage = ((rech_lab_cost - labour_cost) / labour_cost) * 100
                    # Update Labour_Uplift entry
                    #self.Labour_Uplift.delete(0, tk.END)
                    #elf.Labour_Uplift.insert(0, "{:.2f}%".format(uplift_percentage))
                #else:
                    # Restore original uplift or set it to 0% if invalid
                    #if hasattr(self, 'original_labour_uplift_percentage'):
                        #self.Labour_Uplift.delete(0, tk.END)
                        #self.Labour_Uplift.insert(0, f"{self.original_labour_uplift_percentage}%")
                    #else:
                        #self.Labour_Uplift.delete(0, tk.END)
                        #self.Labour_Uplift.insert(0, "0.00%")
                
            #except ValueError:
                #print("Invalid input for Rechlabcost or Labour Cost.")

    def reset_labour_uplift(self, event):
     if hasattr(self, 'original_labour_uplift_percentage'):
        self.Labour_Uplift.delete(0, tk.END)
        self.Labour_Uplift.insert(0, f"{self.original_labour_uplift_percentage}%")
     self.Rechlabcost.delete(0, tk.END)
     self.Rechlabcost.insert(0, "{:.2f}".format(self.original_rechlabcost))
    
    def undo_parts_uplift(self, event):
        try:
            self.Parts_Uplift.edit_undo()  # Perform the undo operation
        except tk.TclError:
            print("Nothing to undo in Parts_Uplift")

    def undo_labour_uplift(self, event):
        try:
            self.Labour_Uplift.edit_undo()  # Perform the undo operation
        except tk.TclError:
            print("Nothing to undo in Labour_Uplift")
     
     
   
     
     
        
     
    
    def update_rtscostcategory(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.Reasoncosttypes.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        type_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        self.categories = KBACKEND.Fetch_Categories_By_Type(type_id)
        
        # Format data for the dropdown
        self.formatted_categories = [f"{row[1]} - {row[2]}" for row in self.categories]

        # Update rtscostcategory dropdown with the new data
        self.rtscostcategory['values'] = self.formatted_categories
        #if formatted_categories:
            #self.rtscostcategory.current(0) 
    
    def update_rtscostproducts(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.rtscostcategory.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        category_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        self.categories = KBACKEND.Fetch_Products_By_Category(category_id)
        
        # Format data for the dropdown
        self.formatted_categoriespro = [f"{row[1]} - {row[2]}" for row in self.categories]

        # Update rtscostcategory dropdown with the new data
        self.category_cost['values'] = self.formatted_categoriespro
        #if formatted_categories:
            #self.category_cost.current(0) 

    def filter_rts_category(self,event):
       current_text = self.rtscostcategory.get()
       if current_text == '':
            self.rtscostcategory['values'] = self.formatted_categories
       else:
            filtered_category = [category for category in self.formatted_categories if current_text.lower() in category.lower()]
            self.rtscostcategory['values'] = filtered_category

    def filter_rts_products(self,event):
       current_text = self.category_cost.get()
       if current_text == '':
            self.category_cost['values'] = self.formatted_categoriespro
       else:
            filtered_category = [product for product in self.formatted_categoriespro if current_text.lower() in product.lower()]
            self.category_cost['values'] = filtered_category

    def clicking_the_costlines(self,event):
       selected_item = self.Table_treep.selection()
       if selected_item:
         # Extract the index of the selected item
         item_index = self.Table_treep.index(selected_item[0])

         Line_added = item_index + 1

         PO_Number= self.Approvalentryp.get()

         open_costline_details= KBACKEND.open_costlines_page(PO_Number,Line_added)

         self.open_costlinespage_with_clickedrow(open_costline_details)
    
    def open_costlinespage_with_clickedrow(self,open_costline_details):
     self.costline_windowclick = tk.Toplevel(self.root)
     self.costline_windowclick.title("Cost Line Form")
     self.costline_windowclick.geometry("800x620") 
     self.costline_windowclick.resizable(False,False)

      #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_windowclick, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png"]
     for idcost, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcost: self.costline_iconsclick(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)
     
     dataframe = Frame(self.costline_windowclick, bd=3, relief=tk.RIDGE)
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=35, width=780, height=90)

     Reg_details= self.Reg_no_entryp.get()
     Reg_no = Label(dataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.costlineregclick = ttk.Entry(dataframe,width=18)
     self.costlineregclick.grid(row=0, column=1,padx=10,pady=3)
     self.costlineregclick.insert(0,Reg_details)
     self.attach_context_menu(self.costlineregclick)
     self.costlineregclick.state(['disabled'])
     
     Repairer_name=self.Repairerentryp.get()
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=2)
     self.costlinerepclick = ttk.Entry(dataframe, width=18)
     self.costlinerepclick.grid(row=0, column=3,padx=10,pady=3)
     self.costlinerepclick.insert(0,Repairer_name)
     self.attach_context_menu(self.costlinerepclick)
     self.costlinerepclick.state(['disabled'])
     
     System_number= self.Approvalentryp.get()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=4)
     self.systemcostclick = ttk.Entry(dataframe, width=18)
     self.systemcostclick.grid(row=0, column=5,padx=10,pady=3)
     self.systemcostclick.insert(0,System_number)
     self.attach_context_menu(self.systemcostclick)
     self.systemcostclick.state(['disabled'])
     
     Ododetails=self.Odometerentryp.get()
     Odometerveh = Label(dataframe, text="Vehicle Odometer:")
     Odometerveh.grid(row=1, column=0,pady=5)
     self.odovehcostclick = ttk.Entry(dataframe, width=18)
     self.odovehcostclick.grid(row=1, column=1)
     self.odovehcostclick.insert(0,Ododetails)
     self.attach_context_menu(self.odovehcostclick)
     self.odovehcostclick.state(['disabled'])
     
     Repairer_accountdetails= self.Accountentryp.get()
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=1, column=2,pady=5)
     self.repaccocostclick = ttk.Entry(dataframe, width=18)
     self.repaccocostclick.grid(row=1, column=3)
     self.repaccocostclick.insert(0,Repairer_accountdetails)
     self.attach_context_menu(self.repaccocostclick)
     self.repaccocostclick.state(['disabled'])

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=1,column=4)
     self.Line_createdentryclick=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentryclick.grid(row=1,column=5)
     if open_costline_details is not None:
      self.Line_createdentryvalueclick= open_costline_details.get('Line_Added')
     else:
        self.Line_createdentryvalueclick= None
     if self.Line_createdentryvalueclick:
      self.Line_createdentryclick.set_date(self.Line_createdentryvalueclick)
     else:
      self.Line_createdentryclick.set_date(None)

     self.Line_createdentryclick.state(['disabled'])

     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=2,column=0)
     self.Line_createdbyclick= ttk.Entry(dataframe,width=18)
     self.Line_createdbyclick.grid(row=2,column=1)
     if open_costline_details is not None:
        self.Line_createdbyclickvalue= open_costline_details.get('Added_By')
     else:
        self.Line_createdbyclickvalue= None
     self.Line_createdbyclick.insert(0, self.Line_createdbyclickvalue if self.Line_createdbyclickvalue is not None else"")
     self.Line_createdbyclick.state(['disabled'])

     Seconddataframe = Frame(self.costline_windowclick, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=125, width=780, height=70)

     Reason = Label(Seconddataframe, text="Types:")
     Reason.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Reasoncosttypesclick = ttk.Combobox(Seconddataframe,width=20)
     self.Reasoncosttypesclick.grid(row=0, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Reasoncosttypesclickid= open_costline_details.get('Type_ID')
        self.Reasoncosttypesclickdesc= open_costline_details.get('Type_Desc')
        self.reasoncosttypesclickvalue = f"{self.Reasoncosttypesclickid}-{self.Reasoncosttypesclickdesc}" if self.Reasoncosttypesclickid and self.Reasoncosttypesclickdesc else None
     else:
        self.reasoncosttypesclickvalue= None

     self.Reasoncosttypesclick.insert(0,self.reasoncosttypesclickvalue if self.reasoncosttypesclickvalue is not None else"")
     self.attach_context_menu(self.Reasoncosttypesclick)
     self.Reasoncosttypesclick.state(['disabled'])

     RTS = Label(Seconddataframe, text="Category")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategoryclick = ttk.Combobox(Seconddataframe,width=20)
     self.rtscostcategoryclick.grid(row=0, column=3,padx=10,pady=3)
     if open_costline_details is not None:
        self.rtscostcategoryid= open_costline_details.get('Category_ID')
        self.rtscostcategorydesc= open_costline_details.get('Cat_Desc')
        self.rtscostcategoryclickvalue=f"{self.rtscostcategoryid}-{self.rtscostcategorydesc}" if self.rtscostcategoryid and self.rtscostcategorydesc else None
     else:
        self.rtscostcategoryclickvalue= None
     self.rtscostcategoryclick.insert(0,self.rtscostcategoryclickvalue if self.rtscostcategoryclickvalue is not None else"")
     self.attach_context_menu(self.rtscostcategoryclick)
     self.rtscostcategoryclick.state(['disabled'])

     category_label = tk.Label(Seconddataframe, text="Products:")
     category_label.grid(row=0, column=4)
     self.category_productsclick = ttk.Combobox(Seconddataframe, width=20)
     self.category_productsclick.grid(row=0, column=5, padx=15, pady=3)
     if open_costline_details is not None:
      self.costlineproductid=open_costline_details.get('Product_ID')
      self.costlineproductdesc=open_costline_details.get('Product_Desc')
      self.costlineproductsvalue=f"{self.costlineproductid}-{self.costlineproductdesc}" if self.costlineproductid and self.costlineproductdesc else None
     else:
      self.costlineproductsvalue=None
     self.category_productsclick.insert(0,self.costlineproductsvalue if self.costlineproductsvalue is not None else"")
     self.category_productsclick.state(['disabled'])
     
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscostclick = ttk.Entry(Seconddataframe, width=18)
     self.analysiscostclick.grid(row=1, column=1)
     if open_costline_details is not None:
        self.analysiscostclickvalue= open_costline_details.get('Pf_depot')
     else:
        self.analysiscostclickvalue=None
     self.analysiscostclick.insert(0,self.analysiscostclickvalue if self.analysiscostclickvalue is not None else"")
     self.attach_context_menu(self.analysiscostclick)
     self.analysiscostclick.state(['disabled'])

     Thirddataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=195, width=780, height=50)

     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscostclick = ttk.Entry(Thirddataframe,width=13)
     self.Partscostclick.grid(row=0, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Partscostclickvalue= open_costline_details.get('Parts_cost')
     else:
        self.Partscostclickvalue= None
     self.Partscostclick.insert(0,self.Partscostclickvalue if self.Partscostclickvalue is not None else"")
     self.attach_context_menu(self.Partscostclick)
     self.Partscostclick.state(['disabled'])

     Labour_Hours= Label(Thirddataframe,text="Labour Hours:")
     Labour_Hours.grid(row=0,column=2)
     self.Labour_Hoursclick= ttk.Entry(Thirddataframe,width=13)
     self.Labour_Hoursclick.grid(row=0,column=3,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labour_Hoursclickvalue= open_costline_details.get('Labour_Hours')
     else:
        self.Labour_Hoursclickvalue=None
     self.Labour_Hoursclick.insert(0,self.Labour_Hoursclickvalue if self.Labour_Hoursclickvalue is not None else"")
     self.attach_context_menu(self.Labour_Hoursclick)
     self.Labour_Hoursclick.state(['disabled'])

     Labour_Rate=Label(Thirddataframe,text="Labour Rate")
     Labour_Rate.grid(row=0,column=4)
     self.Labour_Rateclick=ttk.Entry(Thirddataframe,width=13)
     self.Labour_Rateclick.grid(row=0,column=5,padx=15, pady=3)
     if open_costline_details is not None:
        self.Labour_Rateclickvalue= open_costline_details.get('Labour_Rate')
     else:
        self.Labour_Rateclickvalue=None
     self.Labour_Rateclick.insert(0,self.Labour_Rateclickvalue if self.Labour_Rateclickvalue is not None else "0.00")
     self.attach_context_menu(self.Labour_Rateclick)
     self.Labour_Rateclick.state(['disabled'])

     Labour = Label(Thirddataframe, text="Labour Value:")
     Labour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Labourcostclick = ttk.Entry(Thirddataframe,width=13)
     self.Labourcostclick.grid(row=0, column=7,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labourcostclickvalue= open_costline_details.get('labour_cost')
     else:
        self.Labourcostclickvalue= None
     self.Labourcostclick.insert(0,self.Labourcostclickvalue if self.Labourcostclickvalue is not None else"")
     self.attach_context_menu(self.Labourcostclick)
     self.Labourcostclick.state(['disabled'])

     fourthdataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Recharge")
     fourthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fourthdataframe.place(x=0, y=245, width=780, height=80)


     Parts_Uplift=Label(fourthdataframe,text="Parts Uplift")
     Parts_Uplift.grid(row=0,column=0)
     self.Parts_Upliftclick= ttk.Entry(fourthdataframe,width=13)
     self.Parts_Upliftclick.grid(row=0,column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Parts_Upliftclickvalue= open_costline_details.get('Parts_Uplift')
     else:
        self.Parts_Upliftclickvalue=None
     self.Parts_Upliftclick.insert(0,self.Parts_Upliftclickvalue if self.Parts_Upliftclickvalue is not None else"")
     self.attach_context_menu(self.Parts_Upliftclick)
     self.Parts_Upliftclick.state(['disabled'])

     RechParts = Label(fourthdataframe, text="Rech.Parts:")
     RechParts.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechcostclick = ttk.Entry(fourthdataframe,width=13)
     self.Rechcostclick.grid(row=0, column=3,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechcostclickvalue= open_costline_details.get('Recharge_parts')
     else:
        self.Rechcostclickvalue= None
     self.Rechcostclick.insert(0,self.Rechcostclickvalue if self.Rechcostclickvalue is not None else"")
     self.attach_context_menu(self.Rechcostclick)
     self.Rechcostclick.state(['disabled'])
     
     Labour_Uplift= Label(fourthdataframe,text="Labour Uplift")
     Labour_Uplift.grid(row=0,column=4)
     self.Labour_Upliftclick= ttk.Entry(fourthdataframe,width=13)
     self.Labour_Upliftclick.grid(row=0,column=5,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labour_Upliftclickvalue=open_costline_details.get('Labour_Uplift')
     else:
        self.Labour_Upliftclickvalue=None
     self.Labour_Upliftclick.insert(0,self.Labour_Upliftclickvalue if self.Labour_Upliftclickvalue is not None else"")
     self.attach_context_menu(self.Labour_Upliftclick)
     self.Labour_Upliftclick.state(['disabled'])

     Rechlabour = Label(fourthdataframe, text="Rech.labour:")
     Rechlabour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechlabcostclick = ttk.Entry(fourthdataframe,width=11)
     self.Rechlabcostclick.grid(row=0, column=7,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechlabcostclickvalue= open_costline_details.get('Recharge_labour')
     else:
        self.Rechlabcostclickvalue= None
     self.Rechlabcostclick.insert(0,self.Rechlabcostclickvalue if self.Rechlabcostclickvalue is not None else"")
     self.attach_context_menu(self.Rechlabcostclick)
     self.Rechlabcostclick.state(['disabled'])

     Rechposted = Label(fourthdataframe, text="Rech.posted:")
     Rechposted.grid(row=1, column=0)
     
     self.rechposted_varclick = tk.BooleanVar()
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechpostedcostclick = ttk.Checkbutton(fourthdataframe,variable=self.rechposted_varclick)
     self.Rechpostedcostclick.grid(row=1, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechpostedcostclickvalue= open_costline_details.get('Recharge_invoiced')
     else:
        self.Rechpostedcostclickvalue= None
     if self.Rechpostedcostclickvalue == 'Y':
        checkbox_checked = True
     else:
         checkbox_checked = False
     self.rechposted_varclick.set(checkbox_checked)
     self.Rechpostedcostclick.state(['disabled'])

     Rechposteddate = Label(fourthdataframe, text="Rech.posted date:")
     Rechposteddate.grid(row=1, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechposteddatecostclick = ttk.Entry(fourthdataframe, width=12)
     self.Rechposteddatecostclick.grid(row=1, column=3,padx=15,pady=3)

     if open_costline_details is not None:
        self.Rechposteddatecostclickvalue= open_costline_details.get('Recharge_posted')
     else:
        self.Rechposteddatecostclickvalue= None


      # Format the date to dd/mm/yyyy
     if self.Rechposteddatecostclickvalue is not None:
      if isinstance(self.Rechposteddatecostclickvalue, datetime):
        # Format the date to dd/mm/yyyy
        formatted_date = self.Rechposteddatecostclickvalue.strftime("%d/%m/%Y")
      else:
        formatted_date = ""  # Handle case where the value is not a datetime object
         
     else:
      formatted_date = ""

     # Insert the formatted date into the Entry widget
     self.Rechposteddatecostclick.insert(0, formatted_date)
     self.Rechposteddatecostclick.state(['disabled'])
     
     #self.Rechposteddatecostclick.insert(0,self.Rechposteddatecostclickvalue if self.Rechposteddatecostclickvalue is not None else"")
     #self.Rechposteddatecostclick.state(['disabled'])

  
     
     Customer_PO= self.Customer_Ponum.get()
     Customerreference = Label(fourthdataframe, text="Customer ref:")
     Customerreference.grid(row=1, column=4)
     self.customerreferencecostclick = ttk.Entry(fourthdataframe,width=11)
     self.customerreferencecostclick.grid(row=1, column=5,padx=15,pady=3)
     self.customerreferencecostclick.insert(0,Customer_PO if Customer_PO is not None else"")
     self.customerreferencecostclick.state(['disabled'])

     fifthdataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=375, width=780, height=115)

     self.notescostclick= tk.Text(fifthdataframe,width=80, height='5',wrap='word')
     self.notescostclick.grid(row=0,column=0,sticky='w',padx=5)
     if open_costline_details is not None:
        self.notescostclickvalue= open_costline_details.get('Notes')
     else:
        self.notescostclickvalue= None
     self.notescostclick.insert("1.0",self.notescostclickvalue if self.notescostclickvalue is not None else"")
     self.attach_context_menu(self.notescostclick)
     self.notescostclick['state']='disabled'

     Sixthdataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Recharge text")
     Sixthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Sixthdataframe.place(x=0, y=490, width=780, height=115)

     self.rechargecostclick= tk.Text(Sixthdataframe,width=80, height='5',wrap='word')
     self.rechargecostclick.grid(row=0,column=0,sticky='w',padx=5)
     if open_costline_details is not None:
        self.rechargecostclickvalue= open_costline_details.get('Recharge_text')
     else:
        self.rechargecostclickvalue= None
     self.rechargecostclick.insert("1.0",self.rechargecostclickvalue if self.rechargecostclickvalue is not None else"")
     self.rechargecostclick['state']='disabled'

     Seventhdataframe = LabelFrame(self.costline_windowclick, bd=3, relief=tk.RIDGE,text="Customer Specifics")
     Seventhdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seventhdataframe.place(x=0, y=325, width=780, height=50)
     
     self.Customer_specificsclick=ttk.Entry(Seventhdataframe,width=100)
     self.Customer_specificsclick.grid(row=0,column=2)

     cust_id=self.Customer_Identry.get()
     result=KBACKEND.check_customer_specific(cust_id)
     if result:
        self.Customer_specificsclick.delete(0, tk.END)
        self.Customer_specificsclick.insert(0,"This Customer had SPECIAL RECHARGE RATES")
     else:
        self.Customer_specificsclick.delete(0, tk.END)
        self.Customer_specificsclick.insert(0,"This Customer did not have SPECAL RECHARGE RATES")
     self.Customer_specificsclick.state(['disabled'])

    def costline_iconsclick(self,index):
       if index==1:
          self.close_the_windowclick()
    
    def close_the_windowclick(self):
       self.costline_windowclick.destroy()
    
    def clear_date_entry(self):
        # Clear the displayed date in the DateEntry widget
        self.Rechposteddatecost.delete(0, "end")
    
    def toggle_date_entry(self):
        if self.rechposted_var.get():
            self.Rechposteddatecost.set_date(datetime.now().strftime("%d/%m/%Y"))
            self.rechposted_value.set("Y")
        else:
           self.clear_date_entry()
           self.rechposted_value.set("N")




    def costline_icons(self,index):
       if index==1:
          self.close_the_costline()
       elif index==2:
          self.save_the_costlines()
    
    def close_the_costline(self):
       self.costline_window.destroy()

    def get_combined_datetime(self):
        if not self.rechposted_var.get():
            return None  # Return None if the checkbutton is not checked
        
        # Proceed with date retrieval and combination
        date = self.Rechposteddatecost.get_date()
        current_time = datetime.now().time()
        combined_datetime = datetime.combine(date, current_time)
        return combined_datetime
    
    def save_the_costlines(self):
       PO_Number=self.systemcost.get()
       KBACKEND.generate_line_number(PO_Number)
       Line_Added= self.Line_createdentry.get_date()
       Time= datetime.now().time()

       bothdateandtime= datetime.combine(Line_Added, Time)
       Added_By=self.Line_createdby.get()
       #RTS_code= self.Reasoncost.get()
       #RTS_Desc=self.rtscost.get()
       Type=self.Reasoncosttypes.get()
       if Type:
          type_id=Type.split(' - ')[0]
       else:
          type_id=None
       Category=self.rtscostcategory.get()
       if Category:
          Category_id= Category.split(' - ')[0]
       else:
          Category_id=None
       Products=self.category_cost.get()
       if Products:
          Product_id=Products.split(' - ')[0]
       else:
          Product_id=None
       PF_Depot=self.analysiscost.get()
       Parts_Cost=self.Partscost.get()
       Labour_Hours=self.Labour_Hours.get()
       Labour_Rate=self.Labour_Rate.get()
       Labour_cost=self.Labourcost.get()
       Parts_Uplift=self.Parts_Uplift.get()
       Labour_Uplift=self.Labour_Uplift.get()
       Recharge_parts=self.Rechcost.get()
       Recharge_cost=self.Rechlabcost.get()
       Recharge_invoiced=self.rechposted_value.get()

       combined_datetime = self.get_combined_datetime()
       Notes=self.notescost.get("1.0", tk.END)
       Recharge_text= self.rechargecost.get("1.0", tk.END)

       KBACKEND.store_cost_lines(PO_Number,bothdateandtime,Added_By,PF_Depot,Parts_Cost,Labour_Hours,Labour_Rate,
                            Labour_cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_cost,Recharge_invoiced,combined_datetime,
                                 Notes,Recharge_text,type_id,Category_id,Product_id)
       
       self.Table_treep.delete(*self.Table_treep.get_children())

       Approval_number= self.Approvalentryp.get()

       Costlines= KBACKEND.populate_costlines(Approval_number)

       if Costlines:
          for incident in Costlines:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel


             self.Table_treep.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
          self.populate_all_the_costlines()
       Insert_purchase= KBACKEND.retrieve_last_purchase_and_populate(Approval_number)

       self.costlinestable.delete(*self.costlinestable.get_children())

       if Insert_purchase:
          for Purchase in Insert_purchase:
            Repaired= Purchase.get("Repaired")
            if Repaired is not None:
             Repaired_date = Repaired.date()
            else:
             print("Repaired is None, cannot access 'date' attribute.")
            Repaired_date = None  # or some default value           
            Odometer=Purchase.get("Odometer")
            Supplier_Name= Purchase.get("Supplier")
            Incident_Link= Purchase.get("Incident_Link")
            Total_Parts=Purchase.get("Total_parts")
            Total_labours=Purchase.get("Total_labours")
            Total_cost= Total_Parts + Total_labours
            Recharge_parts= Purchase.get("Recharge_parts")
            Recharge_labours= Purchase.get("Recharge_labours")
            Total_Recharge= Recharge_parts+ Recharge_labours
            PO_number= Purchase.get("Approval")

            self.costlinestable.insert("", "end", values=(Repaired_date,Odometer,Supplier_Name,Incident_Link,
                                                         Total_cost,Total_Recharge,PO_number))
       self.populate_top_purchase_order()
             
        
      

    
    def populate_supplier_detailsp(self,event=None):
        selected_supplier= self.Repairerentryp.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.Accountentryp.delete(0,tk.END)
              self.Accountentryp.insert(0,row[0])

        


         
    def initilisecostlinefunctionalities(self,index):
       if index==1:
          self.exit_the_purchaseorders()
       if index==2:
          self.save_the_purchase_information()
    
    def exit_the_purchaseorders(self):
       self.purchasehistory.destroy()
    
    def save_the_purchase_information(self):
        PO_Number=self.Approvalentryp.get()
        i_number= self.Numberentry.get()
        # Getting the selected date from the DateEntry widget
        Pocreated_date = self.Issuedentryp.get_date()
    
        # Getting the current time
        current_time = datetime.now().time()
    
        # Combining selected date and current time into a datetime object
        combined_datetime = datetime.combine(Pocreated_date, current_time)

        Created_By= self.Po_createdby.get()

        Supplier_No= self.Accountentryp.get()

        Order_Category= self.Order_cat.get()

        Fleet_No= self.fleetnumbercost.get()

        Odometer= self.Odometerentryp.get()

        Customer_PO= self.Customer_Ponum.get()

       
        Kofax_Scan= self.Kofaxno.get()

        Igloo_invoice=self.Igloono.get()

        Supplier_Name=self.Repairerentryp.get()

        Repaired_Date=self.Repairedentryp.get_date()

        Time= datetime.now().time()

        Repaired_Datetime= datetime.combine(Repaired_Date,Time)

        KBACKEND.store_the_purchase_orderinfo(PO_Number,i_number,combined_datetime,Created_By,Supplier_No,
                                              Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,Supplier_Name,Repaired_Datetime)
    
    def onclick_for_purchaseorder_table(self,event):
       item = self.costlinestable.identify_row(event.y)
       print("Clicked on item:", item)
    
      
    
       # Check if item is valid
       if item:
         # Set focus to the clicked row
         self.costlinestable.focus(item)

       # Get the values from the clicked row
       values = self.costlinestable.item(item, "values")

       

        # Check if the values list has at least 7 elements
       if len(values) > 6:
         approval_number = values[6]
         
       else:
         approval_number = None  # or handle the case appropriately
   
   
       costline_details= KBACKEND.retrieve_costlines_for_approvalnumber(approval_number)
       
       if costline_details:
       
        self.open_costlines_for_purchaseorder_number(costline_details)
       
       else:
        print("NO DETAILS FOUND")
    
    def open_costlines_for_purchaseorder_number(self,costline_details):
        self.tablewindow = tk.Toplevel(self.root)
        self.tablewindow.title("Cost lines for the PO Number")
        self.tablewindow.geometry("800x400") 
        self.tablewindow.resizable(False,False)

        dataframe = Label(self.tablewindow, bd=3, relief=tk.RIDGE)
        dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
        dataframe.place(x=0, y=29, width=780, height=180) 

        scrollbar_x = ttk.Scrollbar(dataframe, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(dataframe, orient=VERTICAL)

        self.Table_treepwindow = ttk.Treeview(dataframe, columns=("Types", "Category","Products", "Parts_Cost", "Labour_Cost", "Total_Cost", "Rech_Parts","Rech_Labour" ,"Total_Recharge"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        
        self.Table_treepwindow.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.Table_treepwindow.xview)
        scrollbar_y.config(command=self.Table_treepwindow.yview)

        

        self.Table_treepwindow.heading("Types", text="Types")
        self.Table_treepwindow.heading("Category", text="Category")
        self.Table_treepwindow.heading("Products", text="Products")
        self.Table_treepwindow.heading("Parts_Cost", text="Parts_Cost")
        self.Table_treepwindow.heading("Labour_Cost", text="Labour_Cost")
        self.Table_treepwindow.heading("Total_Cost",text="Total_Cost")
        self.Table_treepwindow.heading("Rech_Parts", text="Rech_Parts")
        self.Table_treepwindow.heading("Rech_Labour", text="Rech_Labour")
        self.Table_treepwindow.heading("Total_Recharge", text="Total_Recharge")

        self.Table_treepwindow["show"] = "headings"
    
        self.Table_treepwindow.column("Types", width=90)
        self.Table_treepwindow.column("Category", width=90)
        self.Table_treepwindow.column("Products", width=90)
        self.Table_treepwindow.column("Parts_Cost", width=90)
        self.Table_treepwindow.column("Labour_Cost", width=90)
        self.Table_treepwindow.column("Total_Cost", width=90)
        self.Table_treepwindow.column("Rech_Parts", width=90)
        self.Table_treepwindow.column("Rech_Labour", width=90)
        self.Table_treepwindow.column("Total_Recharge", width=90)

        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.Table_treepwindow.pack(fill="both", expand=True)

        self.Table_treepwindow.delete(*self.Table_treepwindow.get_children())
        if costline_details:
         for incident in costline_details:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel

             self.Table_treepwindow.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
        else:
           print("NO DETAILS FOUND")

    def open_costlines_without_incidents(self):
     self.costline_windowwithoutincident = tk.Toplevel(self.root)
     self.costline_windowwithoutincident.title("Cost Line Form without Incident Linked")
     self.costline_windowwithoutincident.geometry("800x380") 
     self.costline_windowwithoutincident.resizable(False,False)

     #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_windowwithoutincident, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png", "icon24.png"]
     for idcostnoinci, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcostnoinci: self.costline_iconswithoutincident(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

     dataframe = Frame(self.costline_windowwithoutincident, bd=3, relief=tk.RIDGE)
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=35, width=790, height=75)
     
     sup=KBACKEND.fetch_supplier_details()
     self.suppliernoinci = [row[1] for row in sup]
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=0)
     self.costlinerepnoinci = ttk.Combobox(dataframe, width=18,values=self.suppliernoinci)
     self.costlinerepnoinci.grid(row=0, column=1,padx=10,pady=3)
     self.attach_context_menu(self.costlinerepnoinci)
     self.costlinerepnoinci.bind("<<ComboboxSelected>>", self.populate_supplier_detailswithoutinci)
     self.costlinerepnoinci.bind("<KeyRelease>", self.filter_supplier_listwithoutinci)
     
     Po_Number=KBACKEND.generate_purchase_order_number()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=2)
     self.systemcostnoinci = Entry(dataframe, width=18)
     self.systemcostnoinci.grid(row=0, column=3,padx=10,pady=3)
     self.systemcostnoinci.insert(0,Po_Number)
     self.attach_context_menu(self.systemcostnoinci)
     
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=0, column=4,pady=5)
     self.repaccocostnoinci = Entry(dataframe, width=18)
     self.repaccocostnoinci.grid(row=0, column=5)
     self.attach_context_menu(self.repaccocostnoinci)

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=0,column=6)
     self.Line_createdentrynoinci=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentrynoinci.grid(row=0,column=7)
     self.Line_createdentrynoinci.state(['disabled'])
     
     current_time = datetime.now().strftime("%H:%M")
     Time_created= Label(dataframe,text="Time")
     Time_created.grid(row=1,column=0)
     self.Time_createdentrynoinci=ttk.Entry(dataframe,width=18)
     self.Time_createdentrynoinci.grid(row=1,column=1)
     self.Time_createdentrynoinci.insert(0,current_time)
     self.Time_createdentrynoinci.state(['disabled'])
     
     current_user=getuser()
     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=1,column=2)
     self.Line_createdbynoinci=ttk.Entry(dataframe,width=18)
     self.Line_createdbynoinci.grid(row=1,column=3)
     self.Line_createdbynoinci.insert(0,current_user)
     self.Line_createdbynoinci.state(['disabled'])

     Seconddataframe = Frame(self.costline_windowwithoutincident, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=115, width=790, height=70)

     Reason = Label(Seconddataframe, text="Types:")
     Reason.grid(row=0, column=0)
     Po_Types=KBACKEND.Fetch_PO_Types_noinci()
     formatted_data = [f"{row[0]} - {row[1]}" for row in Po_Types]
     self.Reasoncosttypeswithoutinci = ttk.Combobox(Seconddataframe,width=20,values=formatted_data)
     self.Reasoncosttypeswithoutinci.grid(row=0, column=1,padx=15,pady=3)
     self.Reasoncosttypeswithoutinci.bind("<<ComboboxSelected>>", self.update_rtscostcategorywithoutinci)
     
     RTS = Label(Seconddataframe, text="Category:")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategorywithoutinci = ttk.Combobox(Seconddataframe,width=20)
     self.rtscostcategorywithoutinci.grid(row=0, column=3,padx=10,pady=3)
     self.rtscostcategorywithoutinci.bind("<<ComboboxSelected>>",self.update_rtscostproductswithoutinci)
     self.rtscostcategorywithoutinci.bind("<KeyRelease>",self.filter_rts_categorywithoutinci)
     self.attach_context_menu(self.rtscostcategorywithoutinci)

     category_label = tk.Label(Seconddataframe, text="Products:")
     category_label.grid(row=0, column=4)

     self.category_costwithoutinci = ttk.Combobox(Seconddataframe, width=20)
     self.category_costwithoutinci.grid(row=0, column=5, padx=15, pady=3)
     self.category_costwithoutinci.bind("<KeyRelease>",self.filter_rts_productswithoutinci)
     self.attach_context_menu(self.category_costwithoutinci)

     rowss = KBACKEND.fetch_locations_and_descriptions()
     self.depotdetailswithoutinci = [row[1] for row in rowss]  # First column values for dropdown
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscostwithoutinci = ttk.Combobox(Seconddataframe, width=20,values=self.depotdetailswithoutinci)
     self.analysiscostwithoutinci.grid(row=1, column=1)
     self.attach_context_menu(self.analysiscostwithoutinci)

     Thirddataframe = LabelFrame(self.costline_windowwithoutincident, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=185, width=790, height=50)

     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscostwithoutinci = Entry(Thirddataframe,width=18)
     self.Partscostwithoutinci.grid(row=0, column=1,padx=15,pady=3)
     self.Partscostwithoutinci.insert(0,"0.00")
     self.attach_context_menu(self.Partscostwithoutinci)

     fifthdataframe = LabelFrame(self.costline_windowwithoutincident, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=235, width=790, height=135)

     self.notescostwithoutinci= Text(fifthdataframe,width=80, height='6',wrap='word')
     self.notescostwithoutinci.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.notescostwithoutinci)

   
    def populate_supplier_detailswithoutinci(self,event=None):
        selected_supplier= self.costlinerepnoinci.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.repaccocostnoinci.delete(0,tk.END)
              self.repaccocostnoinci.insert(0,row[0])
    def filter_supplier_listwithoutinci(self, event):
        # Function to filter supplier list based on user input
        current_text = self.costlinerepnoinci.get()
        if current_text == '':
            self.costlinerepnoinci['values'] = self.suppliernoinci
        else:
            filtered_suppliers = [supplier for supplier in self.suppliernoinci if current_text.lower() in supplier.lower()]
            self.costlinerepnoinci['values'] = filtered_suppliers
    def update_rtscostcategorywithoutinci(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.Reasoncosttypeswithoutinci.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        type_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        categories = KBACKEND.Fetch_Categories_By_Type(type_id)
        
        # Format data for the dropdown
        self.formatted_categoriescatwithoutinci = [f"{row[1]} - {row[2]}" for row in categories]

        # Update rtscostcategory dropdown with the new data
        self.rtscostcategorywithoutinci['values'] = self.formatted_categoriescatwithoutinci
        #if formatted_categories:
            #self.rtscostcategory.current(0) 
    
    def update_rtscostproductswithoutinci(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.rtscostcategorywithoutinci.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        category_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        categories = KBACKEND.Fetch_Products_By_Category(category_id)
        
        # Format data for the dropdown
        self.formatted_categoriesprodwithoutinci = [f"{row[1]} - {row[2]}" for row in categories]

        # Update rtscostcategory dropdown with the new data
        self.category_costwithoutinci['values'] = self.formatted_categoriesprodwithoutinci
        #if formatted_categories:
            #self.category_cost.current(0) 
   
    def filter_rts_categorywithoutinci(self,event):
       current_text = self.rtscostcategorywithoutinci.get()
       if current_text == '':
            self.rtscostcategorywithoutinci['values'] = self.formatted_categoriescatwithoutinci
       else:
            filtered_category = [category for category in self.formatted_categoriescatwithoutinci if current_text.lower() in category.lower()]
            self.rtscostcategorywithoutinci['values'] = filtered_category

    def filter_rts_productswithoutinci(self,event):
       current_text = self.category_costwithoutinci.get()
       if current_text == '':
            self.category_costwithoutinci['values'] = self.formatted_categoriesprodwithoutinci
       else:
            filtered_category = [product for product in self.formatted_categoriesprodwithoutinci if current_text.lower() in product.lower()]
            self.category_costwithoutinci['values'] = filtered_category
    



    def costline_iconswithoutincident(self,index):
       if index==1:
          self.close_the_costlineswithoutincident_window()
       if index==2:
          self.save_the_costlineswithoutincident_details()

    def close_the_costlineswithoutincident_window(self):
       self.costline_windowwithoutincident.destroy()
    def save_the_costlineswithoutincident_details(self):
       SupplierName_withoutinci= self.costlinerepnoinci.get()
       PO_Number=self.systemcostnoinci.get()
       KBACKEND.generate_line_number(PO_Number)
       SupplierNo=self.repaccocostnoinci.get()
       Line_Created= self.Line_createdentrynoinci.get_date()
       Time_Created= self.Time_createdentrynoinci.get()

       current_time = datetime.strptime(Time_Created, "%H:%M").time()
    
       # Combining selected date and current time into a datetime object
       combined_datetime = datetime.combine(Line_Created, current_time)

       Created_By=self.Line_createdbynoinci.get()

       Types=self.Reasoncosttypeswithoutinci.get()
       if Types:
          type_id=Types.split(' - ')[0]
       else:
          type_id=None

       Category=self.rtscostcategorywithoutinci.get()
       if Category:
          Category_id=Category.split(' - ')[0]
       else:
          Category_id=None

       Products= self.category_costwithoutinci.get()
       if Products:
          Product_id=Products.split(' - ')[0]
       else:
          Product_id=None

       Pf_Depot= self.analysiscostwithoutinci.get()

       Parts= self.Partscostwithoutinci.get()

       Notes= self.notescostwithoutinci.get("1.0", tk.END)

       KBACKEND.store_the_costlines_withoutinci(SupplierName_withoutinci,PO_Number,SupplierNo,
                                                combined_datetime,Created_By,type_id,Category_id,
                                                Product_id,Pf_Depot,Parts,Notes)
       











     ##########Incident listing in the front page########################
    ########### This clicks the data with a blue colour ###############
    def change_row_color(self, event):
     # Get the clicked row
     item = self.root.Kerride_table.identify_row(event.y)
     print("Clicked on item:", item)
    
     # Select the clicked row and configure tag for color
     self.root.Kerride_table.selection_set(item)
     print("Selected item:", self.root.Kerride_table.selection())
     self.root.Kerride_table.tag_configure("selected", background="lightblue")
    
     # Set focus to the clicked row
     self.root.Kerride_table.focus(item)
    
     # Print a message to indicate that the function is called
     print("Clicked on a row.")
    
     # Extract the registration number from the clicked row
     registration_number = self.root.Kerride_table.item(item, "values")[3]  # Assuming registration number is the first column
     incident_number= self.root.Kerride_table.item(item, "values")[4]
     # Retrieve incident details based on the registration number
     incident_details = KBACKEND.retrieve_incident_details(registration_number,incident_number)
     additional_details=KBACKEND.fetch_additional_details(registration_number)
     
     if incident_details and additional_details:
        if self.form_window is not None:
                self.form_window.destroy()
        # Open the form window and populate it with incident details
        self.open_icon1_window_with_clicked_row_data(registration_number, incident_details,additional_details)
     else:
        print("No incident details found for the selected registration number.")
     
    ############ After the data is click this opens the incident page for that particular data########
    def open_icon1_window_with_clicked_row_data(self, reg_no, incident_details,additional_details):
     # Create a new window for the form
     self.form_window = tk.Toplevel(self.root)
     self. form_window.title("Incident Detail Form")
     self.form_window.geometry("800x660") 
     self.form_window.resizable(False,False)

     #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.form_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png", "icon24.png","icon25.png","icon26.png"]
     for idin, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idin: self.open_incident_window(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)
    
    # Create frames for each page
         self.mainn_page = Frame(self.form_window)
         self.eventss_page = Frame(self.form_window)
         self.postincident_pagee = Frame(self.form_window)

    # Function to show main page
     def show_mainn_page():
        self.mainn_page.pack(fill="both", expand=True)
        self.eventss_page.pack_forget()
        self.postincident_pagee.pack_forget()

    # Function to show events page
     def show_eventss_page():
      self.mainn_page.pack_forget()
      self.eventss_page.pack(fill="both", expand=True)
      self.postincident_pagee.pack_forget()
      self.save_the_incident_details()

     def show_postincident_pagee():
      self.mainn_page.pack_forget()
      self.eventss_page.pack_forget()
      self.postincident_pagee.pack(fill="both",expand=True)
      self.save_the_incident_details()

     show_mainn_page()

      #Creating Buttons Frame for second pagE
     Buttonframe= Frame(self.form_window, relief=tk.RIDGE,)
     Buttonframe.place(x=0,y=27,width=780,height=40)

    # Create buttons
     mainn_button = tk.Button(Buttonframe, text="MAIN", command=show_mainn_page)
     mainn_button.pack(side=tk.LEFT, padx=1, pady=2)

     eventss_button = tk.Button(Buttonframe, text="EVENTS", command=show_eventss_page)
     eventss_button.pack(side=tk.LEFT, padx=1, pady=2)

     Post_button = tk.Button(Buttonframe, text="VIEW POST REPORT", command=show_postincident_pagee)
     Post_button.pack(side=tk.LEFT, padx=1, pady=2)
     
     self.post_incident_reportsone=tk.Button(Buttonframe, text="Post Incident Reports",command=self.post_incident_reports_actionone)

     # Populate the form with the retrieved data
     self.populate_form(reg_no, incident_details,additional_details)

    def populate_form(self, reg_no, incident_details,additional_details):
     # Populate your form with the retrieved incident details

      # Mainn page components
     #First Data Frame for Vehicle Details
     firstdataframe = LabelFrame(self.mainn_page, bd=3, relief=tk.RIDGE,text="Vehicle Details")
     firstdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     firstdataframe.place(x=0, y=29, width=780, height=100) 

     #Registration and Entry for the first data frame
     Reg_no = tk.Label(firstdataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)
    
     self.reistrationentry = tk.Entry(firstdataframe, width=15)
     self.reistrationentry.insert(0, incident_details.get('Registration', ''))
     self.reistrationentry.grid(row=0, column=1)
     self.attach_context_menu(self.reistrationentry)

      #Creating an Entry for page 2
     self.Make_Mod = Entry(firstdataframe, width=30)
     self.Make_Mod.insert(0,additional_details.get('Make_Mod'))
     self.Make_Mod.grid(row=0, column=2,padx=70)
     self.attach_context_menu(self.Make_Mod)

     self.lb3one = Label(firstdataframe, text="Driver name:",fg="Red")
     #self.lb3one.grid(row=0, column=3)
     self.Driverrentry = Entry(firstdataframe, width=18)
     #self.Driverrentry.grid(row=0, column=4)
     self.attach_context_menu(self.Driverrentry)

    # Retrieve the value
     self.Driverrvalue = incident_details.get('Driver_name')

    # Insert the value into the Entry widget
     self.Driverrentry.insert(0, self.Driverrvalue if self.Driverrvalue is not None else "")
     
     
     #Creating a Label and Entry for Fleet No:
     Fleett_No=Label(firstdataframe, text="Fleet No:")
     Fleett_No.grid(row=1, column=0,pady=6)
     self.fleett=Entry(firstdataframe,width=15)
     self.fleett.grid(row=1,column=1)
     self.attach_context_menu(self.fleett)
     self.fleettvalue=additional_details.get('fleet_no')
     self.fleett.insert(0,self.fleettvalue if self.fleettvalue is not None else"")
     
     self.view_fleett = Button(firstdataframe, text="View fleet info",width=12,command=self.open_fleet_infotwo)
     self.view_fleett.grid(row=2, column=0,padx=20)
     self.basee_url = "http://igloouk/Igloo"

     #Creating a Label and Entry for Vehicle loaded:

     lb3 = Label(firstdataframe, text="Vehicle loaded:")
     lb3.grid(row=2,column=1,padx=10)
     self.vehiclevar=tk.BooleanVar()
     self.Vehiclee_loaded=Checkbutton(firstdataframe,width=2,variable=self.vehiclevar)
     self.Vehiclee_loaded.grid(row=2,column=2,sticky='w')
     self.attach_context_menu(self.Vehiclee_loaded)
     self.vehiclevalue= incident_details.get('Vehicle_loaded',0)

     # Convert the retrieved value to boolean (1 for True, 0 for False)
     self.vehiclevalue = bool(self.vehiclevalue)

     # Set the state of the Checkbutton based on the retrieved value
     self.vehiclevar.set(self.vehiclevalue)
     #Creating another Entry for page 2
     self.empty = Entry(firstdataframe, width=30)
     self.empty.grid(row=1, column=2,padx=80)
     self.attach_context_menu(self.empty)

     #Creating a Label and Entry for Driver Phone:

     self.lb3phoneone = Label(firstdataframe, text="Phone:",fg="Red")
     #self.lb3phoneone.grid(row=1, column=3)
     self.Driverrphone = Entry(firstdataframe, width=18)
     #self.Driverrphone.grid(row=1, column=4)
     self.attach_context_menu(self.Driverrphone)
     self.Driverrphonevalue= incident_details.get('Driver_phone')
     self.Driverrphone.insert(0,self.Driverrphonevalue if self.Driverrphonevalue is not None else"")
     
     
     #Second Data Frame for Customer and Company Details 
     Seconddataframe= LabelFrame(self.mainn_page, bd=3, relief=tk.RIDGE,text="Customer/Company Details")
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0,y=130,width=780,height=100)

     #Creating Label for ID and entry
     Customer_Id = Label(Seconddataframe, text="Customer_ID:", padx=3, pady=3)
     Customer_Id.grid(row=0, column=0)
     self.Customer_Identryy= Entry(Seconddataframe, width=14)
     self.Customer_Identryy.grid(row=0, column=1)
     self.attach_context_menu(self.Customer_Identryy)
     self.Customer_Identryyvalue=additional_details.get('Customer_No')
     self.Customer_Identryy.insert(0,self.Customer_Identryyvalue if self.Customer_Identryyvalue is not 
                                   None else"")
     

     #Creating Label for Cust_Name and entry
     Cust_Name = Label(Seconddataframe, text="Name:", padx=3, pady=3)
     Cust_Name.grid(row=0, column=2)
     self.Cust_Namee_Entry= Entry(Seconddataframe, width=14)
     self.Cust_Namee_Entry.grid(row=0, column=3)
     self.attach_context_menu(self.Cust_Namee_Entry)
     self.Cust_Namee_Entryvalue= additional_details.get('Customer_Name')
     self.Cust_Namee_Entry.insert(0,self.Cust_Namee_Entryvalue if self.Cust_Namee_Entryvalue is not
                                  None else"")
     
     
     #Creating Label for Contract_No and Entry
     
     Contract_No = Label(Seconddataframe, text="Contract_No:", padx=3, pady=3)
     Contract_No.grid(row=0, column=4)
     self.Contract_No_Entryy= Entry(Seconddataframe, width=14)
     self.Contract_No_Entryy.grid(row=0, column=5)
     self.attach_context_menu(self.Contract_No_Entryy)
     self.Contract_No_Entryyvalue= additional_details.get('Contract_No')
     self.Contract_No_Entryy.insert(0,self.Contract_No_Entryyvalue if self.Contract_No_Entryyvalue is 
                                    not None else"")
     
     
      #Creating Label for Contact_Tel and Entry

     self.Contact_Telone = Label(Seconddataframe, text="Contact_Tel:", padx=3, pady=3,fg="red")
     self.Contact_Telone.grid(row=1, column=2)
     self.Contact_Tel_Entryy= Entry(Seconddataframe, width=14)
     self.Contact_Tel_Entryy.grid(row=1, column=3)
     self.attach_context_menu(self.Contact_Tel_Entryy)
     self.Contact_Tel_Entryyvalue=incident_details.get('Contact_tel')
     self.Contact_Tel_Entryy.insert(0,self.Contact_Tel_Entryyvalue if self.Contact_Tel_Entryyvalue is 
                                    not None else"" )
     

    #Creating Label for Contact_Email and Entry

     self.Contact_Emailone = Label(Seconddataframe, text="Contact_Email:", padx=3, pady=3,fg="red")
     self.Contact_Emailone.grid(row=1, column=4)
     self.Contact_Email_Entryy= Entry(Seconddataframe, width=14)
     self.Contact_Email_Entryy.grid(row=1, column=5)
     self.attach_context_menu(self.Contact_Email_Entryy)
     self.Contact_Email_Entryyvalue=incident_details.get('Contact_Email')
     self.Contact_Email_Entryy.insert(0,self.Contact_Email_Entryyvalue if self.Contact_Email_Entryyvalue
                                      is not None else"")
     

     #Creating Label for Contact_Name and Entry

     Contact_Name_Label=Label(Seconddataframe, text="Contact_Name:",fg='red', padx=3, pady=3)
     Contact_Name_Label.grid(row=0, column=6)
     self.Contact_Name_Entryy= Entry(Seconddataframe, width=14)
     self.Contact_Name_Entryy.grid(row=0, column=7)
     self.attach_context_menu(self.Contact_Name_Entryy)
     self.Contact_Name_Entryyvalue=incident_details.get('Contact_name')
     self.Contact_Name_Entryy.insert(0,self.Contact_Name_Entryyvalue if self.Contact_Name_Entryyvalue is
                                     not None else"")
     

     #Creating Label for Customer_Defect_No and Entry

     Customer_DefNO=Label(Seconddataframe, text="Cust_Def_No:", padx=3, pady=3)
     Customer_DefNO.grid(row=1, column=6)
     self.Customer_defno_Entryy= Entry(Seconddataframe, width=14)
     self.Customer_defno_Entryy.grid(row=1, column=7)
     self.attach_context_menu(self.Customer_defno_Entryy)
     self.Customer_defno_Entryyvalue= incident_details.get('Cust_defect')
     self.Customer_defno_Entryy.insert(0,self.Customer_defno_Entryyvalue if self.Customer_defno_Entryyvalue
                                       is not None else"")


    

     #Creating Label for Contact_Method_ID AND Entry
     self.contactmethd= KBACKEND.fetch_contact_detais()
     self.contactdets=[row[1] for row in self.contactmethd]
     Contact_Method_Id=Label(Seconddataframe,text="Contact_Method_ID*:",fg="red",padx=3,pady=3)
     Contact_Method_Id.grid(row=1,column=0)
     self.Contact_Method_Entryy=ttk.Combobox(Seconddataframe,width=12,values=self.contactdets)
     self.Contact_Method_Entryy.grid(row=1,column=1)
     self.attach_context_menu(self.Contact_Method_Entryy)
     self.Contact_Email_Entryyvalue=incident_details.get('Contact_id')
     self.Contact_Method_Entryy.insert(0, self.Contact_Email_Entryyvalue if self.Contact_Email_Entryyvalue
                                       is not None else"")
     #self.Contact_Method_Entryy.bind("<<ComboboxSelected>>", self.on_contact_method_selectedone)
     #self.on_contact_method_selectedone()
     

     #Creating Label for Depot
     Depot=Label(Seconddataframe,text="Customer Depot",padx=3,pady=3)
     Depot.grid(row=2,column=0)
     self.Depotentryy=Entry(Seconddataframe,width=16)
     self.Depotentryy.grid(row=2,column=1)
     self.attach_context_menu(self.Depotentryy)
     self.Depotentryyvalue=additional_details.get('Customer_Depot')
     self.Depotentryy.insert(0,self.Depotentryyvalue if self.Depotentryyvalue is not None else"")
     
     
     #Creating a frame for incident details 
      
     ThirdDataframe= LabelFrame(self.mainn_page, bd=3, relief=tk.RIDGE,text="Incident Details")
     ThirdDataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     ThirdDataframe.place(x=0,y=230,width=780,height=345)

     #Creating a label and entry field for location
     Location= Label(ThirdDataframe, text="Location:")
     Location.grid(row=0, column=0,pady=(0,25),sticky='w')
     self.locaentryy= Text(ThirdDataframe,width=30, height='3',wrap='word')
     self.locaentryy.grid(row=0,column=1,columnspan=2,sticky='w')
     self.attach_context_menu(self.locaentryy)
     self.locaentryyvalue=incident_details.get('Defect_Address')
     self.locaentryy.insert("1.0",self.locaentryyvalue if self.locaentryyvalue is not None else"")

     self.view_mapp = Button(ThirdDataframe, text="View map",width=12,command=self.open_maptwo)
     self.view_mapp.grid(row=0, column=2,padx=5)
     self.homee_url = "https://www.google.com/maps"
     

     #Creating a label and Entry for Number

     Number= Label(ThirdDataframe,text="Number:")
     Number.grid(row=0,column=3,padx=3)
     self.Numberentryy=Entry(ThirdDataframe,width=15)
     self.Numberentryy.grid(row=0,column=4)
     self.attach_context_menu(self.Numberentryy)
     self.Numberentryyvalue=incident_details.get('Incident No')
     self.Numberentryy.insert(0, self.Numberentryyvalue if self.Numberentryyvalue is not None else"")
     
     
     #Creating Label and Entry for Date
     Date = Label(ThirdDataframe, text="Date", padx=5)
     Date.grid(row=1, column=3,padx=20,pady=4)
     self.dateeentry= DateEntry(ThirdDataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.dateeentry.grid(row=1, column=4,sticky='w')
     self.attach_context_menu(self.dateeentry)
     self.dateeentryvalue=incident_details.get('Date')
     self.dateeentry.set_date(self.dateeentryvalue if self.dateeentryvalue is not None else"")

     #current_time = datetime.now().strftime("%H:%M")
     Time= Label(ThirdDataframe,text= "Time",padx=5)
     Time.grid(row=2,column=3)
     self.modifiedtimetwo= ttk.Entry(ThirdDataframe,width=15)
     self.modifiedtimetwo.grid(row=2, column=4,sticky='w')
     incident_datetime=incident_details.get('Date')

     incident_time_str = incident_datetime.strftime("%H:%M")

     self.modifiedtimetwo.delete(0, 'end')  # Clear any existing content
     self.modifiedtimetwo.insert(0, incident_time_str)

     
     
     #Creating Label and Entry for Time 

     Created_by = Label(ThirdDataframe, text="Created_By", padx=5)
     Created_by.grid(row=3, column=3)
     self.Timee= ttk.Entry(ThirdDataframe, width=15)
     self.Timee.grid(row=3, column=4,sticky='w')
     self.attach_context_menu(self.Timee)
     self.timeevalue=incident_details.get('Createdby')
     self.Timee.insert(0,self.timeevalue if self.timeevalue is not None else"")
     self.Timee.state(['disabled'])
     


     #Creating Label and Entry for Odometer

     Odo= Label(ThirdDataframe, text="Odometer", padx=5)
     Odo.grid(row=4, column=3)
     self.Odoentry= ttk.Entry(ThirdDataframe, width=13)
     self.Odoentry.grid(row=4, column=4,sticky='w')
     self.attach_context_menu(self.Odoentry)
     self.Odoentryvalue=incident_details.get('Odometer')
     self.Odoentry.insert(0,self.Odoentryvalue if self.Odoentryvalue is not None else"")
     self.Odoentry.state(['disabled'])

     

     #Creating Lable and Entry for Location:
     # Define the label
     self.Localabel = tk.Label(ThirdDataframe, text="Depot loc:", padx=5)
     self.Localabel.grid(row=5, column=3)

    # Define locaentry
     # Fetch data from the database using backend function
     rowss = KBACKEND.fetch_locations_and_descriptions()
     self.locations = [row[0] for row in rowss]  # First column values for dropdown
    # Define loca combobox
     self.locationn_1 = ttk.Combobox(ThirdDataframe, values=self.locations, width=15)
     self.locationn_1.grid(row=5, column=4, sticky='w')
     self.attach_context_menu(self.locationn_1)
     self.locationn_1value=additional_details.get('PF_Depot')
     self.locationn_1.insert(0,self.locationn_1value if self.locationn_1value is not None else"")
     #self.populate_location_descriptionn()
     

        # Define loca entry
     self.locationn_2 = tk.Entry(ThirdDataframe, width=15)
     self.locationn_2.grid(row=6, column=4, sticky='w', columnspan=4)
     self.attach_context_menu(self.locationn_2)
     self.locationn_1.bind("<<ComboboxSelected>>", self.populate_location_descriptionn)
     self.populate_location_descriptionn()

     #Creating a Lable and Entry for Type

     self.categorydetails= KBACKEND.fetch_cat_details()
     self.categorydescription= [row[1]for row in self.categorydetails]

     Typee= Label(ThirdDataframe, text="Category *:",fg="red")
     Typee.grid(row=1,column=0,padx=5,pady=6)
     self.CatEntryy= ttk.Combobox(ThirdDataframe, values=self.categorydescription, width=13)
     self.CatEntryy.grid(row=1, column=1, pady=4, sticky='w') 
     self.attach_context_menu(self.CatEntryy)
     self.CatEntryyvalue=incident_details.get('Cat')
     self.CatEntryy.insert(0,self.CatEntryyvalue if self.CatEntryyvalue is not None else"")

     loctype= Label(ThirdDataframe, text="Incident Loc *:",fg="red")
     loctype.grid(row=2,column=0,padx=5,pady=6)
     self.locationdetails=KBACKEND.fetch_Location_details()
     self.locationdescription= [row[1] for row in self.locationdetails]
     self.LolEntryy=ttk.Combobox(ThirdDataframe,values=self.locationdescription,width=13)
     self.LolEntryy.grid(row=2,column=1,pady=4,sticky='w')
     self.attach_context_menu(self.LolEntryy)
     self.LolEntryyvalue=incident_details.get('Loca')
     self.LolEntryy.insert(0,self.LolEntryyvalue if self.LolEntryyvalue is not None else"")
     self.LolEntryy.bind("<<ComboboxSelected>>", self.on_location_selectedone)
     self.on_location_selectedone()

     Chartype= Label(ThirdDataframe, text="Recharge *:",fg="red")
     Chartype.grid(row=3,column=0,padx=5,pady=2)
     self.chargedetails=KBACKEND.fetch_charge_details()
     self.Chargedescription= [row[1] for row in self.chargedetails]
     self.Chargeentryy=ttk.Combobox(ThirdDataframe,values=self.Chargedescription,width=13)
     self.Chargeentryy.grid(row=3,column=1,pady=2,sticky='w')
     self.attach_context_menu(self.Chargeentryy)
     self.Chargeentryyvalue=incident_details.get('Charge')
     self.Chargeentryy.insert(0,self.Chargeentryyvalue if self.Chargeentryyvalue is not None else"")
     self.Chargeentryy.bind("<<ComboboxSelected>>", self.on_recharge_selectedone)
     self.on_recharge_selectedone()
     
     
     #Creating a Label and Entry for Fault Description
     Fault= Label(ThirdDataframe, text="Fault Description:")
     Fault.grid(row=4, column=0, pady=(0,25),sticky='w')
     self.Faultentryy= Text(ThirdDataframe,width=30, height='3',wrap='word')
     self.Faultentryy.grid(row=4,column=1,sticky='w')
     self.attach_context_menu(self.Faultentryy)
     self.Faultentryyvalue=incident_details['Defectdesc']
     self.Faultentryy.insert("1.0",self.Faultentryyvalue if self.Faultentryyvalue is not None else"")
     
     #Creating a Lable and Entry for Status

     self.rowsss= KBACKEND.fetch_status_details()
     self.Statuss= [row[1] for row in self.rowsss]
     Statuss= Label(ThirdDataframe, text="Status *:",fg="red")
     Statuss.grid(row=5,column=0,padx=2)
     self.StatussEntryy= ttk.Combobox(ThirdDataframe, values=self.Statuss, width=25)
     self.StatussEntryy.grid(row=5, column=1, padx=2,pady=2, sticky='w')
     self.attach_context_menu(self.StatussEntryy)
     self.StatussEntryyvalue= incident_details.get('Status')
     self.StatussEntryy.insert(0,self.StatussEntryyvalue if self.StatussEntryyvalue is not None else"")
     self.StatussEntryy.bind('<<ComboboxSelected>>', self.on_status_selectedone)
     self.on_status_selectedone()

     Attendance_Deff= Label(ThirdDataframe, text="Attendance_Deferred")
     Attendance_Deff.grid(row=6,column=0)
     self.attendance_vari=tk.BooleanVar()
     self.AttendanceEntryy= ttk.Checkbutton(ThirdDataframe, variable=self.attendance_vari)
     self.AttendanceEntryy.grid(row=6, column=1, sticky='w')
     self.attach_context_menu(self.AttendanceEntryy)
     self.AttendanceEntryvalue= incident_details.get('Attendance',0)
     
     self.AttendanceEntryvalue=bool(self.AttendanceEntryvalue)
     self.attendance_vari.set(self.AttendanceEntryvalue)
     
     Deffered = Label(ThirdDataframe, text='Deferred To')
     Deffered.grid(row=7, column=0, padx=2, sticky='w')
     self.Deferred_Too = DateEntry(ThirdDataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Deferred_Too.grid(row=7, column=1, padx=2, sticky='w')
     self.attach_context_menu(self.Deferred_Too)
     self.Deferred_Tovalue= incident_details.get('Deferred')
     if self.Deferred_Tovalue is not None:
          self.Deferred_Tovaluedate= self.Deferred_Tovalue.date()
     else:
          self.Deferred_Tovaluedate=None
     self.Deferred_Too.set_date(self.Deferred_Tovaluedate)

     Deff_time=Label(ThirdDataframe,text='Deferred To Time')
     Deff_time.grid(row=8,column=0,padx=2, sticky='w')
     self.Deferred_Timetwo= Entry(ThirdDataframe,width=15)
     self.Deferred_Timetwo.grid(row=8,column=1,sticky='w')
     self.Deferred_Timetwovalue=incident_details.get('Deferred')
     current_time= datetime.now().strftime("%H:%M")
     if self.Deferred_Timetwovalue is not None:
         self.Deferred_TimetwoTime= self.Deferred_Timetwovalue.strftime('%H:%M')
     else:
        self.Deferred_TimetwoTime= current_time
     self.Deferred_Timetwo.insert(0,self.Deferred_TimetwoTime if self.Deferred_TimetwoTime is not None else current_time)
     self.attach_context_menu(self.Deferred_Timetwo)


     whatwords = Label(ThirdDataframe, text='Defect_loc_W3W')
     whatwords.grid(row=7, column=3,sticky='w')
     self.whatwordsentryy = Entry(ThirdDataframe, width=30)
     self.whatwordsentryy.grid(row=7, column=4, sticky='w') 
     self.attach_context_menu(self.whatwordsentryy)
     self.whatwordsentryyvalue= incident_details.get('Whatwords')
     self.whatwordsentryy.insert(0,self.whatwordsentryyvalue if self.whatwordsentryyvalue is not None else"")

     self.whatt= tk.Button(ThirdDataframe, text="View map", width=12,command=self.open_what_maptwo)
     self.whatt.grid(row=8, column=4, columnspan=2, pady=5)
     self.whatt_url = "https://what3words.com"

     
     #Creating Frame for Supplier details
     Fourthdataframe=LabelFrame(self.mainn_page,bd=3,relief=tk.RIDGE,text="Supplier Details")
     Fourthdataframe.pack(side=tk.TOP,padx=8,pady=3, anchor="nw")
     Fourthdataframe.place(x=0,y=575,width=780,height=50)
     
     #Creating label and Entry for Name:
     supp=KBACKEND.fetch_supplier_details()
     self.supplier = [row[1] for row in supp]
     
     self.supplierno=[row[0] for row in supp]
     Namesup= Label(Fourthdataframe, text="Supplier No:")
     Namesup.grid(row=0,column=0,padx=5)
     self.nameentryy= ttk.Combobox(Fourthdataframe,value=self.supplierno,width=30)
     self.nameentryy.grid(row=0,column=1,padx=5)
     self.Suppliernamevalue= incident_details.get('Supplier_No')
     self.nameentryy.insert(0,self.Suppliernamevalue if self.Suppliernamevalue is not None else"")
     self.attach_context_menu(self.nameentryy)
     #self.nameentryy.bind("<<ComboboxSelected>>", self.populate_supplier_details_two)
     
    
     
      #Creating label and Entry for Contat:
     Contactsup= Label(Fourthdataframe, text="Supplier Name:")
     Contactsup.grid(row=0,column=2,padx=5,pady=5)
     self.Contactentryy= ttk.Combobox(Fourthdataframe,values=self.supplier,width=30)
     self.Contactentryy.grid(row=0,column=3,padx=5,pady=5)
     self.attach_context_menu(self.Contactentryy)
     self.Contactentryy.bind("<KeyRelease>", self.filter_supplier_list_two)
     self.nameentryy.bind("<<ComboboxSelected>>", self.populate_supplier_details_two)
     self.Contactentryy.bind("<<ComboboxSelected>>", self.populate_supplier_detailss)
     
     
     
     

     Phonesup= Label(Fourthdataframe, text="Phone:")
     Phonesup.grid(row=0,column=4,padx=5)
     self.Phoneentryy= ttk.Entry(Fourthdataframe,width=17)
     self.Phoneentryy.grid(row=0,column=5,padx=5)
     self.attach_context_menu(self.Phoneentryy)
     self.nameentryy.bind("<<ComboboxSelected>>", self.populate_supplier_details_two)
     self.populate_supplier_details_two()
     
     
     #Retrieving all the events_information :

     EventsFrame= LabelFrame(self.eventss_page, relief=tk.RIDGE,text="Events")
     EventsFrame.place(x=0,y=30,width=780,height=500)
    
     
     self.eventss_tree = ttk.Treeview(EventsFrame, columns=("Created", "Time1", "By1", "Event Type", "Event Action", "Notes", "Last Updated", "Time2","By2", "Follow-Up", "Time3","By3", "Action"),show="headings")
     self.eventss_tree.pack(fill="both", expand=True)

     self.eventss_tree.heading("Created", text="Created")
     self.eventss_tree.heading("Time1", text="Time1")
     self.eventss_tree.heading("By1", text="By1")
     self.eventss_tree.heading("Event Type", text="Event Type")
     self.eventss_tree.heading("Event Action", text="Event Action")
     self.eventss_tree.heading("Notes", text="Notes")
     self.eventss_tree.heading("Last Updated", text="Last Updated")
     self.eventss_tree.heading("Time2", text="Time2")
     self.eventss_tree.heading("By2",text="By2")
     self.eventss_tree.heading("Follow-Up", text="Follow-Up")
     self.eventss_tree.heading("Time3", text="Time3")
     self.eventss_tree.heading("By3",text="By3")
     self.eventss_tree.heading("Action", text="Action")

     self.eventss_tree.column("Created", width=90)
     self.eventss_tree.column("Time1", width=70)
     self.eventss_tree.column("By1", width=60)
     self.eventss_tree.column("Event Type", width=80)
     self.eventss_tree.column("Event Action", width=80)
     self.eventss_tree.column("Notes", width=200)
     self.eventss_tree.column("Last Updated", width=90)
     self.eventss_tree.column("Time2", width=70)
     self.eventss_tree.column("By2",width=60)
     self.eventss_tree.column("Follow-Up", width= 70)
     self.eventss_tree.column("Time3",width= 70)
     self.eventss_tree.column("By3",width= 60)
     self.eventss_tree.column("Action",width= 70)
     
     
     #Simulate adding some data to the tree
     self.scrollbarr_y = ttk.Scrollbar(EventsFrame, orient="vertical", command=self.eventss_tree.yview)
     self.scrollbarr_y.pack(side="right", fill="y")
     self.eventss_tree.configure(yscrollcommand=self.scrollbarr_y.set)

     self.scrollbarr_x = ttk.Scrollbar(EventsFrame, orient="horizontal", command=self.eventss_tree.xview)
     self.scrollbarr_x.pack(side="bottom", fill="x")
     self.eventss_tree.configure(xscrollcommand=self.scrollbarr_x.set)

     self.populate_events_tree()

     self.eventss_tree.bind("<<TreeviewSelect>>", self.on_row_selected)

     PostincidentFrame= LabelFrame(self.postincident_pagee, relief=tk.RIDGE,text="Post Incident Report")
     PostincidentFrame.place(x=0,y=30,width=780,height=300)

     self.Post_incident_treee = ttk.Treeview(PostincidentFrame, columns=("Incident_Number","Date","Time","Created By","Incident Category","Comments"),show="headings")
     self.Post_incident_treee.pack(fill="both", expand=True)

     self.Post_incident_treee.heading("Incident_Number", text="Incident_Number")
     self.Post_incident_treee.heading("Date", text="Date")
     self.Post_incident_treee.heading("Time", text="Time")
     self.Post_incident_treee.heading("Created By", text="Created By")
     self.Post_incident_treee.heading("Incident Category", text="Incident Category")
     self.Post_incident_treee.heading("Comments", text="Comments")
     

     self.Post_incident_treee.column("Incident_Number", width=90)
     self.Post_incident_treee.column("Date", width=70)
     self.Post_incident_treee.column("Time", width=60)
     self.Post_incident_treee.column("Created By", width=80)
     self.Post_incident_treee.column("Incident Category", width=80)
     self.Post_incident_treee.column("Comments", width=200)
     self.Post_incident_treee.bind("<<TreeviewSelect>>",self.clicking_the_postreports)
     self.populate_the_post_incident_reports()
    
    def open_fleet_infotwo(self):
            webbrowser.open(self.basee_url)     
    def open_maptwo(self):
        address = self.locaentryy.get("1.0", tk.END).strip()  # Get the text from the Text widget
        if not address:
            webbrowser.open(self.homee_url)
        else:
            formatted_address = address.replace(" ", "+")
            map_url = f"https://www.google.com/maps/search/?api=1&query={formatted_address}"
            webbrowser.open(map_url)
    def open_what_maptwo(self):
        address = self.whatwordsentryy.get().strip()  # Get the text from the Entry widget
        if not address:
            webbrowser.open(self.whatt_url)
        else:
            formatted_address = address.replace(" ", ".")
            map_url = f"https://what3words.com/{formatted_address}"
            webbrowser.open(map_url)

    def on_row_selected(self, event):
        
        selected_item = self.eventss_tree.selection()
        
        if selected_item:
         # Extract the index of the selected item
         item_index = self.eventss_tree.index(selected_item[0])

         # Event number is the index + 1 (since event numbers start from 1)
         event_no = item_index + 1

         # Get the incident number from the entry
         incident_no=self.Numberentryy.get()

         fetch_event_details= KBACKEND.fetch_data_for_event(incident_no,event_no)

         self.open_eventspage_with_clickedrow(fetch_event_details)
    
    def filter_supplier_list_two(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Contactentryy.get()
        if current_text == '':
            self.Contactentryy['values'] = self.supplier
        else:
            filtered_suppliers = [supplier for supplier in self.supplier if current_text.lower() in supplier.lower()]
            self.Contactentryy['values'] = filtered_suppliers
    #def on_contact_method_selectedone(self, event=None):
        #selected_method = self.Contact_Method_Entryy.get()
        #if selected_method == 'Telephone':
            #self.show_contact_telone()
            #self.hide_contact_emailone()
        #elif selected_method == 'Email':
            #self.show_contact_emailone()
            #self.hide_contact_telone()

    #def show_contact_telone(self):
        #self.Contact_Telone.grid(row=1, column=2)
        #self.Contact_Tel_Entryy.grid(row=1, column=3)
        #self.Contact_Telone.configure(fg='red')

    #def hide_contact_telone(self):
        #self.Contact_Telone.grid_forget()
        #self.Contact_Tel_Entryy.grid_forget()

    #def show_contact_emailone(self):
        #self.Contact_Emailone.grid(row=1, column=4)
        #self.Contact_Email_Entryy.grid(row=1, column=5)
        #self.Contact_Emailone.configure(fg='red')

    #def hide_contact_emailone(self):
        #self.Contact_Emailone.grid_forget()
        #self.Contact_Email_Entryy.grid_forget()
    def post_incident_reports_actionone(self):
      self.save_the_incident_details()
      self.post_windowone= tk.Toplevel(self.root)
      self.post_windowone.title("Post Incident Report Form")
      self.post_windowone.geometry("750x350") 
      self.post_windowone.resizable(False,False)

      icon_box = tk.Frame(self.post_windowone, relief=tk.RIDGE, borderwidth=3)
      icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

      # You can add icons below menus using PhotoImage or other methods.
      # For demonstration purposes, let's create 13 small image icons.
      image_paths = ["icon14.png", "icon15.png"]
      for idpost, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idpost: self.postwindowfunctionsone(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

      First_framepost= LabelFrame(self.post_windowone, bd=3, relief=tk.RIDGE,text="Post Incident Reports")
      First_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      First_framepost.place(x=0,y=30,width=700,height=120)
      
      Incident_Number=self.Numberentryy.get()
      I_No=Label(First_framepost, text="Incident_Number:")
      I_No.grid(row=0, column=0,padx=5)
      self.Incidentnumber_entrypostone=Entry(First_framepost,width=15)
      self.Incidentnumber_entrypostone.grid(row=0,column=1,padx=5)
      self.Incidentnumber_entrypostone.insert(0,Incident_Number)

      Date = Label(First_framepost, text="Date:")
      Date.grid(row=0, column=2,padx=5)
      self.datepostone= DateEntry(First_framepost, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
      self.datepostone.grid(row=0, column=3,sticky='w',padx=5)
      self.datepostone.state(['disabled'])

      current_time = datetime.now().strftime("%H:%M")
      Time= Label(First_framepost,text= "Time:")
      Time.grid(row=0,column=4,padx=5)
      self.timepostone= ttk.Entry(First_framepost,width=15)
      self.timepostone.grid(row=0, column=5,sticky='w',padx=5,pady=8)
      self.timepostone.insert(0,current_time)
      self.timepostone.state(['disabled'])

      currentuser=getuser()
      Createdby= Label(First_framepost,text="Created By")
      Createdby.grid(row=1,column=0,padx=5)
      self.createdbypostone= ttk.Entry(First_framepost)
      self.createdbypostone.grid(row=1,column=1,padx=5)
      self.createdbypostone.insert(0,currentuser)
      self.createdbypostone.state(['disabled'])

      Inc= Label(First_framepost, text="Incident_Category:")
      Inc.grid(row=1, column=2,padx=5)
      self.Incpostone= ttk.Entry(First_framepost, width=15)
      self.Incpostone.grid(row=1, column=3,sticky='w')

      self.linked_postvarone = tk.BooleanVar()
      self.linked_postvalueone = tk.StringVar()
      self.Linkedpostone=Checkbutton(First_framepost,width=2,variable=self.linked_postvarone,command=self.toggle_post_entryone)
      self.Linkedpostone.grid(row=1,column=4,sticky='w',padx=3)
      Linked_Orders= Label(First_framepost,text="Final Costed")
      Linked_Orders.grid(row=1,column=5,padx=5,pady=5)

      self.catdetailsforpostincidentone=KBACKEND.fetch_cat_details()
      self.catdetailspostone= [row[1] for row in self.catdetailsforpostincidentone]
      lb5 = Label(First_framepost, text="Defect Cat*",fg="red", padx=5,pady=5)
      lb5.grid(row=2, column=0)
      self.Categorypostone = ttk.Combobox(First_framepost, values= self.catdetailspostone, width=13)
      self.Categorypostone.grid(row=2, column=1)

      self.verdictdetailsone=KBACKEND.fetch_verdict_details()
      self.verdictdetailspostone=[row[1] for row in self.verdictdetailsone]
      lb6 = Label(First_framepost, text="PIR_Verdict*",fg="red", padx=5,pady=5)
      lb6.grid(row=2, column=2)
      self.PIR_verdictone = ttk.Combobox(First_framepost, values= self.verdictdetailspostone, width=13)
      self.PIR_verdictone.grid(row=2, column=3)

      Second_framepost= Frame(self.post_windowone, bd=3, relief=tk.RIDGE)
      Second_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      Second_framepost.place(x=0,y=150,width=700,height=180)

      comments= Label(Second_framepost, text="Comments:")
      comments.grid(row=0, column=0,pady=5,sticky='w')
      self.commentspostone= Text(Second_framepost,width=40, height='8',wrap='word')
      self.commentspostone.grid(row=0,column=1,columnspan=2,sticky='w',pady=5)

      
    def toggle_post_entryone(self):
        if self.linked_postvarone.get():
            self.linked_postvalueone.set("Y")
        else:
           self.linked_postvalueone.set("N")
    def postwindowfunctionsone(self,index):
       if index==1:
          self.exit_the_post_incident_reportone()
       if index==2:
          self.save_the_post_incident_reportone()
    def exit_the_post_incident_reportone(self):
       self.post_windowone.destroy()
    def save_the_post_incident_reportone(self):
       Incident_Number=self.Incidentnumber_entrypostone.get()
       date_str=self.datepostone.get_date()
       time_str=self.timepostone.get()

       current_time = datetime.strptime(time_str, "%H:%M").time()

       combined_datetime = datetime.combine(date_str, current_time)

       Created_By= self.createdbypostone.get()

       Incident_cat=self.Incpostone.get()

       Final_costed=self.linked_postvalueone.get()

       category_post= self.Categorypostone.get()
       if category_post is None or category_post == "":
          messagebox.showerror("Error", "Primary key attribute 'Category_Post' requires a value.")
       else:
         for row in self.catdetailsforpostincidentone:
          if row[1] == category_post:
            category_post_value_to_store = row[0]
            break
       verdict_post=self.PIR_verdictone.get()
       if verdict_post is None or verdict_post=="":
          messagebox.showerror("Error", "Primary key attribute 'PIR_Verdict' requires a value.")
       else:
          for row in self.verdictdetailsone:
             if row[1]== verdict_post:
               verdict_post_value_to_store=row[0]
               break

       Comments=self.commentspostone.get("1.0", tk.END)

       KBACKEND.store_the_postincident_reports(Incident_Number,combined_datetime,Created_By,Incident_cat,
                                               Final_costed,Comments,category_post_value_to_store,verdict_post_value_to_store)
       
       Incident_Number=self.Numberentryy.get()
       Post_incident_report=KBACKEND.fetch_lastpost_reports_and_insert(Incident_Number)

       self.Post_incident_treee.delete(*self.Post_incident_treee.get_children())

       if Post_incident_report:
          for post_details in Post_incident_report:
             Inci_Number= post_details.get("I_number")
             Date_time= post_details.get("Report_Created")
             if Date_time is not None:
              Date = Date_time.date()
              Time = Date_time.time()
             else:
               Date = None  # or a default value
               Time = None
             Created= post_details.get("Created_By")
             Incident_Category= post_details.get("Inc_Category_ID")
             Commentss= post_details.get("Comments")

             self.Post_incident_treee.insert("", "end", values=(Incident_Number,Date,Time,Created,Incident_Category,Commentss))   
             
             self.post_incident_reportsone.config(state=DISABLED)
    def on_status_selectedone(self, event=None):
        selected_status = self.StatussEntryy.get()
        Inci_number= self.Numberentryy.get()
        current_user=getuser()
        if selected_status == "Completed" and KBACKEND.is_authority_level_sufficient(current_user):
            self.post_incident_reportsone.pack(side=tk.RIGHT, padx=1, pady=2)
        else:
            self.post_incident_reportsone.pack_forget()
        if selected_status=="Completed" and KBACKEND.fetch_postreportsnew(Inci_number):
           self.post_incident_reportsone.config(state=DISABLED)   
        if selected_status == "Closed": 
           Incident_Number = self.Numberentryy.get()
           if not KBACKEND.fetch_postreports(Incident_Number):
                messagebox.showwarning("Warning", "Create a post incident report before closing the incident.")
                self.StatussEntryy.set('')  # Clear the selection
           else:
               self.StatussEntryy.set("Closed")
               #self.post_incident_reports.config(state=DISABLED)
               #self.StatussEntry.state(['disabled'])

    def check_initial_value(self):
        initial_value = self.LolEntryy.get()
        self.handle_location_logic(initial_value)

    def on_location_selectedone(self, event=None):
        selected_location = self.LolEntryy.get()
        self.handle_location_logic(selected_location)

    def handle_location_logic(self, location):
        if location == "Roadside":
            self.show_driver_fields()
        else:
            self.hide_driver_fields()

    def show_driver_fields(self):
        self.lb3one.grid(row=0, column=3)
        self.Driverrentry.grid(row=0, column=4)
        self.lb3phoneone.grid(row=1, column=3)
        self.Driverrphone.grid(row=1, column=4)

    def hide_driver_fields(self):
        self.lb3one.grid_remove()
        self.Driverrentry.grid_remove()
        self.lb3phoneone.grid_remove()
        self.Driverrphone.grid_remove()

    #def on_location_selectedone(self, event):
        #selected_location = self.LolEntryy.get()
        
        #if selected_location == "Roadside":
            #self.lb3one.grid(row=0, column=3)
            #self.Driverrentry.grid(row=0, column=4)
            #self.lb3phoneone.grid(row=1, column=3)
            #self.Driverrphone.grid(row=1, column=4)

        #else:
            #self.lb3one.grid_remove()
            #self.Driverrentry.grid_remove()
            #self.lb3phoneone.grid_remove()
            #self.Driverrphone.grid_remove()
    
    def clicking_the_postreports(self,event):
       selected_item = self.Post_incident_treee.selection()
       if selected_item:
         # Extract the index of the selected item
         #item_index = self.Table_treep.index(selected_item[0])

         Incident_Number= self.Numberentryy.get()

         open_post_report_details= KBACKEND.fetch_lastpost_reports_and_inserttwo(Incident_Number)

         self.open_postreports_with_clickedrow(open_post_report_details)

    def open_postreports_with_clickedrow(self,open_post_report_details):
      self.post_windowoneclick= tk.Toplevel(self.root)
      self.post_windowoneclick.title("Post Incident Report Form")
      self.post_windowoneclick.geometry("750x350") 
      self.post_windowoneclick.resizable(False,False)

      First_framepost= LabelFrame(self.post_windowoneclick, bd=3, relief=tk.RIDGE,text="Post Incident Reports")
      First_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      First_framepost.place(x=0,y=30,width=700,height=120)
      
      Incident_Number=self.Numberentryy.get()
      I_No=Label(First_framepost, text="Incident_Number:")
      I_No.grid(row=0, column=0,padx=5)
      self.Incidentnumber_entrypostone=ttk.Entry(First_framepost,width=15)
      self.Incidentnumber_entrypostone.grid(row=0,column=1,padx=5)
      self.Incidentnumber_entrypostone.insert(0,Incident_Number)
      self.Incidentnumber_entrypostone.state(['disabled'])

      Date = Label(First_framepost, text="Date:")
      Date.grid(row=0, column=2,padx=5)
      self.datepostoneclick= DateEntry(First_framepost, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
      self.datepostoneclick.grid(row=0, column=3,sticky='w',padx=5)
      if open_post_report_details is not None:
         self.datepostonevalue= open_post_report_details.get("Report_Created")
      else:
         self.datepostonevalue=None
      self.datevalueclick= self.datepostonevalue.date()
      self.datepostoneclick.set_date(self.datevalueclick)
      self.datepostoneclick.state(['disabled'])

      Time= Label(First_framepost,text= "Time:")
      Time.grid(row=0,column=4,padx=5)
      self.timepostoneclick= ttk.Entry(First_framepost,width=15)
      self.timepostoneclick.grid(row=0, column=5,sticky='w',padx=5,pady=8)
      if open_post_report_details is not None:
         self.timepostoneclickvalue= open_post_report_details.get("Report_Created")
      else:
         self.timepostoneclickvalue= None
      self.timevalueclick= self.timepostoneclickvalue.time()
      self.timepostoneclick.insert(0,self.timevalueclick)
      self.timepostoneclick.state(['disabled'])

      
      Createdby= Label(First_framepost,text="Created By")
      Createdby.grid(row=1,column=0,padx=5)
      self.createdbypostoneclick= ttk.Entry(First_framepost)
      self.createdbypostoneclick.grid(row=1,column=1,padx=5)
      if open_post_report_details is not None:
       self.createdbypostoneclickvalue= open_post_report_details.get("Created_By")
      else:
       self.createdbypostoneclickvalue=None
      self.createdbypostoneclick.insert(0,self.createdbypostoneclickvalue)
      self.createdbypostoneclick.state(['disabled'])
      

      Inc= Label(First_framepost, text="Incident_Category:")
      Inc.grid(row=1, column=2,padx=5)
      self.Incpostoneclick= ttk.Entry(First_framepost, width=15)
      self.Incpostoneclick.grid(row=1, column=3,sticky='w')
      if open_post_report_details is not None:
         self.Incpostoneclickvalue=open_post_report_details.get("Inc_Category_ID")
      else:
         self.Incpostoneclickvalue= None
      self.Incpostoneclick.insert(0,self.Incpostoneclickvalue)
      self.Incpostoneclick.state(['disabled'])

      self.linked_postvaroneclick = tk.BooleanVar()
      self.Linkedpostoneclick=ttk.Checkbutton(First_framepost,width=2,variable=self.linked_postvaroneclick)
      self.Linkedpostoneclick.grid(row=1,column=4,sticky='w',padx=3)
      if open_post_report_details is not None:
         self.Linkedpostoneclickvalue= open_post_report_details.get("Linked_Orders")
      else:
         self.Linkedpostoneclickvalue= None
      if self.Linkedpostoneclickvalue=='Y':
         checkbox=True
      else:
         checkbox=False
      self.linked_postvaroneclick.set(checkbox)
      self.Linkedpostoneclick.state(['disabled'])
      Linked_Orders= Label(First_framepost,text="Final Costed")
      Linked_Orders.grid(row=1,column=5,padx=5,pady=5)

      self.catdetailsforpostincidentclickone=KBACKEND.fetch_cat_details()
      self.catdetailspostclickone= [row[1] for row in self.catdetailsforpostincidentclickone]
      lb5 = Label(First_framepost, text="Defect Cat*",fg="red", padx=5,pady=5)
      lb5.grid(row=2, column=0)
      self.Categorypostclickone = ttk.Combobox(First_framepost, values= self.catdetailspostclickone, width=15)
      self.Categorypostclickone.grid(row=2, column=1)
      if open_post_report_details is not None:
         self.Categorypostclickvalueone= open_post_report_details.get("Category")
      else:
         self.Categorypostclickvalueone= None
      self.Categorypostclickone.insert(0,self.Categorypostclickvalueone if self.Categorypostclickvalueone is not None else"")
      self.Categorypostclickone.state(['disabled'])

      self.verdictdetailsoneclick=KBACKEND.fetch_verdict_details()
      self.verdictdetailspostoneclick=[row[1] for row in self.verdictdetailsoneclick]
      lb6 = Label(First_framepost, text="PIR_Verdict*",fg="red", padx=5,pady=5)
      lb6.grid(row=2, column=2)
      self.PIR_verdictoneclick = ttk.Combobox(First_framepost, values= self.verdictdetailspostoneclick, width=13)
      self.PIR_verdictoneclick.grid(row=2, column=3)
      if open_post_report_details is not None:
         self.PIR_verdictoneclickvalue=open_post_report_details.get("Verdict")
      else:
         self.PIR_verdictoneclickvalue=None
      self.PIR_verdictoneclick.insert(0,self.PIR_verdictoneclickvalue if self.PIR_verdictoneclickvalue is not None else"")
      self.PIR_verdictoneclick.state(['disabled'])

      Second_framepost= Frame(self.post_windowoneclick, bd=3, relief=tk.RIDGE)
      Second_framepost.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
      Second_framepost.place(x=0,y=150,width=700,height=180)

      comments= Label(Second_framepost, text="Comments:")
      comments.grid(row=0, column=0,pady=5,sticky='w')
      self.commentspostoneclick= tk.Text(Second_framepost,width=40, height='8',wrap='word')
      self.commentspostoneclick.grid(row=0,column=1,columnspan=2,sticky='w',pady=5)
      if open_post_report_details is not None:
         self.commentspostoneclickvalue= open_post_report_details.get("Comments")
      else:
         self.commentspostoneclickvalue=None
      self.commentspostoneclick.insert("1.0",self.commentspostoneclickvalue)
      self.commentspostoneclick['state']='disabled'

       
    def open_eventspage_with_clickedrow(self,fetch_event_details):
     
     self.event_window= tk.Toplevel(self.root)
     self.event_window.title("Event Detail Form")
     self.event_window.geometry("800x600") 
     self.event_window.resizable(False,False)

     Incident_Eventt= Frame(self.event_window, bd=3, relief=tk.RIDGE)
     Incident_Eventt.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Eventt.place(x=0,y=30,width=600,height=100)

     self.eventsinfo= KBACKEND.fetch_event_types()
     self.eventtypesinformation= [row[1] for row in self.eventsinfo]
     Event_type= Label(Incident_Eventt, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entryy= ttk.Combobox(Incident_Eventt,values=self.eventtypesinformation,width=20)
     self.Event_type_entryy.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.Event_type_value= fetch_event_details.get("Event_Type")
     self.Event_type_entryy.set(self.Event_type_value if self.Event_type_value is not None else"")
     self.Event_type_entryy.state(['disabled'])
     self.attach_context_menu(self.Event_type_entryy)

     self.Event_another_entryy= Entry(Incident_Eventt,width=50,state='disabled')
     self.Event_another_entryy.grid(row=0,column=2,sticky="w")
     self.attach_context_menu(self.Event_another_entryy)

     
     Action_required= Label(Incident_Eventt, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entryy= ttk.Entry(Incident_Eventt,width=30)
     self.Action_required_entryy.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entryyvalue=fetch_event_details.get("Createdby")
     self.Action_required_entryy.insert(0,self.Action_required_entryyvalue if self.Action_required_entryyvalue
                                        is not None else"")
     self.Action_required_entryy.state(['disabled'])
     self.attach_context_menu(self.Action_required_entryy)
     
     Owner= Label(Incident_Eventt, text="Owner")
     Owner.grid(row=2,column=0,padx=5,pady=5)
     self.Owner_entryy= ttk.Entry(Incident_Eventt,width=30)
     self.Owner_entryy.grid(row=2,column=1,sticky="w",padx=5,pady=5)
     self.Ownerentryyvalue= fetch_event_details.get("Owner")
     self.Owner_entryy.insert(0,self.Ownerentryyvalue if self.Ownerentryyvalue is not None else"")
     self.Owner_entryy.state(['disabled'])
     self.attach_context_menu(self.Owner_entryy)

     Created= LabelFrame(self.event_window,bd=3, relief=tk.RIDGE,text="Created")
     Created.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Created.place(x=610,y=30,width=180,height=120)
     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Created, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entryy= DateEntry(Created, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entryy.grid(row=0, column=1,sticky='w')
     self.Date_created_Entryyvalue= fetch_event_details.get("Createddate")
     self.Date_created_date= self.Date_created_Entryyvalue.date()
     self.Date_created_Entryy.set_date(self.Date_created_date if self.Date_created_date is not None else"")
     self.Date_created_Entryy.state(['disabled'])
     self.attach_context_menu(self.Date_created_Entryy)
     #Time
     Time_created= Label(Created,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entryy= ttk.Entry(Created,width=9)
     self.Time_created_entryy.grid(row=1,column=1,sticky="w")
     self.Time_created_entryyvalue= fetch_event_details.get("Createddate")
     self.Time_created_time=self.Time_created_entryyvalue.time()
     self.Time_created_entryy.insert(0,self.Time_created_time if self.Time_created_time is not None else"")
     self.Time_created_entryy.state(['disabled'])
     self.attach_context_menu(self.Time_created_entryy)
     


     Event_text=Frame(self.event_window,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entryy= tk.Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entryy.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.Event_detailsvalue= fetch_event_details.get("Eventtext")
     self.Event_details_entryy.insert("1.0",self.Event_detailsvalue if self.Event_detailsvalue is not None else"")
     self.Event_details_entryy['state'] = 'disabled'
     self.attach_context_menu(self.Event_details_entryy)

     

     


     Next_event= LabelFrame(self.event_window,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)
     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entryy= DateEntry(Next_event, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='yyyy/mm/dd')
     self.Date_nextevent_Entryy.grid(row=0, column=1,sticky='w')
     self.Date_nextevent_Entryyvalue=fetch_event_details.get("Nexteventdate")
     self.Date_nextevent_date= self.Date_nextevent_Entryyvalue.date()
     print(self.Date_nextevent_date)
     self.Date_nextevent_Entryy.set_date(self.Date_nextevent_date if self.Date_nextevent_date is not None else"")
     self.Date_nextevent_Entryy.state(['disabled'])
     self.attach_context_menu(self.Date_nextevent_Entryy)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entryy= Entry(Next_event,width=9)
     self.Time_nextevent_entryy.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Time_nextevent_entryyvalue= fetch_event_details.get("Nexteventdate")
     self.Time_nextevent_time= self.Time_nextevent_entryyvalue.time()
     self.Time_nextevent_entryy.insert(0,self.Time_nextevent_time if self.Time_nextevent_time is not None else"")
     self.Time_nextevent_entryy['state'] = 'disabled'
     self.attach_context_menu(self.Time_nextevent_entryy)

     self.type=KBACKEND.fetch_event_types()
     self.typedetails= [row[1] for row in self.type]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entryy= ttk.Combobox(Next_event,values=self.typedetails,width=20)
     self.Type_nextevent_entryy.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.Typenextevent_value= fetch_event_details.get("Nexteventtype")
     self.Type_nextevent_entryy.state(['disabled'])
     self.Type_nextevent_entryy.set(self.Typenextevent_value if self.Type_nextevent_entryy is not None else"")
     self.attach_context_menu(self.Type_nextevent_entryy)
     
    
     self.Type_another_entryy= ttk.Entry(Next_event,width=40)
     self.Type_another_entryy.grid(row=3,column=2,sticky="w")
     self.Type_another_entryy.state(['disabled'])
     self.attach_context_menu(self.Type_another_entryy)
     

    def populate_events_tree(self):
       incident_number=self.Numberentryy.get()
       event_details=KBACKEND.fetch_all_event_details(incident_number)
       self.eventss_tree.delete(*self.eventss_tree.get_children())
       if event_details:
          for events in event_details:
             Event_created= events.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= events.get('Notes')
             Last_updated= events.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= events.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= events.get('Event_Description')
             Next_Event_Description= events.get('Next_Event_Description')
             C_By= events.get('Created_By')
             Own= events.get('Owner')


             self.eventss_tree.insert("", "end", values=(Created_date,Created_time,C_By,Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,Own,Follow_up_date,follow_up_time,Own,Next_Event_Description))
        
    

    def populate_location_descriptionn(self, event=None):
        selected_location = self.locationn_1.get()
        rows = KBACKEND.fetch_locations_and_descriptions()
        for row in rows:
            if row[0] == selected_location:
                self.locationn_2.delete(0, tk.END)
                self.locationn_2.insert(0, row[1])
                break
    def populate_supplier_detailss(self,event=None):
        selected_supplier= self.Contactentryy.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.nameentryy.delete(0,tk.END)
              self.Phoneentryy.delete(0,tk.END)
              self.nameentryy.insert(0,row[0])
              self.Phoneentryy.insert(0,row[2])
    def populate_supplier_details_two(self,event=None):
       selected_supplierno=self.nameentryy.get()
       rows=KBACKEND.fetch_supplier_details()
       for row in rows:
          if row[0]==selected_supplierno:
             self.Contactentryy.delete(0,tk.END)
             self.Phoneentryy.delete(0,tk.END)
             self.Contactentryy.insert(0,row[1])
             self.Phoneentryy.insert(0,row[2])     

    def open_Purchase_order_From_mainpage(self):
        self.save_the_incident_details()
        self.purchasehistoryone = tk.Toplevel(self.root)
        self.purchasehistoryone.title("Maintenance Control")
        self.purchasehistoryone.geometry("800x615")  # Adjust the width and height as needed
        self.purchasehistoryone.resizable(False, False)

        icon_box = tk.Frame(self.purchasehistoryone, relief=tk.RIDGE, borderwidth=3)
        icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

        image_paths = ["icon 18.png", "icon 19.png"]
        for idpurcost, path in enumerate(image_paths, start=1):
            image = Image.open(path)
            image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
            photo = ImageTk.PhotoImage(image)
            icon_button = tk.Button(icon_box, image=photo, command=lambda index=idpurcost: self.update_purchase_information(index))
            icon_button.image = photo
            icon_button.pack(side=tk.LEFT, padx=5, pady=2)
        
        # Create frames for each page
        self.Historypone = Frame(self.purchasehistoryone)
        self.Maintenance_Controlpone = Frame(self.purchasehistoryone)

        def show_History():
            self.Maintenance_Controlpone.pack_forget()
            self.Historypone.pack(fill="both", expand=True)

        def show_maintenance():
            self.Maintenance_Controlpone.pack(fill="both", expand=True)
            self.Historypone.pack_forget()

        show_History()

        # Creating Buttons Frame for second page
        Buttonframe = Frame(self.purchasehistoryone, relief=tk.RIDGE)
        Buttonframe.place(x=0, y=27, width=780, height=40)

        # Create buttons
        hist_button = tk.Button(Buttonframe, text="History", command=show_History)
        hist_button.pack(side=tk.LEFT, padx=1, pady=2)

        maintain_button = tk.Button(Buttonframe, text="Maintenance Control", command=show_maintenance)
        maintain_button.pack(side=tk.LEFT, padx=1, pady=2)

        dataframe = Label(self.Historypone, bd=3, relief=tk.RIDGE)
        dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
        dataframe.place(x=0, y=29, width=780, height=180) 

        scrollbar_x = ttk.Scrollbar(dataframe, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(dataframe, orient=VERTICAL)

        self.costlinestableone = ttk.Treeview(dataframe, column=("Repaired", "Odometer", "Supplier_Name",
                                                             "Incident_Link", "Total_Parts_Cost", 
                                                            "Total_Recharge","Approval"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        self.costlinestableone.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.costlinestableone.xview)
        scrollbar_y.config(command=self.costlinestableone.yview)

        # Set column headings
        self.costlinestableone.heading("Repaired", text="Repaired")
        self.costlinestableone.heading("Odometer", text="Odometer")
        self.costlinestableone.heading("Supplier_Name", text="Supplier_Name")
        self.costlinestableone.heading("Incident_Link", text="Incident_Link")
        self.costlinestableone.heading("Total_Parts_Cost", text="Total_Parts_Cost")
        self.costlinestableone.heading("Total_Recharge", text="Total_Recharge")
        self.costlinestableone.heading("Approval", text="Approval")

        # Set Treeview to display column headings only
        self.costlinestableone["show"] = "headings"

        # Set column widths
        self.costlinestableone.column("Repaired", width=80)
        self.costlinestableone.column("Odometer", width=70)
        self.costlinestableone.column("Supplier_Name", width=80)
        self.costlinestableone.column("Incident_Link", width=90)
        self.costlinestableone.column("Total_Parts_Cost", width=90)
        self.costlinestableone.column("Total_Recharge", width=90)
        self.costlinestableone.column("Approval", width=80)
        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.costlinestableone.pack(side=LEFT, fill=BOTH, expand=True)
        self.costlinestableone.bind("<ButtonRelease-1>", self.onclick_for_purchaseorder_tableone)
        self.populate_top_purchase_order_two()

        self.Approvalframepone = tk.Frame(self.purchasehistoryone, bd=3, relief=tk.RIDGE)
        self.Approvalframepone.place(x=0, y=250, width=780, height=150)

        # Creating frame for the 3 buttons
        self.Approval_Issuepone = tk.Frame(self.Approvalframepone)
        self.Invoice_Detailspone = tk.Frame(self.Approvalframepone)
        self.Misccpone = tk.Frame(self.Approvalframepone)
        
        # Function to show approval page
        def show_Approval():
            self.Approval_Issuepone.place(x=0, y=40, width=780, height=110)
            self.Invoice_Detailspone.place_forget()
            self.Misccpone.place_forget()
        
        # Function to show invoice details page
        def show_Invoice_Details():
            self.Approval_Issuepone.place_forget()
            self.Invoice_Detailspone.place(x=0, y=40, width=780, height=110)
            self.Misccpone.place_forget()
        
        # Function to show misc page
        def show_Miscc():
            self.Approval_Issuepone.place_forget()
            self.Invoice_Detailspone.place_forget()
            self.Misccpone.place(x=0, y=40, width=780, height=110)
        
        show_Approval()
        
        # Creating Buttons Frame for second page
        Buttonframe = tk.Frame(self.Approvalframepone, relief=tk.RIDGE)
        Buttonframe.place(x=0, y=8, width=780, height=30)
        
        # Create buttons
        Approval_button = tk.Button(Buttonframe, text="Approval Issue", command=show_Approval)
        Approval_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        Invoice_details_button = tk.Button(Buttonframe, text="Invoice Details", command=show_Invoice_Details)
        Invoice_details_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        Miscc_button = tk.Button(Buttonframe, text="Misc", command=show_Miscc)
        Miscc_button.pack(side=tk.LEFT, padx=1, pady=2)
        
        # Creating data frame for Approval Issue
        Repairerdataframe = tk.Frame(self.Approval_Issuepone, bd=3, relief=tk.RIDGE)
        Repairerdataframe.place(x=0, y=0, width=765, height=100)
        
        # Creating data frame for Invoice Details
        Invoicedataframe = tk.Frame(self.Invoice_Detailspone, bd=3, relief=tk.RIDGE)
        Invoicedataframe.place(x=0, y=0, width=765, height=100)


        incident_number=self.Numberentryy.get()

        purchase_details= KBACKEND.insert_purchase_details(incident_number)

        #Creating a label and combobox entry for Repairer 
        sup=KBACKEND.fetch_supplier_details()
        self.supplierpname = [row[1] for row in sup]
        Repairer= Label(Repairerdataframe, text="Supplier Name:")
        Repairer.grid(row=0,column=0,padx=5,pady=5)
        insert_supplier=self.Contactentryy.get()
        self.Repairerentrypone= ttk.Combobox(Repairerdataframe,values=self.supplierpname,width=20)
        self.Repairerentrypone.grid(row=0,column=1,sticky="w",padx=5,pady=5)
        self.Repairerentrypone.insert(0, insert_supplier if insert_supplier is not None else "")
        self.attach_context_menu(self.Repairerentrypone)
        self.Repairerentrypone.bind("<KeyRelease>", self.filter_supplier_list_four)
        self.Repairerentrypone.bind("<<ComboboxSelected>>", self.populate_supplier_detailspinsert)

        Account= Label(Repairerdataframe, text="Account:")
        Account.grid(row=0,column=2,padx=5,pady=5)
        self.Accountentrypone= ttk.Entry(Repairerdataframe,width=20)
        self.Accountentrypone.grid(row=0,column=3,sticky="w",padx=5,pady=5)
        self.attach_context_menu(self.Accountentrypone)
        self.populate_supplier_detailspinsert()

        Approval= Label(Repairerdataframe,text="Approval:")
        Approval.grid(row=0,column=4,padx=5,pady=5)
        self.Approvalentrypone= ttk.Entry(Repairerdataframe,width= 20)
        self.Approvalentrypone.grid(row=0,column=5,sticky="w",padx=5,pady=3)
        Approval_Number= KBACKEND.generate_purchase_order_number()
        if purchase_details is not None:
           self.Approvalentryponevalue= purchase_details.get('PO_Number')
        else:
           self.Approvalentryponevalue= None
        self.Approvalentrypone.insert(0,self.Approvalentryponevalue if self.Approvalentryponevalue is not None else Approval_Number)
        self.attach_context_menu(self.Approvalentrypone)
        self.Approvalentrypone.state(['disabled'])

        Issued = Label(Repairerdataframe, text="Issued:")
        Issued.grid(row=1, column=0,padx=5,pady=5)
        self.Issuedentrypone= DateEntry(Repairerdataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.Issuedentrypone.grid(row=1, column=1,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
           self.Issuedentryponevalue= purchase_details.get('PO_Created')
        else:
           self.Issuedentryponevalue= None
        self.Issuedentrypone.set_date(self.Issuedentryponevalue if self.Issuedentryponevalue is not None else None)
        self.attach_context_menu(self.Issuedentrypone)
        
        current_user=getuser()
        Po_created= Label(Repairerdataframe,text="Created_By:")
        Po_created.grid(row=1,column=2,padx=5,pady=5)
        self.Po_createdbyone= ttk.Entry(Repairerdataframe,width=20)
        self.Po_createdbyone.grid(row=1,column=3,padx=5,pady=5)
        if purchase_details is not None:
           self.Po_createdbyonevalue= purchase_details.get('Created_By')
        else:
           self.Po_createdbyonevalue= None
        self.Po_createdbyone.insert(0, self.Po_createdbyonevalue if self.Po_createdbyonevalue is not None else current_user)
        self.attach_context_menu(self.Po_createdbyone)
        self.Po_createdbyone.state(['disabled'])
        
        fleet_entry=self.fleett.get()
        Fleet_Number=Label(Repairerdataframe, text="Fleet_No:")
        Fleet_Number.grid(row=1,column=4,padx=5,pady=5)
        self.fleetnumbercostone= Entry(Repairerdataframe,width=20)
        self.fleetnumbercostone.grid(row=1,column=5,padx=5,pady=5)
        if purchase_details is not None:
           self.fleetnumbercostonevalue= purchase_details.get('Fleet_No')
        else:
           self.fleetnumbercostonevalue= None
        self.fleetnumbercostone.insert(0,self.fleetnumbercostonevalue if self.fleetnumbercostonevalue is not None else fleet_entry)
        self.attach_context_menu(self.fleetnumbercostone)

        #Creating a Label and Entry for Odometer
        Odoentry=self.Odoentry.get()
        Odometer= Label(Repairerdataframe,text="Odometer:")
        Odometer.grid(row=2,column=0,padx=5,pady=5)
        self.Odometerentrypone= ttk.Entry(Repairerdataframe,width= 20)
        self.Odometerentrypone.grid(row=2,column=1,padx=5,pady=5,sticky="w")
        if purchase_details is not None:
           self.Odometerentryponevalue= purchase_details.get('Odometer')
        else:
           self.Odometerentryponevalue= None
        self.Odometerentrypone.insert(0,self.Odometerentryponevalue if self.Odometerentryponevalue is not None else Odoentry)
        self.attach_context_menu(self.Odometerentrypone)
        self.Odometerentrypone.state(['disabled'])


        #Creating a Label and Entry for Repaired:
        Repaired = Label(Repairerdataframe, text="Repaired:")
        Repaired.grid(row=2, column=2,padx=5,pady=5)
        self.Repairedentrypone= DateEntry(Repairerdataframe, width=10, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
        self.Repairedentrypone.grid(row=2, column=3,padx=5,pady=5,sticky='w')
        self.Repairerentryponevalue = purchase_details.get('Purchase_Date') if purchase_details else None

        # Convert the date string to a datetime object if it is not empty
        try:
         if self.Repairerentryponevalue:
          self.Repairerentryponevalue = datetime.strptime(self.Repairerentryponevalue, "%Y-%m-%d").date()
         else:
          self.Repairerentryponevalue = None
        except ValueError:
         self.Repairerentryponevalue = None  # or handle the error as needed

        # Set the date in the DateEntry widget
        if self.Repairerentryponevalue:
         self.Repairedentrypone.set_date(self.Repairerentryponevalue)
        else:
         self.Repairedentrypone.set_date(None)

        Order_Category= Label(Repairerdataframe,text="Order_Category")
        Order_Category.grid(row=2,column=4,padx=5,pady=5,sticky='w')
        self.Order_catone= Entry(Repairerdataframe,width=20)
        if purchase_details is not None:
           self.Order_catonevalue=purchase_details.get('Order_Category')
        else:
           self.Order_catonevalue = None
        self.Order_catone.grid(row=2,column=5,padx=5,pady=5,sticky='w')
        self.Order_catone.insert(0, self.Order_catonevalue if self.Order_catonevalue is not None else"")
        self.attach_context_menu(self.Order_catone)

        #Creating fields for the Invoice details dataframe

        Customer_Po= Label(Invoicedataframe,text="Customer Po:")
        Customer_Po.grid(row=0,column=0,padx=5,pady=5,sticky='w')
        self.Customer_Ponumone= Entry(Invoicedataframe,width=20)
        self.Customer_Ponumone.grid(row=0,column=1,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
           self.Customer_Ponumonevalue= purchase_details.get('Customer_PO')
        else:
           self.Customer_Ponumonevalue= None
        self.Customer_Ponumone.insert(0,self.Customer_Ponumonevalue if self.Customer_Ponumonevalue is not None else"")
        self.attach_context_menu(self.Customer_Ponumone)

        kofax= Label(Invoicedataframe,text="Kofax Scan_No:")
        kofax.grid(row=0,column=2,padx=5,pady=5,sticky='w')
        self.Kofaxnoone= Entry(Invoicedataframe,width=20)
        self.Kofaxnoone.grid(row=0,column=3,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
           self.Kofaxnoonevalue= purchase_details.get('Kofax_Scan_No')
        else:
           self.Kofaxnoonevalue= None
        self.Kofaxnoone.insert(0,self.Kofaxnoonevalue if self.Kofaxnoonevalue is not None else"")
        self.attach_context_menu(self.Kofaxnoone)

        Igloo= Label(Invoicedataframe,text="Igloo Invoice_No:")
        Igloo.grid(row=0,column=4,padx=5,pady=5,sticky='w')
        self.Igloonoone= Entry(Invoicedataframe,width=20)
        self.Igloonoone.grid(row=0,column=5,padx=5,pady=5,sticky='w')
        if purchase_details is not None:
           self.Igloonoonevalue=purchase_details.get('Igloo_Invoice_No')
        else:
           self.Igloonoonevalue=None
        self.Igloonoone.insert(0,self.Igloonoonevalue if self.Igloonoonevalue is not None else"")
        self.attach_context_menu(self.Igloonoone)

        Tableone= Frame(self.purchasehistoryone, bd=3,relief=tk.RIDGE)
        Tableone.place(x=0,y=400,width=780,height=140)

        scrollbar_x = ttk.Scrollbar(Tableone, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(Tableone, orient=VERTICAL)

        self.Table_treepone = ttk.Treeview(Tableone, columns=("Types", "Category","Products", "Parts_Cost", "Labour_Cost", "Total_Cost", "Rech_Parts","Rech_Labour" ,"Total_Recharge"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        
        self.Table_treepone.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.Table_treepone.xview)
        scrollbar_y.config(command=self.Table_treepone.yview)

        

        self.Table_treepone.heading("Types", text="Types")
        self.Table_treepone.heading("Category", text="Category")
        self.Table_treepone.heading("Products", text="Products")
        self.Table_treepone.heading("Parts_Cost", text="Parts_Cost")
        self.Table_treepone.heading("Labour_Cost", text="Labour_Cost")
        self.Table_treepone.heading("Total_Cost",text="Total_Cost")
        self.Table_treepone.heading("Rech_Parts", text="Rech_Parts")
        self.Table_treepone.heading("Rech_Labour", text="Rech_Labour")
        self.Table_treepone.heading("Total_Recharge", text="Total_Recharge")

        self.Table_treepone["show"] = "headings"
    
        self.Table_treepone.column("Types", width=90)
        self.Table_treepone.column("Category", width=90)
        self.Table_treepone.column("Products", width=90)
        self.Table_treepone.column("Parts_Cost", width=90)
        self.Table_treepone.column("Labour_Cost", width=90)
        self.Table_treepone.column("Total_Cost", width=90)
        self.Table_treepone.column("Rech_Parts", width=90)
        self.Table_treepone.column("Rech_Labour", width=90)
        self.Table_treepone.column("Total_Recharge", width=90)

        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.Table_treepone.pack(fill="both", expand=True)
        self.populate_all_the_costlines_two()
        
        self.Table_treepone.bind("<<TreeviewSelect>>", self.clicking_the_costlinestwo)

        Addcostline= Frame(self.purchasehistoryone, bd=3,relief=tk.RIDGE)
        Addcostline.place(x=0,y=540,width=780,height=50)

        Invoice_details_button = tk.Button(Addcostline, text="Add Costline",command= self.add_costline_two)
        Invoice_details_button.pack(side=tk.RIGHT, padx=1, pady=2)

        Maindataframemaintainence= Frame(self.Maintenance_Controlpone,bd=3, relief=tk.RIDGE)
        Maindataframemaintainence.pack(side=tk.TOP,padx=8,pady=3, anchor='nw')
        Maindataframemaintainence.place(x=0,y=33,width=780,height=65)

        reg_entry=self.reistrationentry.get()
        Reg_no= Label(Maindataframemaintainence,text="Reg_no:")
        Reg_no.grid(row=0,column=0)
        self.Reg_no_entrypone = Entry(Maindataframemaintainence, width=30)
        self.Reg_no_entrypone.grid(row=0, column=1)
        self.Reg_no_entrypone.insert(0,reg_entry if reg_entry is not None else"")
        self.attach_context_menu(self.Reg_no_entrypone)

        Vehicle= self.Make_Mod.get()
        Vehicle_main= Label(Maindataframemaintainence,text= "Vehicle:")
        Vehicle_main.grid(row=0,column=2)
        self.Vehicle_main_entrypone= Entry(Maindataframemaintainence,width=35)
        self.Vehicle_main_entrypone.grid(row=0,column=3,sticky='w')
        self.Vehicle_main_entrypone.insert(0,Vehicle if Vehicle is not None else"")
        self.attach_context_menu(self.Vehicle_main_entrypone)

        Agreementframe= Frame(self.Maintenance_Controlpone,bd=3, relief=tk.RIDGE)
        Agreementframe.pack(side=tk.TOP,padx=8,pady=3, anchor='nw')
        Agreementframe.place(x=0,y=98,width=780,height=70)

         #Create Label and entry for Agreement inside the dataframe
        Contract_number=self.Contract_No_Entryy.get()
        Agreement= Label(Agreementframe,text="Agreement:")
        Agreement.grid(row=0,column=0,padx=5,pady=5)
        self.Agreemententrypone= Entry(Agreementframe,width=30)
        self.Agreemententrypone.grid(row=0,column=1,padx=5,pady=5)
        self.Agreemententrypone.insert(0,Contract_number if Contract_number is not None else"")
        self.attach_context_menu(self.Agreemententrypone)

        #Create Label and entry for Customer
        Customer_name= self.Cust_Namee_Entry.get()
        Customer= Label(Agreementframe,text="Customer:")
        Customer.grid(row=0,column=2,padx=5,pady=5)
        self.Customerentrypone= Entry(Agreementframe,width=50)
        self.Customerentrypone.grid(row=0, column=3, padx=5, pady=5)
        self.Customerentrypone.insert(0,Customer_name if Customer_name is not None else"")
        self.attach_context_menu(self.Customerentrypone)
    
    def filter_supplier_list_four(self, event):
        # Function to filter supplier list based on user input
        current_text = self.Repairerentrypone.get()
        if current_text == '':
            self.Repairerentrypone['values'] = self.supplierpname
        else:
            filtered_suppliers = [supplier for supplier in self.supplierpname if current_text.lower() in supplier.lower()]
            self.Repairerentrypone['values'] = filtered_suppliers

    def add_costline_two(self):
     self.update_the_information()
     self.costline_windowone = tk.Toplevel(self.root)
     self.costline_windowone.title("Cost Line Form")
     self.costline_windowone.geometry("800x620") 
     self.costline_windowone.resizable(False,False)

     #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_windowone, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

         # You can add icons below menus using PhotoImage or other methods.
        # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png", "icon24.png"]
     for idcostone, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcostone: self.costline_icons_two(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)

         dataframe = Frame(self.costline_windowone, bd=3, relief=tk.RIDGE)
         dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
         dataframe.place(x=0, y=35, width=780, height=90)

         Reg_details= self.Reg_no_entrypone.get()
         Reg_no = Label(dataframe, text="Registration No:")
         Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.costlineregone = Entry(dataframe,width=18)
     self.costlineregone.grid(row=0, column=1,padx=10,pady=3)
     self.costlineregone.insert(0,Reg_details)
     self.attach_context_menu(self.costlineregone)
     
     Repairer_name=self.Repairerentrypone.get()
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=2)
     self.costlinerepone = Entry(dataframe, width=18)
     self.costlinerepone.grid(row=0, column=3,padx=10,pady=3)
     self.costlinerepone.insert(0,Repairer_name)
     self.attach_context_menu(self.costlinerepone)
     
     System_number= self.Approvalentrypone.get()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=4)
     self.systemcostone = ttk.Entry(dataframe, width=18)
     self.systemcostone.grid(row=0, column=5,padx=10,pady=3)
     self.systemcostone.insert(0,System_number)
     self.attach_context_menu(self.systemcostone)
     self.systemcostone.state(['disabled'])
     
     Ododetails=self.Odometerentrypone.get()
     Odometerveh = Label(dataframe, text="Vehicle Odometer:")
     Odometerveh.grid(row=1, column=0,pady=5)
     self.odovehcostone = ttk.Entry(dataframe, width=18)
     self.odovehcostone.grid(row=1, column=1)
     self.odovehcostone.insert(0,Ododetails)
     self.attach_context_menu(self.odovehcostone)
     self.odovehcostone.state(['disabled'])
     
     Repairer_accountdetails= self.Accountentrypone.get()
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=1, column=2,pady=5)
     self.repaccocostone = Entry(dataframe, width=18)
     self.repaccocostone.grid(row=1, column=3)
     self.repaccocostone.insert(0,Repairer_accountdetails)
     self.attach_context_menu(self.repaccocostone)

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=1,column=4)
     self.Line_createdentryone=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentryone.grid(row=1,column=5)
     self.Line_createdentryone.state(['disabled'])

     current_user=getuser()
     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=2,column=0)
     self.Line_createdbyone= ttk.Entry(dataframe,width=18)
     self.Line_createdbyone.grid(row=2,column=1)
     self.Line_createdbyone.insert(0,current_user)
     self.Line_createdbyone.state(['disabled'])

     Seconddataframe = Frame(self.costline_windowone, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=125, width=780, height=70)

     Reason = Label(Seconddataframe, text="Types:")
     Reason.grid(row=0, column=0)

     Po_Types = KBACKEND.Fetch_PO_Types()
     formatted_data = [f"{row[0]} - {row[1]}" for row in Po_Types]
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Reasoncosttypesone = ttk.Combobox(Seconddataframe,width=20,values=formatted_data)
     self.Reasoncosttypesone.grid(row=0, column=1,padx=15,pady=3)
     self.attach_context_menu(self.Reasoncosttypesone)
     self.Reasoncosttypesone.bind("<<ComboboxSelected>>", self.update_rtscostcategoryone)

     RTS = Label(Seconddataframe, text="Category")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategoryone = ttk.Combobox(Seconddataframe,width=20)
     self.rtscostcategoryone.grid(row=0, column=3,padx=10,pady=3)
     self.attach_context_menu(self.rtscostcategoryone)
     self.rtscostcategoryone.bind("<<ComboboxSelected>>", self.update_rtscostproductsone)
     self.rtscostcategoryone.bind("<KeyRelease>",self.filter_rts_categoryone)
     

     category_label = tk.Label(Seconddataframe, text="Products:")
     category_label.grid(row=0, column=4)

     self.category_costoneproducts = ttk.Combobox(Seconddataframe, width=20)
     self.category_costoneproducts.grid(row=0, column=5, padx=15, pady=3)
     self.category_costoneproducts.bind("<KeyRelease>",self.filter_rts_productsone)
     self.attach_context_menu(self.category_costoneproducts)
     
     Pfdepot= self.locationn_2.get()
     rowss = KBACKEND.fetch_locations_and_descriptions()
     self.depotdetailsone = [row[1] for row in rowss]  # First column values for dropdown
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscostone = ttk.Combobox(Seconddataframe, width=18,values=self.depotdetailsone)
     self.analysiscostone.grid(row=1, column=1)
     self.analysiscostone.insert(0,Pfdepot)
     self.analysiscostone.bind("<<ComboboxSelected>>", self.on_depot_selectedone)
     self.attach_context_menu(self.analysiscostone)

     Thirddataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=195, width=780, height=50)
     
     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscostone = Entry(Thirddataframe,width=13)
     self.Partscostone.grid(row=0, column=1,padx=15,pady=3)
     self.Partscostone.insert(0,"0.00")
     self.Partscostone.bind("<KeyRelease>", self.on_parts_cost_changedone)
     self.attach_context_menu(self.Partscostone)

     Labour_Hours= Label(Thirddataframe,text="Labour Hours:")
     Labour_Hours.grid(row=0,column=2)
     self.Labour_Hoursone= Entry(Thirddataframe,width=13)
     self.Labour_Hoursone.grid(row=0,column=3,padx=15,pady=3)
     self.attach_context_menu(self.Labour_Hoursone)

     Labour_Rate=Label(Thirddataframe,text="Labour Rate")
     Labour_Rate.grid(row=0,column=4)
     self.Labour_Rateone=Entry(Thirddataframe,width=13)
     self.Labour_Rateone.grid(row=0,column=5,padx=15, pady=3)
     self.Labour_Rateone.insert(0,"0.00")
     self.attach_context_menu(self.Labour_Rateone)
                       

     Labour = Label(Thirddataframe, text="Labour Value:")
     Labour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Labourcostone = Entry(Thirddataframe,width=13)
     self.Labourcostone.grid(row=0, column=7,padx=15,pady=3)
     self.Labourcostone.insert(0,"0.00")
     self.attach_context_menu(self.Labourcostone)

     fourthdataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Recharge")
     fourthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fourthdataframe.place(x=0, y=245, width=780, height=80)

     Parts_Uplift=Label(fourthdataframe,text="Parts Uplift")
     Parts_Uplift.grid(row=0,column=0)
     self.Parts_Upliftone= ttk.Entry(fourthdataframe,width=13)
     self.Parts_Upliftone.grid(row=0,column=1,padx=15,pady=3)
     self.Parts_Upliftone.bind("<FocusOut>", self.on_parts_cost_changedone)
     self.Parts_Upliftone.bind("<Double-1>", self.reset_to_originalone) 
     self.attach_context_menu(self.Parts_Upliftone)

     RechParts = Label(fourthdataframe, text="Rech.Parts:")
     RechParts.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechcostone = Entry(fourthdataframe,width=13)
     self.Rechcostone.grid(row=0, column=3,padx=15,pady=3)
     self.Rechcostone.insert(0,"0.00")
     self.Rechcostone.bind("<KeyRelease>", self.on_rechcost_changedone)
     self.attach_context_menu(self.Rechcostone)

     Labour_Uplift= Label(fourthdataframe,text="Labour Uplift")
     Labour_Uplift.grid(row=0,column=4)
     self.Labour_Upliftone= ttk.Entry(fourthdataframe,width=13)
     self.Labour_Upliftone.grid(row=0,column=5,padx=15,pady=3)
     self.Labour_Upliftone.bind("<Double-1>", self.reset_labour_upliftone)
     self.attach_context_menu(self.Labour_Upliftone)

     Rechlabour = Label(fourthdataframe, text="Rech.labour:")
     Rechlabour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechlabcostone = Entry(fourthdataframe,width=11)
     self.Rechlabcostone.grid(row=0, column=7,padx=15,pady=3)
     self.Rechlabcostone.insert(0,"0.00")
     self.attach_context_menu(self.Rechlabcostone)
     #self.Rechlabcostone.bind("<FocusOut>", self.on_rechlabcost_changedone)
     
     self.on_depot_selectedone()
     Rechposted = Label(fourthdataframe, text="Rech.posted:")
     Rechposted.grid(row=1, column=0)
     
     self.rechposted_varone = tk.BooleanVar()
     self.rechposted_valueone = tk.StringVar()
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechpostedcostone = Checkbutton(fourthdataframe,variable=self.rechposted_varone, command=self.toggle_date_entrytwo)
     self.Rechpostedcostone.grid(row=1, column=1,padx=15,pady=3)
     self.attach_context_menu(self.Rechpostedcostone)

     Rechposteddate = Label(fourthdataframe, text="Rech.posted date:")
     Rechposteddate.grid(row=1, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechposteddatecostone = DateEntry(fourthdataframe, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Rechposteddatecostone.grid(row=1, column=3,padx=15,pady=3)
     self.Rechposteddatecostone.set_date(datetime.now().strftime("%d/%m/%Y"))  # Set to a valid date first
     self.Rechposteddatecostone._top_cal.withdraw()  # Hide the calendar popup initially
     self.clear_date_entrytwo()
     self.attach_context_menu(self.Rechposteddatecostone)


     Customerreference = Label(fourthdataframe, text="Customer ref:")
     Customerreference.grid(row=1, column=4)

     self.customerreferencecostone = Entry(fourthdataframe,width=11)
     self.customerreferencecostone.grid(row=1, column=5,padx=15,pady=3)

     fifthdataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=375, width=780, height=115)

     self.notescostone= Text(fifthdataframe,width=80, height='5',wrap='word')
     self.notescostone.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.notescostone)

     Sixthdataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Recharge text")
     Sixthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Sixthdataframe.place(x=0, y=490, width=780, height=115)

     self.rechargecostone= Text(Sixthdataframe,width=80, height='5',wrap='word')
     self.rechargecostone.grid(row=0,column=0,sticky='w',padx=5)
     self.attach_context_menu(self.rechargecostone)

     Seventhdataframe = LabelFrame(self.costline_windowone, bd=3, relief=tk.RIDGE,text="Customer Specifics")
     Seventhdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seventhdataframe.place(x=0, y=325, width=780, height=50)
     
     self.Customer_specificsone=Entry(Seventhdataframe,width=100,fg="Red")
     self.Customer_specificsone.grid(row=0,column=2)

     cust_id=self.Customer_Identryy.get()
     result=KBACKEND.check_customer_specific(cust_id)
     if result:
        self.Customer_specificsone.delete(0, tk.END)
        self.Customer_specificsone.insert(0,result)
     else:
        self.Customer_specificsone.delete(0, tk.END)
        self.Customer_specificsone.insert(0,"CUSTOMER Does not have SPECAL RECHARGE RATES")
    
    def on_recharge_selectedone(self, event=None):
     self.current_selectionone = self.Chargeentryy.get()

    def on_depot_selectedone(self, event=None):
     if self.current_selectionone == "RECHARGE":
        self.update_upliftone()
        self.check_supplier_conditionsone()

    def update_upliftone(self):
     depot_name = self.analysiscostone.get()
     print(f"Depot Name: {depot_name}")
     parts_uplift = KBACKEND.fetch_uplift_forparts(depot_name)
     self.original_uplift_percentageone = parts_uplift
     print(f"Parts Uplift: {parts_uplift}")
     self.Parts_Upliftone.delete(0, tk.END)
     self.Parts_Upliftone.insert(0, f"{parts_uplift}%")
           
            
    def on_parts_cost_changedone(self, event):
     if self.current_selectionone == "RECHARGE":
        try:
            parts_cost = float(self.Partscostone.get())
            parts_uplift_text = self.Parts_Upliftone.get()
            parts_uplift = float(parts_uplift_text.replace('%', ''))
            uplift_amount = parts_cost * (parts_uplift / 100)
            total_cost = parts_cost + uplift_amount
            self.Rechcostone.delete(0, tk.END)
            self.Rechcostone.insert(0, "{:.2f}".format(total_cost))
            self.original_rechcostone = total_cost
        except ValueError:
            pass

    def on_rechcost_changedone(self, event):
     if self.current_selectionone == "RECHARGE":
        try:
            rech_cost = float(self.Rechcostone.get())
            parts_cost = float(self.Partscostone.get())
            if parts_cost > 0:
                uplift_percentage = ((rech_cost - parts_cost) / parts_cost) * 100
                self.Parts_Upliftone.delete(0, tk.END)
                self.Parts_Upliftone.insert(0, "{:.2f}%".format(uplift_percentage))
            else:
                Depot_Name = self.analysiscostone.get()
                print(f"Depot Name: {Depot_Name}")
                parts_uplift = KBACKEND.fetch_uplift_forparts(Depot_Name)
                self.Parts_Upliftone.delete(0, tk.END)
                self.Parts_Upliftone.insert(0, f"{parts_uplift}%")
        except ValueError:
            print("Invalid input for Rechcost or Parts Cost.")
    def reset_to_originalone(self, event):
     self.Parts_Upliftone.delete(0, tk.END)
     self.Parts_Upliftone.insert(0, f"{self.original_uplift_percentageone}%")
    
     self.Rechcostone.delete(0, tk.END)
     self.Rechcostone.insert(0, "{:.2f}".format(self.original_rechcostone))

    def check_supplier_conditionsone(self):
     supplier_name = self.costlinerepone.get()

     if self.current_selectionone == "RECHARGE" and supplier_name == "Petit Forestier Holding":
        self.handle_pp_holding_scenarioone()
     elif self.current_selectionone == "RECHARGE" and supplier_name != "Petit Forestier Holding":
        self.handle_other_supplier_scenarioone()

    def handle_pp_holding_scenarioone(self):
     Depot_Name = self.analysiscostone.get()
     labour_rate = KBACKEND.fetch_labourrate_forlabours(Depot_Name)
     self.Labour_Rateone.delete(0, tk.END)
     self.Labour_Rateone.insert(0, "{:.2f}".format(labour_rate))
     self.Labour_Hoursone.bind("<KeyRelease>", self.calculate_labour_cost_for_pp_holdingone)
     self.original_labour_uplift_percentageone = 0.0
     self.calculate_labour_cost_for_pp_holdingone()
    
    def calculate_labour_cost_for_pp_holdingone(self, event=None):
     try:
        labour_rate = float(self.Labour_Rateone.get())
        labour_hours = float(self.Labour_Hoursone.get())
        labour_cost = labour_rate * labour_hours
        self.Labourcostone.delete(0, tk.END)
        self.Labourcostone.insert(0, "{:.2f}".format(labour_cost))
        self.Rechlabcostone.delete(0, tk.END)
        self.Rechlabcostone.insert(0, "{:.2f}".format(labour_cost))
        self.original_rechlabcostone = labour_cost 
     except ValueError:
        print("Invalid input for labour rate or hours.")

    def handle_other_supplier_scenarioone(self):
     Depot_Name=self.analysiscostone.get()
     labour_uplift = KBACKEND.fetch_labouruplift_forlabours(Depot_Name)
     self.Labour_Upliftone.delete(0, tk.END)
     self.Labour_Upliftone.insert(0, "{:.2f}%".format(labour_uplift))
     self.Labour_Rateone.bind("<KeyRelease>", self.calculate_labour_cost_with_upliftone)
     self.Labour_Hoursone.bind("<KeyRelease>", self.calculate_labour_cost_with_upliftone)
     self.Labour_Upliftone.bind("<FocusOut>", self.calculate_labour_cost_with_upliftone)
     self.original_labour_uplift_percentageone = labour_uplift 
     self.calculate_labour_cost_with_upliftone()

    def calculate_labour_cost_with_upliftone(self, event=None):
     try:
        labour_rate = float(self.Labour_Rateone.get())
        labour_hours = float(self.Labour_Hoursone.get())
        labour_uplift_text = self.Labour_Upliftone.get()
        labour_uplift = float(labour_uplift_text.replace('%', ''))
        labour_cost = labour_rate * labour_hours
        self.Labourcostone.delete(0, tk.END)
        self.Labourcostone.insert(0, "{:.2f}".format(labour_cost))
        uplift_amount = labour_cost * (labour_uplift / 100)
        rech_lab_cost = labour_cost + uplift_amount
        self.Rechlabcostone.delete(0, tk.END)
        self.Rechlabcostone.insert(0, "{:.2f}".format(rech_lab_cost))
        self.original_rechlabcostone = rech_lab_cost
     except ValueError:
        print("Invalid input for labour rate, hours, or uplift.")

    #def on_rechlabcost_changed(self, event):
        #rech_lab_cost = float(self.Rechlabcost.get())
        #labour_cost = float(self.Labourcost.get())
        
        #if labour_cost > 0:
            # Calculate uplift percentage
            #labour_uplift_percentage = ((rech_lab_cost - labour_cost) / labour_cost) * 100
            
            # Update Labour_Uplift entry
            #self.Labour_Uplift.delete(0, tk.END)
            #self.Labour_Uplift.insert(0, "{:.2f}%".format(labour_uplift_percentage))
        #else:
            # If labour cost is 0 or negative, keep Labour_Uplift as is
            #pass

    #def on_rechlabcost_changedone(self, event):
     #if self.current_selectionone == "RECHARGE":
        #supplier_name = self.costlinerepone.get()  # Get the supplier name
        
        #if supplier_name == "Petit Forestier Holding":
            # For "Petit Forestier Holding", just update Rechlabcost without calculating uplift
            #try:
                #rech_lab_cost = float(self.Rechlabcostone.get())
                # Save the original Rechlabcost value if it's being updated
                #self.original_rechlabcostone = rech_lab_cost
                # Update Rechlabcost with the new value
                #self.Rechlabcostone.delete(0, tk.END)
                #self.Rechlabcostone.insert(0, "{:.2f}".format(rech_lab_cost))
                
                # Optional: Clear or set Labour_Uplift to 0% if required
                #self.Labour_Upliftone.delete(0, tk.END)
                #self.Labour_Upliftone.insert(0, "0.00%")
                
            #except ValueError:
                #print("Invalid input for Rechlabcost.")
        
        #else:
            # For other suppliers, calculate uplift based on the new Rechlabcost
            #try:
                #rech_lab_cost = float(self.Rechlabcostone.get())
                #labour_cost = float(self.Labourcostone.get())
                
                # Calculate uplift percentage if labour cost is greater than 0
                #if labour_cost > 0:
                    #uplift_percentage = ((rech_lab_cost - labour_cost) / labour_cost) * 100
                    # Update Labour_Uplift entry
                    #self.Labour_Upliftone.delete(0, tk.END)
                    #self.Labour_Upliftone.insert(0, "{:.2f}%".format(uplift_percentage))
                #else:
                    # Restore original uplift or set it to 0% if invalid
                    #if hasattr(self, 'original_labour_uplift_percentage'):
                        #self.Labour_Upliftone.delete(0, tk.END)
                        #self.Labour_Upliftone.insert(0, f"{self.original_labour_uplift_percentageone}%")
                    #else:
                       # self.Labour_Upliftone.delete(0, tk.END)
                        #self.Labour_Upliftone.insert(0, "0.00%")
                
            #except ValueError:
                #print("Invalid input for Rechlabcost or Labour Cost.")

    #def reset_labour_upliftone(self, event):
     #if hasattr(self, 'original_labour_uplift_percentage'):
        #self.Labour_Upliftone.delete(0, tk.END)
        #self.Labour_Upliftone.insert(0, f"{self.original_labour_uplift_percentageone}%")
     #self.Rechlabcostone.delete(0, tk.END)
     #self.Rechlabcostone.insert(0, "{:.2f}".format(self.original_rechlabcostone))
    
    def reset_labour_upliftone(self, event):
     # Resetting Labour_Upliftone to the original uplift percentage
     if hasattr(self, 'original_labour_uplift_percentageone'):
        self.Labour_Upliftone.delete(0, tk.END)
        self.Labour_Upliftone.insert(0, f"{self.original_labour_uplift_percentageone:.2f}%")
     else:
        print("original_labour_uplift_percentageone not set or not available.")

     # Resetting Rechlabcostone to the original value
     if hasattr(self, 'original_rechlabcostone'):
         self.Rechlabcostone.delete(0, tk.END)
         self.Rechlabcostone.insert(0, "{:.2f}".format(self.original_rechlabcostone))
     else:
        print("original_rechlabcostone not set or not available.")
   

    








    
    def update_rtscostcategoryone(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.Reasoncosttypesone.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        type_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        self.categoriesone = KBACKEND.Fetch_Categories_By_Type(type_id)
        
        # Format data for the dropdown
        self.formatted_categoriesone = [f"{row[1]} - {row[2]}" for row in self.categoriesone]

        # Update rtscostcategory dropdown with the new data
        self.rtscostcategoryone['values'] = self.formatted_categoriesone
        #if formatted_categories:
            #self.rtscostcategory.current(0) 
    
    def update_rtscostproductsone(self, event):
        # Get the selected value from Reasoncosttypes
        selected_type = self.rtscostcategoryone.get()
        if not selected_type:
            return
        
        # Extract the type ID from the selected value
        category_id = selected_type.split(' - ')[0]  # Assuming type_id is the first part
        
        # Fetch categories based on selected type_id
        self.categoriesproone = KBACKEND.Fetch_Products_By_Category(category_id)
        
        # Format data for the dropdown
        self.formatted_categoriesproone = [f"{row[1]} - {row[2]}" for row in self.categoriesproone]

        # Update rtscostcategory dropdown with the new data
        self.category_costoneproducts['values'] = self.formatted_categoriesproone
        #if formatted_categories:
            #self.category_cost.current(0) 
    def filter_rts_categoryone(self,event):
       current_text = self.rtscostcategoryone.get()
       if current_text == '':
            self.rtscostcategoryone['values'] = self.formatted_categoriesone
       else:
            filtered_category = [category for category in self.formatted_categoriesone if current_text.lower() in category.lower()]
            self.rtscostcategoryone['values'] = filtered_category

    def filter_rts_productsone(self,event):
       current_text = self.category_costoneproducts.get()
       if current_text == '':
            self.category_costoneproducts['values'] = self.formatted_categoriesproone
       else:
            filtered_category = [product for product in self.formatted_categoriesproone if current_text.lower() in product.lower()]
            self.category_costoneproducts['values'] = filtered_category

    
    def clear_date_entrytwo(self):
        # Clear the displayed date in the DateEntry widget
        self.Rechposteddatecostone.delete(0, "end")
    
    def toggle_date_entrytwo(self):
        if self.rechposted_varone.get():
            self.Rechposteddatecostone.set_date(datetime.now().strftime("%d/%m/%Y"))
            self.rechposted_valueone.set("Y")
        else:
           self.clear_date_entrytwo()
           self.rechposted_valueone.set("N")
       
    def update_purchase_information(self,index):
       if index==1:
          self.Close_the_purchase_window()
       if index==2:
          self.update_the_information()
    
    def Close_the_purchase_window(self):
       self.purchasehistoryone.destroy()
    
    def update_the_information(self):
        PO_Number=self.Approvalentrypone.get()
        i_number= self.Numberentryy.get()
        # Getting the selected date from the DateEntry widget
        Pocreated_date = self.Issuedentrypone.get_date()
    
        # Getting the current time
        current_time = datetime.now().time()
    
        # Combining selected date and current time into a datetime object
        combined_datetime = datetime.combine(Pocreated_date, current_time)

        Created_By= self.Po_createdbyone.get()

        Supplier_No= self.Accountentrypone.get()

        Order_Category= self.Order_catone.get()

        Fleet_No= self.fleetnumbercostone.get()

        Odometer= self.Odometerentrypone.get()

        Customer_PO= self.Customer_Ponumone.get()

       
        Kofax_Scan= self.Kofaxnoone.get()

        Igloo_invoice=self.Igloonoone.get()

        Supplier_Name=self.Repairerentrypone.get()

        Repaired_Date=self.Repairedentrypone.get_date()

        Time= datetime.now().time()

        Repaired_Datetime= datetime.combine(Repaired_Date,Time)

        KBACKEND.update_the_purchase_orderinfo(PO_Number,i_number,combined_datetime,Created_By,Supplier_No,
                                              Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,Supplier_Name,Repaired_Datetime)        
    def costline_icons_two(self,index):
       if index==1:
          self.close_the_costline_window()
       if index==2:
          self.save_the_costlines_two()
    def get_combined_datetime_two(self):
        if not self.rechposted_varone.get():
            return None  # Return None if the checkbutton is not checked
        
        # Proceed with date retrieval and combination
        date = self.Rechposteddatecostone.get_date()
        current_time = datetime.now().time()
        combined_datetime = datetime.combine(date, current_time)
        return combined_datetime
    
    def close_the_costline_window(self):
       self.costline_windowone.destroy()
    def save_the_costlines_two(self):
       PO_Number=self.systemcostone.get()
       KBACKEND.generate_line_number(PO_Number)
       Line_Added= self.Line_createdentryone.get_date()
       Time= datetime.now().time()

       bothdateandtime= datetime.combine(Line_Added, Time)
       Added_By=self.Line_createdbyone.get()
       #RTS_code= self.Reasoncostone.get()
       #RTS_Desc=self.rtscostone.get()
       Type=self.Reasoncosttypesone.get()
       if Type:
          type_id=Type.split(' - ')[0]
       else:
          type_id=None
       Category=self.rtscostcategoryone.get()
       if Category:
          Category_id= Category.split(' - ')[0]
       else:
          Category_id=None
       Products=self.category_costoneproducts.get()
       if Products:
          Product_id=Products.split(' - ')[0]
       else:
          Product_id=None
       PF_Depot=self.analysiscostone.get()
       Parts_Cost=self.Partscostone.get()
       Labour_Hours=self.Labour_Hoursone.get()
       Labour_Rate=self.Labour_Rateone.get()
       Labour_cost=self.Labourcostone.get()
       Parts_Uplift=self.Parts_Upliftone.get()
       Labour_Uplift=self.Labour_Upliftone.get()
       Recharge_parts=self.Rechcostone.get()
       Recharge_cost=self.Rechlabcostone.get()
       Recharge_invoiced=self.rechposted_valueone.get()       
       combined_datetime = self.get_combined_datetime_two()
       Notes=self.notescostone.get("1.0", tk.END)
       Recharge_text= self.rechargecostone.get("1.0", tk.END)

       KBACKEND.store_cost_lines_two(PO_Number,bothdateandtime,Added_By,PF_Depot,Parts_Cost,Labour_Hours,
                                 Labour_Rate,Labour_cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_cost,Recharge_invoiced,combined_datetime,
                                 Notes,Recharge_text,type_id,Category_id,Product_id)
       
       self.Table_treepone.delete(*self.Table_treepone.get_children())

       Approval_number= self.Approvalentrypone.get()

       Costlines= KBACKEND.populate_costlines(Approval_number)

       if Costlines:
          for incident in Costlines:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel


             self.Table_treepone.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
       self.populate_all_the_costlines_two()

       Insert_purchase= KBACKEND.retrieve_last_purchase_and_populate(Approval_number)

       self.costlinestableone.delete(*self.costlinestableone.get_children())

       if Insert_purchase:
          for Purchase in Insert_purchase:
            Repaired= Purchase.get("Repaired")
            if Repaired is not None:
             Repaired_date = Repaired.date()
            else:
             print("Repaired is None, cannot access 'date' attribute.")
            Repaired_date = None  # or some default value           
            Odometer=Purchase.get("Odometer")
            Supplier_Name= Purchase.get("Supplier")
            Incident_Link= Purchase.get("Incident_Link")
            Total_Parts=Purchase.get("Total_parts")
            Total_labours=Purchase.get("Total_labours")
            Total_cost= Total_Parts + Total_labours
            Recharge_parts= Purchase.get("Recharge_parts")
            Recharge_labours= Purchase.get("Recharge_labours")
            Total_Recharge= Recharge_parts+ Recharge_labours
            PO_number= Purchase.get("Approval")

            self.costlinestableone.insert("", "end", values=(Repaired_date,Odometer,Supplier_Name,Incident_Link,
                                                         Total_cost,Total_Recharge,PO_number))
       self.populate_top_purchase_order_two()
       
    def onclick_for_purchaseorder_tableone(self,event):
       item = self.costlinestableone.identify_row(event.y)
       print("Clicked on item:", item)
    
      
    
       # Check if item is valid
       if item:
         # Set focus to the clicked row
         self.costlinestableone.focus(item)

       # Get the values from the clicked row
       values = self.costlinestableone.item(item, "values")

       

        # Check if the values list has at least 7 elements
       if len(values) > 6:
         approval_number = values[6]
         
       else:
         approval_number = None  # or handle the case appropriately
   
   
       costline_details= KBACKEND.retrieve_costlines_for_approvalnumber(approval_number)
       
       if costline_details:
       
        self.open_costlines_for_purchaseorder_numberone(costline_details) 
       else:
        print("NO DETAILS FOUND")
    def open_costlines_for_purchaseorder_numberone(self,costline_details):
        self.tablewindowone = tk.Toplevel(self.root)
        self.tablewindowone.title("Cost lines for the PO Number")
        self.tablewindowone.geometry("800x400") 
        self.tablewindowone.resizable(False,False)

        dataframe = Label(self.tablewindowone, bd=3, relief=tk.RIDGE)
        dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
        dataframe.place(x=0, y=29, width=780, height=180) 

        scrollbar_x = ttk.Scrollbar(dataframe, orient=HORIZONTAL)
        scrollbar_y = ttk.Scrollbar(dataframe, orient=VERTICAL)

        self.Table_treepwindowone = ttk.Treeview(dataframe, columns=("Types","Category","Products", "Parts_Cost", "Labour_Cost", "Total_Cost", "Rech_Parts","Rech_Labour" ,"Total_Recharge"),
                                       xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set,selectmode="browse")
        
        self.Table_treepwindowone.configure(xscrollcommand=scrollbar_x.set, yscrollcommand=scrollbar_y.set)

        scrollbar_x.config(command=self.Table_treepwindowone.xview)
        scrollbar_y.config(command=self.Table_treepwindowone.yview)

        

        self.Table_treepwindowone.heading("Types", text="Types")
        self.Table_treepwindowone.heading("Category", text="Category")
        self.Table_treepwindowone.heading("Products", text="Products")
        self.Table_treepwindowone.heading("Parts_Cost", text="Parts_Cost")
        self.Table_treepwindowone.heading("Labour_Cost", text="Labour_Cost")
        self.Table_treepwindowone.heading("Total_Cost",text="Total_Cost")
        self.Table_treepwindowone.heading("Rech_Parts", text="Rech_Parts")
        self.Table_treepwindowone.heading("Rech_Labour", text="Rech_Labour")
        self.Table_treepwindowone.heading("Total_Recharge", text="Total_Recharge")

        self.Table_treepwindowone["show"] = "headings"
    
        self.Table_treepwindowone.column("Types", width=90)
        self.Table_treepwindowone.column("Category", width=90)
        self.Table_treepwindowone.column("Products", width=90)
        self.Table_treepwindowone.column("Parts_Cost", width=90)
        self.Table_treepwindowone.column("Labour_Cost", width=90)
        self.Table_treepwindowone.column("Total_Cost", width=90)
        self.Table_treepwindowone.column("Rech_Parts", width=90)
        self.Table_treepwindowone.column("Rech_Labour", width=90)
        self.Table_treepwindowone.column("Total_Recharge", width=90)

        # Pack the scrollbars
        scrollbar_y.pack(side=RIGHT, fill=Y)
        scrollbar_x.pack(side=BOTTOM, fill=X)
        # Pack the Treeview widget
        self.Table_treepwindowone.pack(fill="both", expand=True)

        self.Table_treepwindowone.delete(*self.Table_treepwindowone.get_children())
        if costline_details:
         for incident in costline_details:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel

             self.Table_treepwindowone.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
        else:
           print("NO DETAILS FOUND")
    
    def open_incident_window(self,index):
        if index==1:
           self.close_the_incident_window()
        if index==2:
           self.save_the_incident_details()
        if index==3:
           self.open_events_From_mainpage()
        if index==4:
           self.open_Purchase_order_From_mainpage()
    
    import datetime
    ############### Giving Functionalities for icons of the incidentspage navigated from mainpage ########
    def close_the_incident_window(self):
        self.form_window.destroy()
    def save_the_incident_details(self):
     registration_no=self.reistrationentry.get()
     Driver_name= self.Driverrentry.get()
     fleet_no=self.fleett.get()
     Driver_Phone=self.Driverrphone.get()
     Customer_Id=self.Customer_Identryy.get()
     Customer_name= self.Cust_Namee_Entry.get()
     Contract_No=self.Contract_No_Entryy.get()
     Contact_Tel=self.Contact_Tel_Entryy.get()
     Contact_Email=self.Contact_Email_Entryy.get()
     
     Contact_Name=self.Contact_Name_Entryy.get()
     if Contact_Name=="":
        messagebox.showerror("Error", "Contact Name is an Mandatory field")
     Customer_defect_no=self.Customer_defno_Entryy.get()
     Contact_method=self.Contact_Method_Entryy.get()
     for row in self.contactmethd:
        if row[1] == Contact_method:
            contact_methodd = row[0]
            break
     if Contact_method == "Telephone" and (not Contact_Tel):
            messagebox.showerror("Error", "Telephone is required for this incident.")
     elif Contact_method=="Email" and (not Contact_Email):
          messagebox.showerror("Error", "Email is required for this incident.")
     Depot=self.Depotentryy.get()
     Defect_Address=self.locaentryy.get("1.0", tk.END)
     Incident_No=self.Numberentryy.get()
     selected_date=self.dateeentry.get_date()
     current_time_str = self.modifiedtimetwo.get()
     current_time = datetime.strptime(current_time_str, "%H:%M").time()
     combined_datetime = datetime.combine(selected_date, current_time)
     created_by=self.Timee.get()
     Odometer=self.Odoentry.get()
     Depot_no=self.locationn_1.get()

     cat_selected = self.CatEntryy.get()
     for row in self.categorydetails:
        if row[1] == cat_selected:
            cat_value_to_store = row[0]
            break

     lol=self.LolEntryy.get()
     for row in self.locationdetails:
        if row[1] == lol:
            lol_value_to_store = row[0]
            break
     if lol == "Roadside" and (not Driver_name or not Driver_Phone):
            messagebox.showerror("Error", "Driver name and phone are required for Roadside incidents.")
     charge=self.Chargeentryy.get()
     for row in self.chargedetails:
        if row[1]==charge:
           char_value_to_store= row[0]
           break

     status=self.StatussEntryy.get()
     for row in self.rowsss:
        if row[1]==status:
           stat_value_store= row[0]
           break
     

     Locat=self.LolEntryy.get()
     

     Charge=self.Chargeentryy.get()
    
     Status=self.StatussEntryy.get()

     Faultdesc=self.Faultentryy.get("1.0", tk.END)
     
     Attendance_def= self.attendance_vari.get()
     Deferred_to=self.Deferred_Too.get()

     Deferred_time=self.Deferred_Timetwo.get()
     
     current_time= datetime.now().strftime("%H:%M")
    # Getting the current time
     if Deferred_time is not None:
      datetime_str = f"{Deferred_to} {Deferred_time}"
     else:
     # Handle the case where Deferred_time is None
      datetime_str = f"{Deferred_to} {current_time}" 

    # Convert the datetime string to a datetime object
     if len(datetime_str)>19:
      combined_deferred = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M:%S.%f")
     else:
       combined_deferred = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")
    
     whatwords=self.whatwordsentryy.get()
     SupplierNo=self.nameentryy.get()
     Vehicle_loaded=self.vehiclevar.get()
     customer_name=self.Cust_Namee_Entry.get()
     depot_name=self.locationn_2.get()

     KBACKEND.update_incident_Details(Driver_name,fleet_no,Driver_Phone,Customer_Id,Contract_No,
                                      Contact_Tel,Contact_Email,Contact_Name,Customer_defect_no,
                                      contact_methodd,Defect_Address,Incident_No,combined_datetime,created_by,Odometer,
                                      Depot_no,cat_value_to_store,lol_value_to_store,char_value_to_store,Faultdesc,stat_value_store,Attendance_def,
                                      combined_deferred,whatwords,registration_no,SupplierNo,Vehicle_loaded,customer_name,depot_name)
     
     last_updated_incident= KBACKEND.retrieve_updated_incieve(Incident_No)

      ## Clear existing data from Kerride_table
     self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())

     if last_updated_incident:
        for incidents in last_updated_incident:
        # Retrieve attribute values for each incident
         incident_date = incidents.get("Incident Date")
         Customer=incidents.get("Customer")
         registration = incidents.get("Registration")
         I_no=incidents.get("Incident No")
         Status=incidents.get("Status")
         Category=incidents.get("Category")
         loca=incidents.get("Location")
         Charg=incidents.get("Charge")
         Locate= incidents.get("Locationn")
         Owner=incidents.get("Owner")
         Next_Event_DT=incidents.get("Next_Event_DT")
         if Next_Event_DT is not None:
          Next_Event_Date = Next_Event_DT.date()
          Next_Event_Time = Next_Event_DT.time()
         else:
          Next_Event_Date = None  # or a default value
          Next_Event_Time = None
         # Insert the incident into Kerride_table
         self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locate, registration,I_no,Category,loca,Charg,Status,Owner,Next_Event_Date,Next_Event_Time))
     self.populate_kerride_table()




    
    def open_events_From_mainpage(self):
     
     self.events_window= tk.Toplevel(self.root)
     self.events_window.title("Event Detail Form")
     self.events_window.geometry("800x600")
     self.events_window.resizable(False,False)
       #defining functionalities for icons in the event details page 
     icon_box = tk.Frame(self.events_window, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw")  # Start from left corner

    # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     images = ["icon27.png", "icon28.png"]
     for ideve, path in enumerate(images, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=ideve: self.event_functionalitytwo(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)
    
     Incident_Eventtwo= Frame(self.events_window, bd=3, relief=tk.RIDGE)
     Incident_Eventtwo.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Incident_Eventtwo.place(x=0,y=30,width=600,height=100)
     
     #Creating Label and Entry for Event Type, Action required inside Incident Event frame
     self.event_typesinfotwo= KBACKEND.fetch_event_types()
     self.eventtypedetailstwo= [row[1] for row in self.event_typesinfotwo]
     Event_type= Label(Incident_Eventtwo, text="Event type:")
     Event_type.grid(row=0,column=0,padx=5,pady=5)
     self.Event_type_entrytwo= ttk.Combobox(Incident_Eventtwo,values=self.eventtypedetailstwo,width=20)
     self.Event_type_entrytwo.grid(row=0,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Event_type_entrytwo)
     self.Event_another_entrytwo= Entry(Incident_Eventtwo,width=50)
     self.Event_another_entrytwo.grid(row=0,column=2,sticky="w")
     self.attach_context_menu(self.Event_another_entrytwo)

     current_user=getuser()
     Action_required= Label(Incident_Eventtwo, text="Created By")
     Action_required.grid(row=1,column=0,padx=5,pady=5)
     self.Action_required_entrytwo= ttk.Entry(Incident_Eventtwo,width=30)
     self.Action_required_entrytwo.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.Action_required_entrytwo.insert(0,current_user)
     self.attach_context_menu(self.Action_required_entrytwo)
     self.Action_required_entrytwo.state(['disabled'])
     
     Owner= Label(Incident_Eventtwo, text="Owner")
     Owner.grid(row=2,column=0,padx=5,pady=5)
     self.Owner_entrytwo= ttk.Entry(Incident_Eventtwo,width=30)
     self.Owner_entrytwo.grid(row=2,column=1,sticky="w",padx=5,pady=5)
     self.Owner_entrytwo.insert(0,current_user)
     self.Owner_entrytwo.state(['disabled'])
     self.attach_context_menu(self.Owner_entrytwo)

     Createdtwo= LabelFrame(self.events_window,bd=3, relief=tk.RIDGE,text="Created")
     Createdtwo.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Createdtwo.place(x=610,y=30,width=180,height=120)
     #Creating Date, Time and ID INSIDE THE CREATED DATAFRAME
     Date_created = Label(Createdtwo, text="Date:")
     Date_created.grid(row=0, column=0,padx=5,pady=4)
     self.Date_created_Entrytwo= DateEntry(Createdtwo, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_created_Entrytwo.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_created_Entrytwo)
     #Time
     Time_created= Label(Createdtwo,text="Time:")
     Time_created.grid(row=1,column=0)
     self.Time_created_entrytwo= Entry(Createdtwo,width=9)
     current_time = datetime.now().strftime("%H:%M")
     self.Time_created_entrytwo.grid(row=1,column=1,sticky="w")
     self.Time_created_entrytwo.insert(0, current_time)
     self.attach_context_menu(self.Time_created_entrytwo)
     


     Event_text=Frame(self.events_window,bd=3,relief=tk.RIDGE)
     Event_text.pack(side=tk.TOP, padx=8, pady=3, anchor="w")
     Event_text.place(x=0,y=130,width=600,height=200)
     #Creating a label and entry field for Event text inside Event text frame 
     Event_details= Label(Event_text, text="Event_text:")
     Event_details.grid(row=0, column=0,sticky='w')
     self.Event_details_entrytwo= Text(Event_text,width=50, height='10',wrap='word')
     self.Event_details_entrytwo.grid(row=0,column=1,sticky='w',padx=5,pady=5)
     self.attach_context_menu(self.Event_details_entrytwo)



     


     Next_event= LabelFrame(self.events_window,bd=3,relief=tk.RIDGE,text="Next Event")
     Next_event.pack(side=tk.TOP, padx=8,pady=3,anchor="w")
     Next_event.place(x=40, y=330, width=500,height= 180)
     #Creating Date, Time and ID,Type INSIDE THE Next Event Dataframe
     Date_nextevent = Label(Next_event, text="Date:")
     Date_nextevent.grid(row=0, column=0,padx=5,pady=4)
     self.Date_nextevent_Entrytwo= DateEntry(Next_event, width=12, background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Date_nextevent_Entrytwo.grid(row=0, column=1,sticky='w')
     self.attach_context_menu(self.Date_nextevent_Entrytwo)
     #Time
     Time_nextevent= Label(Next_event,text="Time:")
     Time_nextevent.grid(row=1,column=0,padx=5,pady=5)
     self.Time_nextevent_entrytwo= Entry(Next_event,width=9)
     self.Time_nextevent_entrytwo.grid(row=1,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Time_nextevent_entrytwo)

     self.typetwo=KBACKEND.fetch_event_types()
     self.typedetailstwo= [row[1] for row in self.typetwo]
     Type_nextevent= Label(Next_event, text="Type:")
     Type_nextevent.grid(row=3,column=0,padx=5,pady=5)
     self.Type_nextevent_entrytwo= ttk.Combobox(Next_event,values=self.typedetailstwo,width=20)
     self.Type_nextevent_entrytwo.grid(row=3,column=1,sticky="w",padx=5,pady=5)
     self.attach_context_menu(self.Type_nextevent_entrytwo)
     self.Event_type_entrytwo.bind("<<ComboboxSelected>>", self.populate_next_event_detailstwo)
     self.populate_next_event_detailstwo()
     self.Type_another_entrytwo= Entry(Next_event,width=40)
     self.Type_another_entrytwo.grid(row=3,column=2,sticky="w")
     self.attach_context_menu(self.Type_another_entrytwo)

    def populate_next_event_detailstwo(self, event=None):
     selected_event_type = self.Event_type_entrytwo.get()
    
     # Find the corresponding details for the selected event type
     for row in self.event_typesinfotwo:
        if row[1] == selected_event_type:
            next_event_id = row[2]
            if next_event_id is None:  # If there is no next_event_id
                # Set Type_nextevent_entry to the selected event type
                self.Type_nextevent_entrytwo.set(selected_event_type)
                # Set Date_nextevent_Entry to the current date
                current_date = datetime.now().strftime("%d/%m/%Y")
                self.Date_nextevent_Entrytwo.set_date(current_date)
                # Set Time_nextevent_entry to the current time
                current_time = datetime.now().strftime("%H:%M")
                self.Time_nextevent_entrytwo.delete(0, 'end')  # Clear previous value
                self.Time_nextevent_entrytwo.insert(0, current_time)
            else:
                # Find the corresponding description for the next_event_id
                for item in self.typetwo:
                    if item[0] == next_event_id:
                        self.Type_nextevent_entrytwo.set(item[1])
                        minutes = item[3]  # Use minutes from item[3]
                        if minutes > 1440:  # If duration exceeds one day
                            # Calculate the number of days and remaining minutes
                            days = minutes // 1440
                            remaining_minutes = minutes % 1440
                            # Calculate the adjusted date
                            next_date = datetime.now() + timedelta(days=days)
                            date_str = next_date.strftime("%d/%m/%Y")
                            # Populate Date_nextevent_Entry
                            self.Date_nextevent_Entrytwo.set_date(date_str)
                            # Get the current time
                            current_time_str = self.Time_created_entrytwo.get()
                            current_time = datetime.strptime(current_time_str, "%H:%M")
                            # Add remaining minutes to current time
                            adjusted_time = current_time + timedelta(minutes=remaining_minutes)
                        else:
                            # Get the current time
                            current_time_str = self.Time_created_entrytwo.get()
                            current_time = datetime.strptime(current_time_str, "%H:%M")
                            # Add minutes to current time
                            adjusted_time = current_time + timedelta(minutes=minutes)
                        # Format adjusted time
                        adjusted_time_str = adjusted_time.strftime("%H:%M")
                        # Populate Time_nextevent_entry
                        self.Time_nextevent_entrytwo.delete(0, 'end')  # Clear previous value
                        self.Time_nextevent_entrytwo.insert(0, adjusted_time_str)
                        break
            break

    def event_functionalitytwo(self,index):
       if index==1:
          self.exit_the_events()
       elif index==2:
          self.add_the_events_toinci()
    
    def exit_the_events(self):
       self.events_window.destroy()
    def add_the_events_toinci(self):
     i_number=self.Numberentryy.get()
     KBACKEND.generate_event_numbertwo(i_number)

     date_str = self.Date_created_Entrytwo.get()  # Get date as string
     time_str = self.Time_created_entrytwo.get()  # Get time as string

     # Combine date and time strings into a single datetime string
     datetime_str = f"{date_str} {time_str}"

     # Convert the datetime string to a datetime object
     datetime_obj = datetime.strptime(datetime_str, "%d/%m/%Y %H:%M")

     First_event=self.Event_type_entrytwo.get()
     for row in self.event_typesinfotwo:    
        if row[1] == First_event:
            First_event_tostore = row[0]
            break
         
     Event_text=self.Event_details_entrytwo.get("1.0", tk.END)
     second_event= self.Type_nextevent_entrytwo.get()
     for row in self.typetwo:    
         if row[1] == second_event:
            Second_event_tostore = row[0]
            break
     datee_str= self.Date_nextevent_Entrytwo.get()
     timee_str=self.Time_nextevent_entrytwo.get()
        # Combine date and time strings into a single datetime string
     datetime_strr = f"{datee_str} {timee_str}"
     # Convert the datetime string to a datetime object
     datetime_objj = datetime.strptime(datetime_strr, "%d/%m/%Y %H:%M")
     Created_by= self.Action_required_entrytwo.get()
     Owner=self.Owner_entrytwo.get()

     KBACKEND.insert_more_events(i_number,datetime_obj,First_event_tostore,Event_text
                                     ,Second_event_tostore,datetime_objj,Created_by,Owner)
     
     last_updated_event= KBACKEND.retrieve_updated_event(i_number)

      ## Clear existing data from Kerride_table
     self.root.Kerride_table.delete(*self.root.Kerride_table.get_children())

     if last_updated_event:
        for incidents in last_updated_event:
        # Retrieve attribute values for each incident
         incident_date = incidents.get("Incident Date")
         Customer=incidents.get("Customer")
         registration = incidents.get("Registration")
         I_no=incidents.get("Incident No")
         Status=incidents.get("Status")
         Category=incidents.get("Category")
         loca=incidents.get("Location")
         Charg=incidents.get("Charge")
         Locat= incidents.get("Locationn")
         Owner=incidents.get("Owner")
         Next_Event_DT=incidents.get("Next_Event_DT")
         if Next_Event_DT is not None:
          Next_Event_Date = Next_Event_DT.date()
          Next_Event_Time = Next_Event_DT.time()
         else:
          Next_Event_Date = None  # or a default value
          Next_Event_Time = None
         # Insert the incident into Kerride_table
         self.root.Kerride_table.insert("", "end", values=(incident_date, Customer, Locat, registration,I_no,Category,loca,Charg,Status,Owner,Next_Event_Date,Next_Event_Time))
     self.populate_kerride_table()

     event_details= KBACKEND.fetch_all_eventstwo(i_number)
     self.eventss_tree.delete(*self.eventss_tree.get_children())
        
       
     if event_details:
          for event in event_details:
             Event_created= event.get('Created')
             #event_datetime = datetime.strptime(Event_created, "%Y-%m-%d %H:%M:%S")
             Created_date = Event_created.date()

             # Get the time part
             Created_time = Event_created.time()
        
             Notes= event.get('Notes')
             Last_updated= event.get('Last Updated')
             #last_updated_datetime= datetime.strptime(Last_updated, "%Y-%m-%d %H:%M:%S")
             Last_updated_date= Last_updated.date()
             Last_updated_time= Last_updated.time()
             Follow_up= event.get('Follow up')
             #Follow_up_datetime= datetime.strptime(Follow_up, "%Y-%m-%d %H:%M:%S")
             Follow_up_date= Follow_up.date()
             follow_up_time= Follow_up.time()
             Event_Description= event.get('Event_Description')
             Next_Event_Description= event.get('Next_Event_Description')




             self.eventss_tree.insert("", "end", values=(Created_date,Created_time,"",Event_Description,"",
                Notes,Last_updated_date,Last_updated_time,"",Follow_up_date,follow_up_time,"",Next_Event_Description))
        
             self.populate_events_tree()
    
    def clicking_the_costlinestwo(self,event):
       selected_item = self.Table_treepone.selection()
       if selected_item:
         # Extract the index of the selected item
         item_index = self.Table_treepone.index(selected_item[0])

         Line_added = item_index + 1

         PO_Number= self.Approvalentrypone.get()

         open_costline_details= KBACKEND.open_costlines_page(PO_Number,Line_added)

         self.open_costlinespage_with_clickedrowtwo(open_costline_details)
    
    def open_costlinespage_with_clickedrowtwo(self,open_costline_details):
       
     self.costline_windowclickone = tk.Toplevel(self.root)
     self.costline_windowclickone.title("Cost Line Form")
     self.costline_windowclickone.geometry("800x620") 
     self.costline_windowclickone.resizable(False,False)

      #Create a container (Frame) for the icons with a border
     icon_box = tk.Frame(self.costline_windowclickone, relief=tk.RIDGE, borderwidth=3)
     icon_box.pack(side=tk.TOP, padx=8, pady=2, anchor="nw") 

     # You can add icons below menus using PhotoImage or other methods.
    # For demonstration purposes, let's create 13 small image icons.
     image_paths = ["icon23.png"]
     for idcost, path in enumerate(image_paths, start=1):
         image = Image.open(path)
         image = image.resize((15, 15), Image.BILINEAR)  # Change to Image.LANCZOS if preferred
         photo = ImageTk.PhotoImage(image)
         icon_button = tk.Button(icon_box, image=photo, command=lambda index=idcost: self.costline_iconsclickone(index))
         icon_button.image = photo
         icon_button.pack(side=tk.LEFT, padx=5, pady=2)
     
     dataframe = Frame(self.costline_windowclickone, bd=3, relief=tk.RIDGE)
     dataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     dataframe.place(x=0, y=35, width=780, height=90)

     Reg_details= self.Reg_no_entrypone.get()
     Reg_no = Label(dataframe, text="Registration No:")
     Reg_no.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.costlineregclickone = ttk.Entry(dataframe,width=18)
     self.costlineregclickone.grid(row=0, column=1,padx=10,pady=3)
     self.costlineregclickone.insert(0,Reg_details)
     self.attach_context_menu(self.costlineregclickone)
     self.costlineregclickone.state(['disabled'])
     
     Repairer_name=self.Repairerentrypone.get()
     Repairer = Label(dataframe, text="Repairer:")
     Repairer.grid(row=0, column=2)
     self.costlinerepclickone = ttk.Entry(dataframe, width=18)
     self.costlinerepclickone.grid(row=0, column=3,padx=10,pady=3)
     self.costlinerepclickone.insert(0,Repairer_name)
     self.attach_context_menu(self.costlinerepclickone)
     self.costlinerepclickone.state(['disabled'])
     
     System_number= self.Approvalentrypone.get()
     System = Label(dataframe, text="Po Number:")
     System.grid(row=0, column=4)
     self.systemcostclickone = ttk.Entry(dataframe, width=18)
     self.systemcostclickone.grid(row=0, column=5,padx=10,pady=3)
     self.systemcostclickone.insert(0,System_number)
     self.attach_context_menu(self.systemcostclickone)
     self.systemcostclickone.state(['disabled'])
     
     Ododetails=self.Odometerentrypone.get()
     Odometerveh = Label(dataframe, text="Vehicle Odometer:")
     Odometerveh.grid(row=1, column=0,pady=5)
     self.odovehcostclickone = ttk.Entry(dataframe, width=18)
     self.odovehcostclickone.grid(row=1, column=1)
     self.odovehcostclickone.insert(0,Ododetails)
     self.attach_context_menu(self.odovehcostclickone)
     self.odovehcostclickone.state(['disabled'])
     
     Repairer_accountdetails= self.Accountentrypone.get()
     Repaireraccount = Label(dataframe, text="Repairer account:")
     Repaireraccount.grid(row=1, column=2,pady=5)
     self.repaccocostclickone = ttk.Entry(dataframe, width=18)
     self.repaccocostclickone.grid(row=1, column=3)
     self.repaccocostclickone.insert(0,Repairer_accountdetails)
     self.attach_context_menu(self.repaccocostclickone)
     self.repaccocostclickone.state(['disabled'])

     Line_created= Label(dataframe,text="Line Created:")
     Line_created.grid(row=1,column=4)
     self.Line_createdentryclickone=DateEntry(dataframe, width=12,background='darkblue', foreground='white', borderwidth=2, date_pattern='dd/mm/yyyy')
     self.Line_createdentryclickone.grid(row=1,column=5)
     if open_costline_details is not None:
      self.Line_createdentryvalueclickone= open_costline_details.get('Line_Added')
     else:
        self.Line_createdentryvalueclickone= None
     if self.Line_createdentryvalueclickone:
      self.Line_createdentryclickone.set_date(self.Line_createdentryvalueclickone)
     else:
      self.Line_createdentryclickone.set_date(None)

     self.Line_createdentryclickone.state(['disabled'])

     Line_createdby= Label(dataframe,text="Created_By:")
     Line_createdby.grid(row=2,column=0)
     self.Line_createdbyclickone= ttk.Entry(dataframe,width=18)
     self.Line_createdbyclickone.grid(row=2,column=1)
     if open_costline_details is not None:
        self.Line_createdbyclickvalueone= open_costline_details.get('Added_By')
     else:
        self.Line_createdbyclickvalueone= None
     self.Line_createdbyclickone.insert(0, self.Line_createdbyclickvalueone if self.Line_createdbyclickvalueone is not None else"")
     self.Line_createdbyclickone.state(['disabled'])

     Seconddataframe = Frame(self.costline_windowclickone, bd=3, relief=tk.RIDGE)
     Seconddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seconddataframe.place(x=0, y=125, width=780, height=70)

     Reason = Label(Seconddataframe, text="Types:")
     Reason.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Reasoncosttypesclickone = ttk.Combobox(Seconddataframe,width=20)
     self.Reasoncosttypesclickone.grid(row=0, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Reasoncosttypesclickidone= open_costline_details.get('Type_ID')
        self.Reasoncosttypesclickdescone= open_costline_details.get('Type_Desc')
        self.reasoncosttypesclickvalueone = f"{self.Reasoncosttypesclickidone}-{self.Reasoncosttypesclickdescone}" if self.Reasoncosttypesclickidone and self.Reasoncosttypesclickdescone else None
     else:
        self.reasoncosttypesclickvalueone= None
     self.Reasoncosttypesclickone.insert(0,self.reasoncosttypesclickvalueone if self.reasoncosttypesclickvalueone is not None else"")
     self.attach_context_menu(self.Reasoncosttypesclickone)
     self.Reasoncosttypesclickone.state(['disabled'])

     RTS = Label(Seconddataframe, text="Category:")
     RTS.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.rtscostcategoryclickone = ttk.Entry(Seconddataframe,width=20)
     self.rtscostcategoryclickone.grid(row=0, column=3,padx=10,pady=3)
     if open_costline_details is not None:
        self.rtscostcategoryidone= open_costline_details.get('Category_ID')
        self.rtscostcategorydescone= open_costline_details.get('Cat_Desc')
        self.rtscostcategoryclickvalueone=f"{self.rtscostcategoryidone}-{self.rtscostcategorydescone}" if self.rtscostcategoryidone and self.rtscostcategorydescone else None
     else:
        self.rtscostcategoryclickvalueone= None
     self.rtscostcategoryclickone.insert(0,self.rtscostcategoryclickvalueone if self.rtscostcategoryclickvalueone is not None else"")
     self.attach_context_menu(self.rtscostcategoryclickone)
     self.rtscostcategoryclickone.state(['disabled'])

     category_label = tk.Label(Seconddataframe, text="Products:")
     category_label.grid(row=0, column=4)

     self.category_productsclickone = ttk.Combobox(Seconddataframe, width=20)
     self.category_productsclickone.grid(row=0, column=5, padx=15, pady=3)
     if open_costline_details is not None:
      self.costlineproductidone=open_costline_details.get('Product_ID')
      self.costlineproductdescone=open_costline_details.get('Product_Desc')
      self.costlineproductsvalueone=f"{self.costlineproductidone}-{self.costlineproductdescone}" if self.costlineproductidone and self.costlineproductdescone else None
     else:
      self.costlineproductsvalueone=None
     self.category_productsclickone.insert(0,self.costlineproductsvalueone if self.costlineproductsvalueone is not None else"")
     self.attach_context_menu(self.category_productsclickone)
     self.category_productsclickone.state(['disabled'])
     
     Analysis = Label(Seconddataframe, text="PF Depot:")
     Analysis.grid(row=1, column=0,pady=5)
     self.analysiscostclickone = ttk.Entry(Seconddataframe, width=18)
     self.analysiscostclickone.grid(row=1, column=1)
     if open_costline_details is not None:
        self.analysiscostclickvalueone= open_costline_details.get('Pf_depot')
     else:
        self.analysiscostclickvalueone=None
     self.analysiscostclickone.insert(0,self.analysiscostclickvalueone if self.analysiscostclickvalueone is not None else"")
     self.attach_context_menu(self.analysiscostclickone)
     self.analysiscostclickone.state(['disabled'])

     Thirddataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Charges")
     Thirddataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Thirddataframe.place(x=0, y=195, width=780, height=50)

     Parts = Label(Thirddataframe, text="Parts:")
     Parts.grid(row=0, column=0)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Partscostclickone = ttk.Entry(Thirddataframe,width=13)
     self.Partscostclickone.grid(row=0, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Partscostclickvalueone= open_costline_details.get('Parts_cost')
     else:
        self.Partscostclickvalueone= None
     self.Partscostclickone.insert(0,self.Partscostclickvalueone if self.Partscostclickvalueone is not None else"")
     self.attach_context_menu(self.Partscostclickone)
     self.Partscostclickone.state(['disabled'])
     
     Labour_Hours= Label(Thirddataframe,text="Labour Hours:")
     Labour_Hours.grid(row=0,column=2)
     self.Labour_Hoursclickone= ttk.Entry(Thirddataframe,width=13)
     self.Labour_Hoursclickone.grid(row=0,column=3,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labour_Hoursclickonevalue= open_costline_details.get('Labour_Hours')
     else:
        self.Labour_Hoursclickonevalue=None
     self.Labour_Hoursclickone.insert(0,self.Labour_Hoursclickonevalue if self.Labour_Hoursclickonevalue is not None else"")
     self.attach_context_menu(self.Labour_Hoursclickone)
     self.Labour_Hoursclickone.state(['disabled'])

     Labour_Rate=Label(Thirddataframe,text="Labour Rate")
     Labour_Rate.grid(row=0,column=4)
     self.Labour_Rateclickone=ttk.Entry(Thirddataframe,width=13)
     self.Labour_Rateclickone.grid(row=0,column=5,padx=15, pady=3)
     if open_costline_details is not None:
        self.Labour_Rateclickonevalue= open_costline_details.get('Labour_Rate')
     else:
        self.Labour_Rateclickonevalue=None
     self.Labour_Rateclickone.insert(0,self.Labour_Rateclickonevalue if self.Labour_Rateclickonevalue is not None else "0.00")
     self.attach_context_menu(self.Labour_Rateclickone)
     self.Labour_Rateclickone.state(['disabled'])


     Labour = Label(Thirddataframe, text="Labour Value:")
     Labour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Labourcostclickone = ttk.Entry(Thirddataframe,width=13)
     self.Labourcostclickone.grid(row=0, column=7,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labourcostclickvalueone= open_costline_details.get('labour_cost')
     else:
        self.Labourcostclickvalueone= None
     self.Labourcostclickone.insert(0,self.Labourcostclickvalueone if self.Labourcostclickvalueone is not None else"")
     self.attach_context_menu(self.Labourcostclickone)
     self.Labourcostclickone.state(['disabled'])

     fourthdataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Recharge")
     fourthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fourthdataframe.place(x=0, y=245, width=780, height=80)

     Parts_Uplift=Label(fourthdataframe,text="Parts Uplift")
     Parts_Uplift.grid(row=0,column=0)
     self.Parts_Upliftclickone= ttk.Entry(fourthdataframe,width=13)
     self.Parts_Upliftclickone.grid(row=0,column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Parts_Upliftclickvalueone= open_costline_details.get('Parts_Uplift')
     else:
        self.Parts_Upliftclickvalueone=None
     self.Parts_Upliftclickone.insert(0,self.Parts_Upliftclickvalueone if self.Parts_Upliftclickvalueone is not None else"")
     self.attach_context_menu(self.Parts_Upliftclickone)
     self.Parts_Upliftclickone.state(['disabled'])

     RechParts = Label(fourthdataframe, text="Rech.Parts:")
     RechParts.grid(row=0, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechcostclickone = ttk.Entry(fourthdataframe,width=13)
     self.Rechcostclickone.grid(row=0, column=3,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechcostclickvalueone= open_costline_details.get('Recharge_parts')
     else:
        self.Rechcostclickvalueone= None
     self.Rechcostclickone.insert(0,self.Rechcostclickvalueone if self.Rechcostclickvalueone is not None else"")
     self.attach_context_menu(self.Rechcostclickone)
     self.Rechcostclickone.state(['disabled'])

     Labour_Uplift= Label(fourthdataframe,text="Labour Uplift")
     Labour_Uplift.grid(row=0,column=4)
     self.Labour_Upliftclickone= ttk.Entry(fourthdataframe,width=13)
     self.Labour_Upliftclickone.grid(row=0,column=5,padx=15,pady=3)
     if open_costline_details is not None:
        self.Labour_Upliftclickvalueone=open_costline_details.get('Labour_Uplift')
     else:
        self.Labour_Upliftclickvalueone=None
     self.Labour_Upliftclickone.insert(0,self.Labour_Upliftclickvalueone if self.Labour_Upliftclickvalueone is not None else"")
     self.attach_context_menu(self.Labour_Upliftclickone)
     self.Labour_Upliftclickone.state(['disabled'])


     Rechlabour = Label(fourthdataframe, text="Rech.labour:")
     Rechlabour.grid(row=0, column=6)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechlabcostclickone = ttk.Entry(fourthdataframe,width=11)
     self.Rechlabcostclickone.grid(row=0, column=7,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechlabcostclickvalueone= open_costline_details.get('Recharge_labour')
     else:
        self.Rechlabcostclickvalueone= None
     self.Rechlabcostclickone.insert(0,self.Rechlabcostclickvalueone if self.Rechlabcostclickvalueone is not None else"")
     self.attach_context_menu(self.Rechlabcostclickone)
     self.Rechlabcostclickone.state(['disabled'])

     Rechposted = Label(fourthdataframe, text="Rech.posted:")
     Rechposted.grid(row=1, column=0)
     
     self.rechposted_varclickone = tk.BooleanVar()
    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechpostedcostclickone = ttk.Checkbutton(fourthdataframe,variable=self.rechposted_varclickone)
     self.Rechpostedcostclickone.grid(row=1, column=1,padx=15,pady=3)
     if open_costline_details is not None:
        self.Rechpostedcostclickvalueone= open_costline_details.get('Recharge_invoiced')
     else:
        self.Rechpostedcostclickvalueone= None
     if self.Rechpostedcostclickvalueone == 'Y':
        checkbox_checked = True
     else:
         checkbox_checked = False
     self.rechposted_varclickone.set(checkbox_checked)
     self.Rechpostedcostclickone.state(['disabled'])

     Rechposteddate = Label(fourthdataframe, text="Rech.posted date:")
     Rechposteddate.grid(row=1, column=2)

    # Create a Combobox widget and pass the list of registration numbers as options 
     self.Rechposteddatecostclickone = ttk.Entry(fourthdataframe, width=12)
     self.Rechposteddatecostclickone.grid(row=1, column=3,padx=15,pady=3)

     if open_costline_details is not None:
        self.Rechposteddatecostclickvalueone= open_costline_details.get('Recharge_posted')
     else:
        self.Rechposteddatecostclickvalueone= None

     # Format the date to dd/mm/yyyy
     if self.Rechposteddatecostclickvalueone is not None:
      if isinstance(self.Rechposteddatecostclickvalueone, datetime):
        # Format the date to dd/mm/yyyy
        formatted_date = self.Rechposteddatecostclickvalueone.strftime("%d/%m/%Y")
      else:
        formatted_date = ""  # Handle case where the value is not a datetime object
         
     else:
      formatted_date = ""

     # Insert the formatted date into the Entry widget
     self.Rechposteddatecostclickone.insert(0, formatted_date)
     self.Rechposteddatecostclickone.state(['disabled'])
     
     #self.Rechposteddatecostclickone.insert(0,self.Rechposteddatecostclickvalueone if self.Rechposteddatecostclickvalueone is not None else"")
     #self.Rechposteddatecostclickone.state(['disabled'])

     
     Customer_PO= self.Customer_Ponumone.get()
     Customerreference = Label(fourthdataframe, text="Customer ref:")
     Customerreference.grid(row=1, column=4)
     self.customerreferencecostclickone = ttk.Entry(fourthdataframe,width=11)
     self.customerreferencecostclickone.grid(row=1, column=5,padx=15,pady=3)
     self.customerreferencecostclickone.insert(0,Customer_PO if Customer_PO is not None else"")
     self.customerreferencecostclickone.state(['disabled'])

     fifthdataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Notes")
     fifthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     fifthdataframe.place(x=0, y=375, width=780, height=115)

     self.notescostclickone= tk.Text(fifthdataframe,width=80, height='5',wrap='word')
     self.notescostclickone.grid(row=0,column=0,sticky='w',padx=5)
     if open_costline_details is not None:
        self.notescostclickvalueone= open_costline_details.get('Notes')
     else:
        self.notescostclickvalueone= None
     self.notescostclickone.insert("1.0",self.notescostclickvalueone if self.notescostclickvalueone is not None else"")
     self.attach_context_menu(self.notescostclickone)
     self.notescostclickone['state']='disabled'

     Sixthdataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Recharge text")
     Sixthdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Sixthdataframe.place(x=0, y=490, width=780, height=115)

     self.rechargecostclickone= tk.Text(Sixthdataframe,width=80, height='5',wrap='word')
     self.rechargecostclickone.grid(row=0,column=0,sticky='w',padx=5)
     if open_costline_details is not None:
        self.rechargecostclickvalueone= open_costline_details.get('Recharge_text')
     else:
        self.rechargecostclickvalueone= None
     self.rechargecostclickone.insert("1.0",self.rechargecostclickvalueone if self.rechargecostclickvalueone is not None else"")
     self.rechargecostclickone['state']='disabled'
     
     Seventhdataframe = LabelFrame(self.costline_windowclickone, bd=3, relief=tk.RIDGE,text="Customer Specifics")
     Seventhdataframe.pack(side=tk.TOP, padx=8, pady=3, anchor="nw")  # Start from left corner
     Seventhdataframe.place(x=0, y=325, width=780, height=50)

     self.Customer_specificsclickone=ttk.Entry(Seventhdataframe,width=100)
     self.Customer_specificsclickone.grid(row=0,column=2)

     cust_id=self.Customer_Identryy.get()
     result=KBACKEND.check_customer_specific(cust_id)
     if result:
        self.Customer_specificsclickone.delete(0, tk.END)
        self.Customer_specificsclickone.insert(0,"This Customer had SPECIAL RECHARGE RATES")
     else:
        self.Customer_specificsclickone.delete(0, tk.END)
        self.Customer_specificsclickone.insert(0,"This Customer did not have SPECAL RECHARGE RATES")
     self.Customer_specificsclickone.state(['disabled'])
       
    def costline_iconsclickone(self,index):
       if index==1:
          self.close_the_Second_costline()
    
    def close_the_Second_costline(self):
       self.costline_windowclickone.destroy()
       
    
    def populate_top_purchase_order(self):
       self.costlinestable.delete(*self.costlinestable.get_children())

       Reg_Number= self.text1.get()

       Purchase_orders=KBACKEND.retrieve_all_purchase_and_populate(Reg_Number)

       if Purchase_orders:
        for incident in Purchase_orders:
           Repaired= incident.get("Repaired")
           if Repaired is not None:
            Repaired_date = Repaired.date()
           else:
            print("Repaired is None, cannot access 'date' attribute.")
            Repaired_date = None  # or some default value           
           Odometer=incident.get("Odometer")
           Supplier_Name= incident.get("Supplier")
           Incident_Link= incident.get("Incident_Link")
           Total_Parts=incident.get("Total_parts")
           Total_labours=incident.get("Total_labours")
           Total_cost= Total_Parts + Total_labours
           Recharge_parts= incident.get("Recharge_parts")
           Recharge_labours= incident.get("Recharge_labours")
           Total_Recharge= Recharge_parts+ Recharge_labours
           PO_number= incident.get("Approval")

           self.costlinestable.insert("", "end", values=(Repaired_date,Odometer,Supplier_Name,Incident_Link,
                                                         Total_cost,Total_Recharge,PO_number))
    
    def populate_all_the_costlines(self):
       self.Table_treep.delete(*self.Table_treep.get_children())

       Approval_number=self.Approvalentryp.get()

       All_cost_lines= KBACKEND.populate_all_the_cost_lines(Approval_number)

       if All_cost_lines:
          for incident in All_cost_lines:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel


             self.Table_treep.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
             
    def populate_top_purchase_order_two(self):
       self.costlinestableone.delete(*self.costlinestableone.get_children())

       Reg_Number= self.reistrationentry.get()

       Purchase_orders=KBACKEND.retrieve_all_purchase_and_populate(Reg_Number)

       if Purchase_orders:
        for incident in Purchase_orders:
           Repaired= incident.get("Repaired")
           if Repaired is not None:
            Repaired_date = Repaired.date()
           else:
            print("Repaired is None, cannot access 'date' attribute.")
            Repaired_date = None  # or some default value           
           Odometer=incident.get("Odometer")
           Supplier_Name= incident.get("Supplier")
           Incident_Link= incident.get("Incident_Link")
           Total_Parts=incident.get("Total_parts")
           Total_labours=incident.get("Total_labours")
           Total_cost= Total_Parts + Total_labours
           Recharge_parts= incident.get("Recharge_parts")
           Recharge_labours= incident.get("Recharge_labours")
           Total_Recharge= Recharge_parts+ Recharge_labours
           PO_number= incident.get("Approval")

           self.costlinestableone.insert("", "end", values=(Repaired_date,Odometer,Supplier_Name,Incident_Link,
                                                         Total_cost,Total_Recharge,PO_number))
    def populate_supplier_detailspinsert(self,event=None):
        selected_supplier= self.Repairerentrypone.get()
        rows=KBACKEND.fetch_supplier_details()
        for row in rows:
           if row[1]==selected_supplier:
              self.Accountentrypone.delete(0,tk.END)
              self.Accountentrypone.insert(0,row[0])    

    def populate_all_the_costlines_two(self):
       self.Table_treepone.delete(*self.Table_treepone.get_children())

       Approval_number=self.Approvalentrypone.get()

       All_cost_lines= KBACKEND.populate_all_the_cost_lines_two(Approval_number)
       if All_cost_lines:
          for incident in All_cost_lines:
             Rts= incident.get("RTS_code")
             Rtsd= incident.get("RTS_Desc")
             Product=incident.get("Product_Desc")
             Parts= incident.get("Parts_Cost")
             Labour= incident.get("Labour_Cost")
             Total_Cost= Parts+ Labour
             Rechargep= incident.get("Recharge_parts")
             Rechargel= incident.get("Recharge_labour")
             Totalrecharge= Rechargep+ Rechargel


             self.Table_treepone.insert("", "end", values=(Rts,Rtsd,Product,Parts,Labour,Total_Cost,Rechargep,Rechargel,Totalrecharge))
    def populate_the_post_incident_reports(self):
       Incident_Number=self.Numberentryy.get()
       Post_incident_report=KBACKEND.fetch_lastpost_reports_and_insert(Incident_Number)

       self.Post_incident_treee.delete(*self.Post_incident_treee.get_children())

       if Post_incident_report:
          for post_details in Post_incident_report:
             Inci_Number= post_details.get("I_number")
             Date_time= post_details.get("Report_Created")
             if Date_time is not None:
              Date = Date_time.date()
              Time = Date_time.time()
             else:
               Date = None  # or a default value
               Time = None
             Created= post_details.get("Created_By")
             Incident_Category= post_details.get("Inc_Category_ID")
             Commentss= post_details.get("Comments")

             self.Post_incident_treee.insert("", "end", values=(Incident_Number,Date,Time,Created,Incident_Category,Commentss))   




       

       
       




     
         



    

    # Giving the functionalities for the icons such as exit and save 
    def open_icon_windowthird(self,index):
        if index == 1:
            self.close_the_third_window()
        elif index == 2:
            self.save_the_details()   
        
    def close_the_third_window(self):
        self.purchase_order.destroy()  
    def save_the_details():
        pass

    

    #This closes the first window and exits the application.
    def close_the_window(self):
        if messagebox.askokcancel("Quit", "Do you want to quit?"):
          self.root.destroy()

    
    #Right click options#
    def copy(self):
        selected_text = self.root.clipboard_get()
        self.root.clipboard_clear()
        self.root.clipboard_append(selected_text)

    def cut(self):
        if self.root.focus_get():
            selected_text = self.root.focus_get().selection_get()
            self.root.focus_get().delete(tk.SEL_FIRST, tk.SEL_LAST)
            self.root.clipboard_clear()
            self.root.clipboard_append(selected_text)

    def paste(self):
        text_to_paste = self.root.clipboard_get()
        self.root.focus_get().insert(tk.INSERT, text_to_paste)

    
    def undo(self):
        if self.undo_stack:
            previous_state = self.undo_stack.pop()
            self.Regtext1.delete(0, tk.END)
            self.Regtext1.insert(0, previous_state)

    def attach_context_menu(self, entry):
        # Create a context menu
        context_menu = tk.Menu(self.root, tearoff=0)
        context_menu.add_command(label="Copy", command=self.copy)
        context_menu.add_command(label="Cut", command=self.cut)
        context_menu.add_command(label="Paste", command=self.paste)
        context_menu.add_command(label="Undo", command=self.undo)
        # Attach context menu to the Entry widget
        def show_context_menu(event):
            context_menu.tk_popup(event.x_root, event.y_root)

        entry.bind("<Button-3>", show_context_menu)



if __name__ == "__main__":
 import KBACKEND
 root = tk.Tk()
 login_window = KerridgeReplacement(root)
 root.mainloop()


