import pyodbc
import pandas as pd
from tkinter import messagebox
from sqlalchemy import create_engine,inspect
from datetime import datetime

conn_str1 = (
        "DRIVER={ODBC Driver 17 for SQL Server};"
        "SERVER=PO301135\\SQLEXPRESS;"
       "DATABASE=Kerridge;"
        "uid=ManagerPST;"
        "password=s847cn27;"
        "Trusted_Connection=yes;"
) 
conn = pyodbc.connect(conn_str1)
print("Connection Successful")

conn_str2=(
        "DRIVER={ODBC Driver 17 for SQL Server};"
        "SERVER=S0SQL05\\STAT;"
        "DATABASE=IGLOO_UK;"
       "uid=ExcelUK_user;"
        "pwd=m_UArLN$;"
        )
#print(conn_str2)
conn2= pyodbc.connect(conn_str2)
print("Connection Successful")


import datetime

def store_registration(reg_no, I_number,driver_name,created,combined_datetime,contact_methodd,contactname,
                       contacttel,contactemail,drivertel,Defect_loc,faultdesc,cat_value_to_store,lol_value_to_store,
                                 char_value_to_store,stat_value_store,odo,attendance,combined_deferred,what3,fleet,custid,contractno,locat,defectno,supplier_no,vehicle_loaded,
                                 customer_name,depot_name,InciType_value_to_store):
    # Connect to the database
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()

    try:
        # Check if a record with the same Registration_No already exists
        cur.execute("SELECT COUNT(*) FROM Incident_Headder WHERE Registration_No = ? AND I_number=?", (reg_no,I_number))
        record_count = cur.fetchone()[0]

        if record_count > 0:
            # If a record exists, update it
            cur.execute("""UPDATE Incident_Headder 
                        SET 
                        Driver_Name = ? ,
                        Created_BY=?,
                        Defect_occurred=?,
                        Contact_Method_ID=?,
                        Contact_Name=?,
                        Contact_Tel=?,
                        Contact_Email=?,
                        Driver_Tel=?,
                        Defect_Loc_Address=?,
                        Reported_Defect=?,
                        Cat_ID=?,
                        Location_ID=?,
                        Charge_ID=?,
                        Status_ID=?,
                        Odometer=?,
                        Attendance_Deferred=?,
                        Deferred_To=?,
                        Defect_loc_W3W=?,
                        Fleet_No=?,
                        Customer_ID=?,
                        Customer_Contract_NO=?,
                        Depot_No=?,
                        Customer_Defect_NO=?,
                        Supplier_No=?,
                        Vehicle_loaded=?,
                        Customer_Name=?,
                        Depot_Name=?,
                        Inc_Type_ID=?
                        WHERE Registration_No = ? AND I_Number=?""", 
                        (driver_name,created,combined_datetime,contact_methodd,contactname,
                                 contacttel,contactemail,drivertel,Defect_loc,faultdesc,cat_value_to_store,lol_value_to_store,
                                 char_value_to_store,stat_value_store,odo,attendance,combined_deferred,what3,fleet,custid,contractno,locat,defectno,supplier_no,vehicle_loaded,
                                 customer_name,depot_name,InciType_value_to_store,reg_no, I_number))
            print("Record updated successfully")
        else:
            # If no record exists, insert a new one
            # Get the current date and time
            current_datetime = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            # Insert the new record
            cur.execute("""INSERT INTO Incident_Headder(I_Number, I_Created,Created_BY,Defect_occurred, Driver_Name, Registration_No, Contact_Method_ID,Contact_Name,
                        Contact_Tel, Contact_Email,Driver_Tel,Defect_Loc_Address,Reported_Defect,Cat_ID,Location_ID,
                        Charge_ID,Status_ID,Odometer,Attendance_Deferred,Deferred_To,Defect_loc_W3W,Fleet_No,Customer_ID,
                        Customer_Contract_NO,Depot_No,Customer_Defect_NO,Supplier_No,Vehicle_loaded,Customer_Name,Depot_Name,Inc_Type_ID

                        ) 
                        VALUES (?, ?, ?, ?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""", 
                        (generate_new_i_number(), current_datetime,created,combined_datetime,driver_name, 
                         reg_no,contact_methodd,contactname,contacttel,contactemail,drivertel,Defect_loc,faultdesc,
                         cat_value_to_store,lol_value_to_store,
                         char_value_to_store,stat_value_store,odo,attendance,combined_deferred,what3,
                         fleet,custid,contractno,locat,defectno,supplier_no,vehicle_loaded,customer_name,depot_name,InciType_value_to_store))
            print("Record inserted successfully")

        # Commit the transaction
        conn.commit()

    except Exception as e:
        print("Error:", e)
        conn.rollback()  # Rollback the transaction in case of error

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def generate_new_i_number():
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    cur.execute("SELECT MAX(I_Number) FROM Incident_Headder")
    max_i_number = cur.fetchone()[0] or 0  # If there are no existing records, set max_i_number to 0
    cur.close()
    conn.close()
    return max_i_number + 1

def generate_event_number(Incident_No):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    #i_number=generate_new_i_number()
    cur.execute("SELECT COUNT(*) FROM Incident_Events WHERE I_Number=?",(Incident_No))
    event_number = cur.fetchone()[0] or 0  # If there are no existing records, set max_i_number to 0
    cur.close()
    conn.close()
    return event_number + 1
       


def retrieve_all_incidents():
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()

    conn2=pyodbc.connect(conn_str2)
    cur2=conn2.cursor()


    try:
     # Execute a SELECT query to retrieve all incidents
     cur.execute("""WITH LatestEvent AS (
    SELECT 
        I_Number, 
        Event_Owner, 
        Next_Event_DT,
        ROW_NUMBER() OVER (PARTITION BY I_Number ORDER BY E_Number DESC) as rn
    FROM Incident_Events
    )
    SELECT 
    ih.*,Cat_Description,Location_Description,Charge_Description, Contact_Method_Description,Status_Description,
    le.Event_Owner, Created_BY,
    le.Next_Event_DT
    FROM 
    Incident_Headder ih
	JOIN 
    I_Defect_Cats cats ON ih.Cat_ID = cats.Cat_ID
    JOIN 
    I_Locations loc ON ih.Location_ID= loc.Location_ID
	JOIN
	I_Charge_Types charge ON ih.Charge_ID = charge.Charge_ID
	JOIN
	Contact_Methods con ON ih.Contact_Method_ID= con.Contact_Method_ID
	JOIN
	I_Status stat ON ih.Status_ID= stat.Status_ID
    LEFT JOIN 
    LatestEvent le 
    ON ih.I_Number = le.I_Number
    AND le.rn = 1
    ORDER BY 
    ih.I_NUMBER DESC""")

    # Fetch all rows of the result set
     rows = cur.fetchall()

        # Convert the rows into a list of dictionaries
     incidents = []
     for row in rows:

            incident = {
                "Incident Date": row[3],
                "Registration": row[22],
                "Incident No": row[0],
                "Status": row[21],
                "Category":row[12],
                "Location":row[13],
                "Charge":row[14],
                "Customer":row[30],
                "Locationn":row[31],
                "Cat_Desc":row[-8],
                "Loc_Desc":row[-7],
                "Char_Desc":row[-6],
                "Contact_Desc":row[-5],
                "Status_Desc":row[-4],
                "Owner":row[-3],
                "Creator":row[-2],
                "Next_Event_Date":row[-1]
                # Add other columns as needed
            }
            incidents.append(incident)

     return incidents    
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()


def retrieve_last_incident():
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    conn2=pyodbc.connect(conn_str2)
    cur2=conn2.cursor()

    try:
        cur.execute("""WITH LatestEvent AS (
    SELECT 
        I_Number, 
        Event_Owner, 
        Next_Event_DT,
        ROW_NUMBER() OVER (PARTITION BY I_Number ORDER BY E_Number DESC) as rn
    FROM Incident_Events
    )
    SELECT 
	TOP 1
    ih.*, 
    le.Event_Owner, 
    le.Next_Event_DT
    FROM 
    Incident_Headder ih
    LEFT JOIN 
    LatestEvent le 
    ON ih.I_Number = le.I_Number
    AND le.rn = 1
    ORDER BY 
    ih.I_NUMBER DESC""")
        # Fetch the last row of the result set
        row = cur.fetchone()

        if row:
    
            incidents = {
                "Incident Date": row[3],
                "Registration": row[22],
                "Incident No": row[0],
                "Status": row[21],
                "Category":row[12],
                "Location":row[13],
                "Charge":row[14],
                "Customer":row[30],
                "Locationn":row[31],
                "Owner":row[-2],
                "Next_Event_DT":row[-1]
            }
            return [incidents]  # Return as a list of dictionaries

        else:
            print("No incidents found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()


#conn=pyodbc.connect(conn_str2)
#cur = conn.cursor()
#cur.execute("Select TOP 1 * FROM dbo.PARC")
#rows=cur.fetchall()
#for row in rows:
    print(row)
#cur.close()
#conn.close()

def fetch_details_from_database(reg_no):
    conn = pyodbc.connect(conn_str2)
    cur = conn.cursor()
        # Define the SQL query to fetch details based on the registration number
    query = """SELECT DISTINCT
    IMMAT as REG,
    PARC_CGRISE.PARC_ID as FLEET_NO,
    PARC.MARQUE + ' ' + CODE_MODELE + ' ' + CODE_TYPEMODELE as MAKE_MOD,
    POSITION_COURANTE.MISSION_NO_CONTRAT AS CONTRACT_NO,
    CONTRAT_VAR.ID_FICHE AS CUSTOMER_NO,
    dbo.CLIENT_FICHE.NOM_SOC AS CUSTOMER_NAME,
	dbo.POSITION_COURANTE.CODE_AGENCE_DERNLOCAL AS PF_DEPOT,
	dbo.CLIENT_ADRESSE.VILLE as CUSTOMER_DEPOT
FROM dbo.PARC_CGRISE
JOIN PARC ON PARC.PARC_ID = PARC_CGRISE.PARC_ID
JOIN dbo.POSITION_COURANTE ON PARC_CGRISE.PARC_ID = POSITION_COURANTE.PARC_ID
LEFT JOIN CONTRAT_VAR ON 
	CONTRAT_VAR.NO_CONTRAT = POSITION_COURANTE.MISSION_NO_CONTRAT 
	OR CONTRAT_VAR.NO_CONTRAT = POSITION_COURANTE.NO_CONTRAT
	AND CONTRAT_VAR.PARC_ID = CASE 
        WHEN POSITION_COURANTE.CODE_MISSIONCNT = 'RELAIS' 
        THEN POSITION_COURANTE.PARC_ID_REMPLACE 
        ELSE PARC_CGRISE.PARC_ID 
    END 
LEFT JOIN CLIENT_FICHE ON CLIENT_FICHE.ID_FICHE = CONTRAT_VAR.ID_FICHE
LEFT JOIN dbo.CLIENT_ADRESSE ON dbo.CONTRAT_VAR.ID_FICHE = dbo.CLIENT_ADRESSE.ID_FICHE AND dbo.CONTRAT_VAR.CLIENT_ADRFACT = dbo.CLIENT_ADRESSE.ID_ADRESSE
WHERE IMMAT = ?"""
    cur.execute(query, (reg_no,))
    result = cur.fetchone()

    # Close cursor and database connection
    cur.close()

    return result




def fetch_locations_and_descriptions():
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    cur.execute("""SELECT Depot_Code, Depot_Name FROM PF_Depot_Details""")
    rows = cur.fetchall()
    return rows

def fetch_supplier_details():
    conn = pyodbc.connect(conn_str2)
    cur = conn.cursor()
    cur.execute("""Select T_AUXILIAIRE as Supplier_NO,T_LIBELLE as Supplier_Name, T_TELEPHONE as Tel
                FROM [C_MODEL_UK].[dbo].[TIERS]
                WHERE T_AUXILIAIRE like 'SU%' AND T_TABLE7 = 'ACTIVE'
                ORDER BY T_LIBELLE""")
    rows=cur.fetchall()
    return rows
    
def retrieve_incident_details(registration_number,incident_number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
        # Execute a SELECT query to retrieve the last incident
        cur.execute("""SELECT 
    ih.*, 
    Cat_Description,Location_Description,Charge_Description, Contact_Method_Description,Status_Description,Inc_Type_Description
    FROM 
    Incident_Headder ih
    JOIN 
    I_Defect_Cats cats ON ih.Cat_ID = cats.Cat_ID
    JOIN 
    I_Locations loc ON ih.Location_ID= loc.Location_ID
	JOIN
	I_Charge_Types charge ON ih.Charge_ID = charge.Charge_ID
	JOIN
	Contact_Methods con ON ih.Contact_Method_ID= con.Contact_Method_ID
	JOIN
	I_Status stat ON ih.Status_ID= stat.Status_ID
	LEFT JOIN
	Incident_Types Inctype on ih.Inc_Type_ID= Inctype.Inc_Type_ID
    WHERE Registration_NO = ? AND I_Number= ?""", (registration_number,incident_number))      # Fetch the last row of the result set
        row = cur.fetchone()

        if row:
            # Convert the row into a dictionary
            incident_details = {
              # "Incident Date": row[3],
                "Registration": row[22],
                "Driver_name":row[10],
                "Driver_phone":row[11],
                "Cat":row[-6],
                "Loca":row[-5],
                "Charge":row[-4],
                "Contact_id":row[-3],
                "Contact_name":row[7],
                "Contact_tel":row[8],
                "Contact_Email":row[9],
                "Defect_Address":row[15],
                "Defectdesc": row[17],
                "Cust_defect":row[20],
                "Incident No": row[0],
                "Date":row[3],
                "Createdby":row[2],
                "Odometer":row[27],
                "Status": row[-2],
                "Closed":row[26],
                "Attendance":row[18],
                "Deferred":row[19],
                "Whatwords":row[25],
                #"Category":row[12],
                #"Location":row[13],
                #"Charge":row[14],
                "Customer":row[5],
                "Supplier_No":row[28],
                "Vehicle_loaded":row[29],
                "Inc_Type": row[-1]
                #"Locationn":row[24]
                # Add other columns as needed
            }
            return incident_details  # Return as a list of dictionaries

        else:
            print("No incidents found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def fetch_additional_details(registration_number):
    conn = pyodbc.connect(conn_str2)
    cur = conn.cursor()
    try:
        query = """SELECT DISTINCT
    IMMAT as REG,
    PARC_CGRISE.PARC_ID as FLEET_NO,
    PARC.MARQUE + ' ' + CODE_MODELE + ' ' + CODE_TYPEMODELE as MAKE_MOD,
    POSITION_COURANTE.MISSION_NO_CONTRAT AS CONTRACT_NO,
    CONTRAT_VAR.ID_FICHE AS CUSTOMER_NO,
    dbo.CLIENT_FICHE.NOM_SOC AS CUSTOMER_NAME,
	dbo.POSITION_COURANTE.CODE_AGENCE_DERNLOCAL AS PF_DEPOT,
	dbo.CLIENT_ADRESSE.VILLE as CUSTOMER_DEPOT
FROM dbo.PARC_CGRISE
JOIN PARC ON PARC.PARC_ID = PARC_CGRISE.PARC_ID
JOIN dbo.POSITION_COURANTE ON PARC_CGRISE.PARC_ID = POSITION_COURANTE.PARC_ID
LEFT JOIN CONTRAT_VAR ON 
	CONTRAT_VAR.NO_CONTRAT = POSITION_COURANTE.MISSION_NO_CONTRAT 
	OR CONTRAT_VAR.NO_CONTRAT = POSITION_COURANTE.NO_CONTRAT
	AND CONTRAT_VAR.PARC_ID = CASE 
        WHEN POSITION_COURANTE.CODE_MISSIONCNT = 'RELAIS' 
        THEN POSITION_COURANTE.PARC_ID_REMPLACE 
        ELSE PARC_CGRISE.PARC_ID 
    END 
LEFT JOIN CLIENT_FICHE ON CLIENT_FICHE.ID_FICHE = CONTRAT_VAR.ID_FICHE
LEFT JOIN dbo.CLIENT_ADRESSE ON dbo.CONTRAT_VAR.ID_FICHE = dbo.CLIENT_ADRESSE.ID_FICHE AND dbo.CONTRAT_VAR.CLIENT_ADRFACT = dbo.CLIENT_ADRESSE.ID_ADRESSE
WHERE IMMAT = ?"""
        cur.execute(query, (registration_number))
        row= cur.fetchone()
        if row:
            # Convert the row into a dictionary
         additional_details={
            "fleet_no":row[1],
            "Make_Mod":row[2],
            "Contract_No":row[3],
            "Customer_No":row[4],
            "Customer_Name":row[5],
            "PF_Depot":row[6],
            "Customer_Depot":row[7]
        }
         return additional_details
        else:
            print("No details in the database.")
            return None
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()
    
    
def update_incident_Details(Driver_name,fleet_no,Driver_Phone,Customer_Id,Contract_No,
                            Contact_Tel,Contact_Email,Contact_Name,Customer_defect_no,contact_methodd,
                            Defect_Address,Incident_No,combined_datetime,created_by,Odometer,
                            Depot_no,cat_value_to_store,lol_value_to_store,char_value_to_store,Faultdesc,stat_value_store,
                            Attendance_def,combined_deferred, whatwords,registration_no,SupplierNo,Vehicle_loaded,customer_name,depot_name,InciType_value_to_store):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    try:
        # Check if a record with the same Registration_No already exists
        cur.execute("""SELECT COUNT(*) FROM Incident_Headder WHERE Registration_No = ? AND 
                    I_Number=?""", (registration_no,Incident_No))
        record_count = cur.fetchone()[0]
        if record_count > 0:
            #If a record exists, update it
            cur.execute("""Update Incident_Headder 
                        SET 
                        Driver_Name=?,
                        Fleet_No=?,
                        Driver_Tel=?,
                        Customer_ID=?,
                        Customer_Contract_NO=?,
                        Contact_Tel=?,
                        Contact_Email=?,
                        Contact_Name=?,
                        Customer_defect_no=?,
                        Contact_Method_ID=?,
                        Defect_Loc_Address=?,
                        I_Number=?,
                        Defect_occurred=?,
                        Created_BY=?,
                        Odometer=?,
                        Depot_No=?,
                        Cat_ID=?,
                        Location_ID=?,
                        Charge_ID=?,
                        Reported_Defect=?,
                        Status_ID=?,
                        Attendance_Deferred=?,
                        Deferred_To=?,
                        Defect_loc_W3W=?,
                        Supplier_No=?,
                        Vehicle_loaded=?,
                        Customer_Name=?,
                        Depot_Name=?,
                        Inc_Type_ID=?
                        WHERE Registration_No =? AND I_Number=?""",(Driver_name,fleet_no,Driver_Phone,Customer_Id
                            ,Contract_No,Contact_Tel,Contact_Email,Contact_Name,Customer_defect_no,
                             contact_methodd,Defect_Address,Incident_No,combined_datetime,created_by,Odometer,Depot_no,
                             cat_value_to_store,lol_value_to_store,char_value_to_store,Faultdesc,stat_value_store,
                             Attendance_def,combined_deferred,whatwords,SupplierNo,Vehicle_loaded,customer_name,depot_name,InciType_value_to_store,registration_no,Incident_No))
        conn.commit()
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()
            
def fetch_status_details():
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    cur.execute("Select * From I_Status")
    rows=cur.fetchall()
    return rows
def fetch_cat_details():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM I_Defect_Cats")
    rows=cur.fetchall()
    return rows
def fetch_Location_details():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM I_Locations")
    rows=cur.fetchall()
    return rows
def fetch_Incidenttype_details():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM Incident_Types")
    rows=cur.fetchall()
    return rows
def fetch_charge_details():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM I_Charge_Types")
    rows=cur.fetchall()
    return rows
def fetch_contact_detais():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("Select * From Contact_Methods")
    rows=cur.fetchall()
    return rows
def fetch_event_types():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("Select * from Event_Types")
    rows=cur.fetchall()
    return rows

def store_event_details(Incident_No,datetime_obj,First_event_tostore,Event_text,Second_event_tostore,
                        datetime_objj,Created_by,Owner):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    
    cur.execute("""Insert into Incident_Events(I_Number,E_Number,E_Created,Event_Type_ID,
                Event_Text,Next_Event_ID,Next_Event_DT,Created_By,Event_Owner)
                Values(?,?,?,?,?,?,?,?,?)""",(Incident_No,generate_event_number(Incident_No),datetime_obj
                                ,First_event_tostore,Event_text,Second_event_tostore,datetime_objj,
                                Created_by,Owner))
    conn.commit()
    cur.close()
    conn.close()

def store_event_detailstwo(Incident_No,datetime_obj,First_event_tostore,Event_Notes,Second_event_tostore,
                        datetime_objj,Created_by,Ownerof):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    
    cur.execute("""Insert into Incident_Events(I_Number,E_Number,E_Created,Event_Type_ID,
                Event_Text,Next_Event_ID,Next_Event_DT,Created_By,Event_Owner)
                Values(?,?,?,?,?,?,?,?,?)""",(Incident_No,generate_event_number(Incident_No),datetime_obj
                                ,First_event_tostore,Event_Notes,Second_event_tostore,datetime_objj,
                                Created_by,Ownerof))
    conn.commit()
    cur.close()
    conn.close()

def fetch_all_events(Incident_No):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""WITH RankedEventTypes AS (
    SELECT 
        Event_Type_ID,
        Event_Description,
        ROW_NUMBER() OVER (ORDER BY Event_Type_ID) AS RowNum
    FROM 
        Event_Types
    )
    SELECT 
    ie.*, 
    et_event.Event_Description AS event_description, 
    et_next.Event_Description AS next_event_description
    FROM 
    Incident_Events ie
    JOIN 
    Event_Types et_event ON ie.Event_Type_ID = et_event.Event_Type_ID
    JOIN 
    RankedEventTypes et_next ON ie.Next_Event_ID = et_next.RowNum
    WHERE ie.I_Number=?
    ORDER BY E_Number DESC""",(Incident_No))
     row = cur.fetchone()

     if row:
            # Convert the row into a dictionary
            event_details = {
               "Created": row[2],
               "Notes":row[4],
               "Last Updated":row[2],
               "Follow up":row[6],
               "Event_Description": row[-2],
               "Next_Event_Description": row[-1],
               "Created_By": row[7],
               "Owner":row[8]
            }
            return [event_details]  # Return as a list of dictionaries

     else:
            print("No events found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def fetch_all_events_oncemore(Incident_No):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""WITH RankedEventTypes AS (
    SELECT 
        Event_Type_ID,
        Event_Description,
        ROW_NUMBER() OVER (ORDER BY Event_Type_ID) AS RowNum
    FROM 
        Event_Types
    )
    SELECT 
    ie.*, 
    et_event.Event_Description AS event_description, 
    et_next.Event_Description AS next_event_description
    FROM 
    Incident_Events ie
    JOIN 
    Event_Types et_event ON ie.Event_Type_ID = et_event.Event_Type_ID
    JOIN 
    RankedEventTypes et_next ON ie.Next_Event_ID = et_next.RowNum
    WHERE ie.I_Number=?
    ORDER BY E_Number """,(Incident_No))
     rows = cur.fetchall()
     incidents=[]
     for row in rows:     
            # Convert the row into a dictionary
            event_details = {
               "Created": row[2],
               "Notes":row[4],
               "Last Updated":row[2],
               "Follow up":row[6],
               "Event_Description": row[-2],
               "Next_Event_Description": row[-1],
               "Created_By": row[7],
               "Owner":row[8]
            }
            incidents.append(event_details)
     return  incidents

     

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()
    
def fetch_all_event_details(incident_number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
        # Execute a SELECT query to retrieve all incidents
        sqlquery= """WITH RankedEventTypes AS (
    SELECT 
        Event_Type_ID,
        Event_Description,
        ROW_NUMBER() OVER (ORDER BY Event_Type_ID) AS RowNum
    FROM 
        Event_Types
    )
    SELECT 
    ie.*, 
    et_event.Event_Description AS event_description, 
    et_next.Event_Description AS next_event_description
    FROM 
    Incident_Events ie
    JOIN 
    Event_Types et_event ON ie.Event_Type_ID = et_event.Event_Type_ID
    JOIN 
    RankedEventTypes et_next ON ie.Next_Event_ID = et_next.RowNum
    WHERE ie.I_Number=?
    ORDER BY E_Number"""
        cur.execute(sqlquery, (incident_number,))
        # Fetch all rows of the result set
        rows = cur.fetchall()
        # Convert the rows into a list of dictionaries
        incident_events = []
        for row in rows:
            
            events = {
               "Created": row[2],
               "Notes":row[4],
               "Last Updated":row[2],
               "Follow up":row[6],
               "Event_Description": row[-2],
               "Next_Event_Description": row[-1],
               "Created_By": row[7],
               "Owner":row[8]
            }
            incident_events.append(events)

        return incident_events

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def fetch_data_for_event(incident_no,event_no):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""WITH RankedEventTypes AS (
    SELECT 
        Event_Type_ID,
        Event_Description,
        ROW_NUMBER() OVER (ORDER BY Event_Type_ID) AS RowNum
    FROM 
        Event_Types
    )
    SELECT 
    ie.*, 
    et_event.Event_Description AS event_description, 
    et_next.Event_Description AS next_event_description
    FROM 
    Incident_Events ie
    JOIN 
    Event_Types et_event ON ie.Event_Type_ID = et_event.Event_Type_ID
    JOIN 
    RankedEventTypes et_next ON ie.Next_Event_ID = et_next.RowNum
    WHERE ie.I_Number=? AND E_Number=?""",(incident_no,event_no))
     row=cur.fetchone()

     if row:
            # Convert the row into a dictionary
            event_details = {
                "Event_Type":row[-2],
                "Createdby":row[7],
                "Owner":row[8],
                "Createddate":row[2],
                "Eventtext":row[4],
                "Nexteventdate":row[6],
                "Nexteventtype":row[-1],
            }
            return event_details  # Return as a list of dictionaries

     else:
            print("No incidents found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def generate_event_numbertwo(i_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    cur.execute("SELECT COUNT(*) FROM Incident_Events WHERE I_Number=?",(i_number,))
    event_numbertwo = cur.fetchone()[0] or 0  # If there are no existing records, set max_i_number to 0
    cur.close()
    conn.close()
    return event_numbertwo + 1

def insert_more_events(i_number,datetime_obj,First_event_tostore,Event_text
                                     ,Second_event_tostore,datetime_objj,Created_by,Owner):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()

    cur.execute("""INSERT INTO Incident_Events (I_Number,E_Number,E_Created,Event_Type_ID,
                Event_Text,Next_Event_ID,Next_Event_DT,Created_By,Event_Owner) Values(?,?,?,?,?,?,?,?,?)
                """,(i_number,generate_event_numbertwo(i_number),datetime_obj,First_event_tostore,Event_text
                    ,Second_event_tostore,datetime_objj,Created_by,Owner)) 
    conn.commit()
    cur.close()
    conn.close()                  

def fetch_all_eventstwo(i_number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""WITH RankedEventTypes AS (
    SELECT 
        Event_Type_ID,
        Event_Description,
        ROW_NUMBER() OVER (ORDER BY Event_Type_ID) AS RowNum
    FROM 
        Event_Types
    )
    SELECT 
    ie.*, 
    et_event.Event_Description AS event_description, 
    et_next.Event_Description AS next_event_description
    FROM 
    Incident_Events ie
    JOIN 
    Event_Types et_event ON ie.Event_Type_ID = et_event.Event_Type_ID
    JOIN 
    RankedEventTypes et_next ON ie.Next_Event_ID = et_next.RowNum
    WHERE ie.I_Number=?""",(i_number))
     row = cur.fetchone()

     if row:
            # Convert the row into a dictionary
            event_details = {
               "Created": row[2],
               "Notes":row[4],
               "Last Updated":row[2],
               "Follow up":row[6],
               "Event_Description": row[-2],
               "Next_Event_Description": row[-1],
               "Created_By": row[7],
               "Owner":row[8]
            }
            return [event_details]  # Return as a list of dictionaries

     else:
            print("No events found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def fetch_data_for_eventthree(incident_no,event_no):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""WITH RankedEventTypes AS (
    SELECT 
        Event_Type_ID,
        Event_Description,
        ROW_NUMBER() OVER (ORDER BY Event_Type_ID) AS RowNum
    FROM 
        Event_Types
    )
    SELECT 
    ie.*, 
    et_event.Event_Description AS event_description, 
    et_next.Event_Description AS next_event_description
    FROM 
    Incident_Events ie
    JOIN 
    Event_Types et_event ON ie.Event_Type_ID = et_event.Event_Type_ID
    JOIN 
    RankedEventTypes et_next ON ie.Next_Event_ID = et_next.RowNum
    WHERE ie.I_Number=? AND E_Number=?""",(incident_no,event_no))
     row=cur.fetchone()

     if row:
            # Convert the row into a dictionary
            event_details = {
                "Event_Type":row[-2],
                "Createdby":row[7],
                "Owner":row[8],
                "Createddate":row[2],
                "Eventtext":row[4],
                "Nexteventdate":row[6],
                "Nexteventtype":row[-1],
                "Created_By": row[7],
               "Owner":row[8]
            }
            return event_details  # Return as a list of dictionaries

     else:
            print("No incidents found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def retrieve_updated_incieve(Incident_No):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""WITH LatestEvent AS (
    SELECT 
        I_Number, 
        Event_Owner, 
        Next_Event_DT,
        ROW_NUMBER() OVER (PARTITION BY I_Number ORDER BY E_Number DESC) as rn
    FROM Incident_Events
    )
    SELECT 

    ih.*, 
    le.Event_Owner, 
    le.Next_Event_DT
    FROM 
    Incident_Headder ih
    LEFT JOIN 
    LatestEvent le 
    ON ih.I_Number = le.I_Number
    AND le.rn = 1
	WHERE ih.I_Number=?""",(Incident_No))
     row=cur.fetchone()

     if row:
            # Convert the row into a dictionary
            incidents = {
               
                "Incident Date": row[3],
                "Registration": row[22],
                "Incident No": row[0],
                "Status": row[21],
                "Category":row[12],
                "Location":row[13],
                "Charge":row[14],
                "Customer":row[5],
                "Locationn":row[24],
                "Owner":row[-2],
                "Next_Event_DT":row[-1]
            }
            return [incidents]  # Return as a list of dictionaries

     else:
            print("No incidents and Events found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def retrieve_updated_event(i_number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""WITH LatestEvent AS (
    SELECT 
        I_Number, 
        Event_Owner, 
        Next_Event_DT,
        ROW_NUMBER() OVER (PARTITION BY I_Number ORDER BY E_Number DESC) as rn
    FROM Incident_Events
    )
    SELECT 

    ih.*, 
    le.Event_Owner, 
    le.Next_Event_DT
    FROM 
    Incident_Headder ih
    LEFT JOIN 
    LatestEvent le 
    ON ih.I_Number = le.I_Number
    AND le.rn = 1
	WHERE ih.I_Number=?""",(i_number))
     row=cur.fetchone()

     if row:
            # Convert the row into a dictionary
            incidents = {
               
                "Incident Date": row[3],
                "Registration": row[22],
                "Incident No": row[0],
                "Status": row[21],
                "Category":row[12],
                "Location":row[13],
                "Charge":row[14],
                "Customer":row[5],
                "Locationn":row[24],
                "Owner":row[-2],
                "Next_Event_DT":row[-1]
            }
            return [incidents]  # Return as a list of dictionaries

     else:
            print("No incidents and Events found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def giving_i_no_to_events():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
        cur.execute("""SELECT TOP 1 * FROM Incident_Headder ORDER BY I_Number DESC""")
        row=cur.fetchone()
        if row:
            # Convert the row into a dictionary
         incident_details={
            "I_Number":row[0]
        }
         return [incident_details]
        else:
            print("No details in the database.")
            return None
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def retrievevents(incident_no):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""WITH LatestEvent AS (
    SELECT 
        I_Number, 
        Event_Owner, 
        Next_Event_DT,
        ROW_NUMBER() OVER (PARTITION BY I_Number ORDER BY E_Number DESC) as rn
    FROM Incident_Events
    )
    SELECT 

    ih.*, 
    le.Event_Owner, 
    le.Next_Event_DT
    FROM 
    Incident_Headder ih
    LEFT JOIN 
    LatestEvent le 
    ON ih.I_Number = le.I_Number
    AND le.rn = 1
	WHERE ih.I_Number=?""",(incident_no))
     row=cur.fetchone()

     if row:
            # Convert the row into a dictionary
            incidents = {
               
                "Incident Date": row[3],
                "Registration": row[22],
                "Incident No": row[0],
                "Status": row[21],
                "Category":row[12],
                "Location":row[13],
                "Charge":row[14],
                "Customer":row[5],
                "Locationn":row[24],
                "Owner":row[-2],
                "Next_Event_DT":row[-1]
            }
            return [incidents]  # Return as a list of dictionaries

     else:
            print("No incidents and Events found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def users_function(username, password):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute('SELECT * FROM Users WHERE Username COLLATE SQL_Latin1_General_CP1_CS_AS = ? AND User_password COLLATE SQL_Latin1_General_CP1_CS_AS =?', (username, password))
    user=cur.fetchone()

    cur.close()
     # Close the database connection
    conn.close()
        # Return True if a user is found, False otherwise
    if user:
     messagebox.showinfo("Login Successful", "Welcome!")
    else:
            messagebox.showerror("Login Failed", "Username or password incorrect")
    return user is not None
    
    

def generate_user_id():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("""Select MAX(id) FROM Users""")
    max_user_id = cur.fetchone()[0] or 0  # If there are no existing records, set max_i_number to 0
    cur.close()
    conn.close()
    return max_user_id + 1
    

def add_more_users(new_username,new_password):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute('SELECT * FROM Users WHERE Username = ?', (new_username,))
    if cur.fetchone():
     messagebox.showerror("Error", "Username already exists")
     conn.close()
     return

    #cur.execute('SELECT * FROM Users WHERE User_password = ?', (new_password,))
    #if cur.fetchone():
     #messagebox.showerror("Error", "Password already exists")
    # conn.close()
     #return
    try:
     cur.execute("""INSERT INTO USERS (id,Username, User_password) VALUES (?,?,?)""", (generate_user_id(),new_username, new_password))
     conn.commit()
     messagebox.showinfo("Success", "User added successfully")
    except pyodbc.IntegrityError:
     messagebox.showerror("Error", "Username already exists")
    finally:
     conn.close()

def reset_password_for_users(new_password,username):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor() 
    cur.execute('UPDATE Users SET User_password = ? WHERE Username = ?', (new_password, username))
    if cur.rowcount == 0:
     messagebox.showerror("Error", "Username not found")
    else:
     conn.commit()
     messagebox.showinfo("Success", "Password reset successfully")
     conn.close()
def delete_users(username):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute('SELECT * FROM Users WHERE Username = ?', (username,))
    user = cur.fetchone()

    if not user:
     messagebox.showerror("Error", "Username not found")
     cur.close()
     conn.close()
     return

    try:
     cur.execute('DELETE FROM Users WHERE Username = ?', (username,))
     conn.commit()
     messagebox.showinfo("Success", "User deleted successfully")
                
    except pyodbc.Error as e:
     messagebox.showerror("Error", f"Failed to delete user: {str(e)}")
    finally:
     cur.close()
     conn.close()

def getmileage(fleetno):
    conn = pyodbc.connect(conn_str2)
    cur = conn.cursor()
    
    query = """SELECT TOP (1) [KM_CHASSIS]
  FROM [IGLOO_UK].[dbo].[PARC_KM]
  WHERE [PARC_ID] = ?
  ORDER BY [DTE_EFFETRELEVE] DESC"""
    cur.execute(query, (fleetno))
    row= cur.fetchone()
    cur.close()

    return row

def get_cust_name():
    conn = pyodbc.connect(conn_str2)
    cur = conn.cursor()
    cur.execute("""SELECT [NOM_SOC],[ID_FICHE]
                    FROM [IGLOO_UK].[dbo].[CLIENT_FICHE]""")
    rows=cur.fetchall()
    return rows

#Purchase order details

def generate_purchase_order_number():
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    cur.execute("SELECT MAX(PO_Number) FROM Purchase_Order_Headder")
    max_purchase_ordernumber = cur.fetchone()[0] or 0  # If there are no existing records, set max_i_number to 0
    cur.close()
    conn.close()
    return max_purchase_ordernumber + 1

def get_existing_approval_number(incident_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    try:
        cur.execute("""
            SELECT PO_Number
            FROM Purchase_Order_Headder
            WHERE Incident_Link = ?
        """, (incident_number,))

        # Fetch the first row from the result
        row = cur.fetchone()
        if row:
            return row.PO_Number  
        else:
            return None
    except Exception as e:
        print(f"Error fetching approval number: {e}")
        return None
    finally:
        # Always close the database connection
        cur.close()
        conn.close()

def generate_line_number(PO_Number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    cur.execute("SELECT COUNT(PO_Number) FROM Order_Cost_Lines  WHERE PO_Number=?", (PO_Number))
    line_number=cur.fetchone()[0]or 0
    cur.close()
    conn.close()
    return line_number+1

def store_the_purchase_orderinfo(PO_Number,i_number,combined_datetime,Created_By,Supplier_No,
                                              Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,
                                              Supplier_Name,Repaired_Datetime):
    
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()

    try:
        # Check if a record with the same Registration_No already exists
        cur.execute("""SELECT COUNT(*) FROM Purchase_Order_Headder WHERE PO_Number = ?"""
                    , (PO_Number))

        record_count = cur.fetchone()[0]

        if record_count > 0:
            # If a record exists, update it
            cur.execute("""UPDATE Purchase_Order_Headder 
                        SET 
                        PO_Created=?,
                        Created_BY=?,
                        Supplier_No=?,
                        Order_Cat=?,
                        Fleet_No=?,
                        Odometer=?,
                        Customer_PO=?,
                        Kofax_Scan_No=?,
                        Igloo_Invoice_No=?,
                        Supplier_Name=?,
                        Repaired=?
                        WHERE PO_Number = ? AND Incident_Link=?""", 
                        (combined_datetime,Created_By,Supplier_No,
                        Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,Supplier_Name,Repaired_Datetime,PO_Number,i_number))
            print("Record updated successfully")
        else:
            cur.execute("""INSERT INTO Purchase_Order_Headder(PO_Number,Incident_Link,PO_Created,Created_BY,
                        Supplier_No,Order_Cat,Fleet_No,Odometer,Customer_PO,Kofax_Scan_No,Igloo_Invoice_No,Supplier_Name,Repaired
                        ) 
                        VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)""", 
                        (PO_Number,i_number,combined_datetime,Created_By,Supplier_No,
                                              Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,Supplier_Name,Repaired_Datetime
    ))
            print("Record inserted successfully")

        # Commit the transaction
        conn.commit()

    except Exception as e:
        print("Error:", e)
        conn.rollback()  # Rollback the transaction in case of error

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def store_cost_lines(PO_Number,bothdateandtime,Added_By,PF_Depot,Parts_Cost,Labour_Hours,Labour_Rate,
                            Labour_cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_cost,Recharge_invoiced,combined_datetime,
                                 Notes,Recharge_text,type_id,Category_id,Product_id,Supplier_Name,Product_description):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    
    cur.execute("""Insert into Order_Cost_Lines(PO_Number,Line_Number,Line_Added,Added_By,PF_Depot,Parts_Cost,Labour_Hours,Labour_Rate,Labour_Cost,Parts_Uplift,
                Labour_Uplift,Recharge_parts,Recharge_labour,
                Recharge_invoiced,Recharge_posted,Notes,Recharge_Text,PO_Type_ID,PO_Category_ID,PO_Product_ID,Supplier_Name,PO_Product_Description)
                Values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""",(PO_Number,generate_line_number(PO_Number),bothdateandtime,Added_By,PF_Depot,Parts_Cost,Labour_Hours,
                                Labour_Rate,Labour_cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_cost,Recharge_invoiced,combined_datetime,
                                 Notes,Recharge_text,type_id,Category_id,Product_id,Supplier_Name,Product_description))
    conn.commit()
    cur.close()
    conn.close()

def retrieve_all_purchase_and_populate(Reg_Number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()

    try:
     cur.execute("""SELECT Pu.*,Line_Number,Parts_Cost,Labour_Cost,Recharge_parts,Recharge_labour,Registration_NO,costs.Supplier_Name,costs.PO_Product_Description
		FROM
		Purchase_Order_Headder Pu
		JOIN
		Order_Cost_Lines costs ON Pu.PO_Number = costs.PO_Number
		JOIN 
		Incident_Headder Incident ON Pu.Incident_Link= Incident.I_Number
		WHERE Registration_NO = ?
		ORDER BY PO_Number DESC """,(Reg_Number))

    # Fetch all rows of the result set
     rows = cur.fetchall()

        # Convert the rows into a list of dictionaries
     incidents = []
     for row in rows:
            incident = {
                "Repaired": row[2],
                "Odometer": row[7],
                "Supplier": row[11],
                "Incident_Link": row[1],
                "Total_parts":row[-7],
                "Total_labours":row[-6],
                "Recharge_parts":row[-5],
                "Recharge_labours":row[-4],
                "Approval":row[0],
                "Products":row[-1]
            }
            incidents.append(incident)

     return incidents    
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def retrieve_last_purchase_and_populate(Approval_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()

    try:
     cur.execute("""SELECT TOP 1 Pu.*,Line_Number,Parts_Cost,Labour_Cost,Recharge_parts,Recharge_labour,Registration_NO,costs.Supplier_Name,costs.PO_Product_Description
		FROM
		Purchase_Order_Headder Pu
		JOIN
		Order_Cost_Lines costs ON Pu.PO_Number = costs.PO_Number
		JOIN 
		Incident_Headder Incident ON Pu.Incident_Link= Incident.I_Number
		WHERE Registration_NO = ?
		ORDER BY PO_Number DESC""",(Approval_number))

    # Fetch all rows of the result set
     row = cur.fetchone()
     if row:
            Purchase = {
                "Repaired": row[2],
                "Odometer": row[7],
                "Supplier": row[11],
                "Incident_Link": row[1],
                "Total_parts":row[-7],
                "Total_labours":row[-6],
                "Recharge_parts":row[-5],
                "Recharge_labours":row[-4],
                "Approval":row[0],
                "Products":row[-1]
            }
            return[Purchase]  
     else : 
        print("No information found")
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def populate_costlines(Approval_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()

    try:
     cur.execute("""SELECT TOP 1 * FROM Order_Cost_Lines
                    LEFT JOIN PO_Types
                    ON Order_Cost_Lines.PO_Type_ID=PO_Types.PO_Type_ID
                    LEFT JOIN PO_Category 
                    ON Order_Cost_Lines.PO_Category_ID= PO_Category.PO_Category_ID
                    LEFT JOIN PO_Products
                    ON Order_Cost_Lines.PO_Product_ID= PO_Products.PO_Product_ID
                    AND Order_Cost_Lines.PO_Category_ID = PO_Products.PO_Category_ID 
		            WHERE PO_Number= ?
		            ORDER BY Line_Number DESC""",(Approval_number))

    # Fetch all rows of the result set
     row = cur.fetchone()
     if row:
            incident = {
                "RTS_code": row[-8],
                "RTS_Desc": row[-4],
                "Product_Desc":row[-1],
                "Parts_Cost": row[7],
                "Labour_Cost": row[8],
                "Recharge_parts":row[9],
                "Recharge_labour":row[10]
            }
            return[incident]  
     else : 
        print("No information found")
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()
def populate_all_the_cost_lines(Approval_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    try:
     cur.execute("""SELECT * FROM Order_Cost_Lines
                LEFT JOIN PO_Types
                ON Order_Cost_Lines.PO_Type_ID=PO_Types.PO_Type_ID
                LEFT JOIN PO_Category 
                ON Order_Cost_Lines.PO_Category_ID= PO_Category.PO_Category_ID
                LEFT JOIN PO_Products
                ON Order_Cost_Lines.PO_Product_ID= PO_Products.PO_Product_ID
                AND Order_Cost_Lines.PO_Category_ID = PO_Products.PO_Category_ID 
		        WHERE PO_Number= ?
		        ORDER BY Line_Number """,(Approval_number))

    # Fetch all rows of the result set
     rows = cur.fetchall()
     incidents = []
     for row in rows:
            incident = {
                "RTS_code": row[-8],
                "RTS_Desc": row[-4],
                "Product_Desc":row[-1],
                "Parts_Cost": row[7],
                "Labour_Cost": row[8],
                "Recharge_parts":row[9],
                "Recharge_labour":row[10]
            }
            incidents.append(incident) 
     return incidents 
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def insert_purchase_details(Reg_Number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    try:
     cur.execute("""SELECT TOP 1 Pu.*
                    FROM
                    Purchase_Order_Headder Pu
                    JOIN 
                    Incident_Headder Incident ON Pu.Incident_Link= Incident.I_Number
                    WHERE Registration_NO = ?
                    ORDER BY PO_Number DESC""",(Reg_Number))

    # Fetch all rows of the result set
     row = cur.fetchone()
     if row:
            incident = {
                "PO_Number": row[0],
                "Incident_Link": row[1],
                "PO_Created": row[2],
                "Created_By": row[3],
                "Supplier_No":row[4],
                "Order_Category":row[5],
                "Fleet_No":row[6],
                "Odometer":row[7],
                "Customer_PO": row[8],
                "Kofax_Scan_No": row[9],
                "Igloo_Invoice_No":row[10],
                "Supplier_Name":row[11],
                "Repaired": row[12]
            }
            return incident
    except Exception as e:
        print("Error:", e)
        return None
    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def populate_all_the_cost_lines_two(Approval_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    try:
     cur.execute("""SELECT * FROM Order_Cost_Lines
                    LEFT JOIN PO_Types
                    ON Order_Cost_Lines.PO_Type_ID=PO_Types.PO_Type_ID
                    LEFT JOIN PO_Category 
                    ON Order_Cost_Lines.PO_Category_ID= PO_Category.PO_Category_ID
                    LEFT JOIN PO_Products
                    ON Order_Cost_Lines.PO_Product_ID= PO_Products.PO_Product_ID
                    AND Order_Cost_Lines.PO_Category_ID = PO_Products.PO_Category_ID 
		            WHERE PO_Number= ?
		            ORDER BY Line_Number """,(Approval_number))

    # Fetch all rows of the result set
     rows = cur.fetchall()
     incidents = []
     for row in rows:
            incident = {
                "RTS_code": row[-8],
                "RTS_Desc": row[-4],
                "Product_Desc":row[-1],
                "Parts_Cost": row[7],
                "Labour_Cost": row[8],
                "Recharge_parts":row[9],
                "Recharge_labour":row[10]
            }
            incidents.append(incident) 
     return incidents 
    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def update_the_purchase_orderinfo(PO_Number,i_number,combined_datetime,Created_By,Supplier_No,
                                              Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,Supplier_Name,Repaired_Datetime):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()

    try:
            # If a record exists, update it
        cur.execute("""UPDATE Purchase_Order_Headder 
                        SET 
                        PO_Created=?,
                        Created_BY=?,
                        Supplier_No=?,
                        Order_Cat=?,
                        Fleet_No=?,
                        Odometer=?,
                        Customer_PO=?,
                        Kofax_Scan_No=?,
                        Igloo_Invoice_No=?,
                        Supplier_Name=?,
                        Repaired=?
                        WHERE PO_Number = ? AND Incident_Link=?""", 
                        (combined_datetime,Created_By,Supplier_No,
                        Order_Category,Fleet_No,Odometer,Customer_PO,Kofax_Scan,Igloo_invoice,Supplier_Name,Repaired_Datetime,PO_Number,i_number))
        print("Record updated successfully")

        # Check if any rows were affected
        if cur.rowcount == 0:
        # If no rows were updated, insert a new record
         cur.execute("""INSERT INTO Purchase_Order_Headder 
                       (PO_Created, Created_BY, Supplier_No, Order_Cat, Fleet_No, Odometer, Customer_PO, Kofax_Scan_No, Igloo_Invoice_No, Supplier_Name, Repaired, PO_Number, Incident_Link)
                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""", 
                       (combined_datetime, Created_By, Supplier_No, Order_Category, Fleet_No, Odometer, Customer_PO, Kofax_Scan, Igloo_invoice, Supplier_Name, Repaired_Datetime, generate_purchase_order_number(), i_number))
         print("Record inserted successfully")
        else:
         print("Record updated successfully")
        

        # Commit the transaction
        conn.commit()

    except Exception as e:
        print("Error:", e)
        conn.rollback()  # Rollback the transaction in case of error

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def store_cost_lines_two(PO_Number,bothdateandtime,Added_By,PF_Depot,Parts_Cost,Labour_Hours,
                                 Labour_Rate,Labour_cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_cost,Recharge_invoiced,combined_datetime,
                                 Notes,Recharge_text,type_id,Category_id,Product_id,Supplier_Name, Product_Descriptiom):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    
    cur.execute("""Insert into Order_Cost_Lines(PO_Number,Line_Number,Line_Added,Added_By,PF_Depot,Parts_Cost,Labour_Hours,Labour_Rate,
                Labour_Cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_labour,
                Recharge_invoiced,Recharge_posted,Notes,Recharge_Text,PO_Type_ID,PO_Category_ID,PO_Product_ID,Supplier_Name,PO_Product_Description)
                Values(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)""",(PO_Number,generate_line_number(PO_Number),bothdateandtime,Added_By,PF_Depot,Parts_Cost,Labour_Hours,Labour_Rate,
                                 Labour_cost,Parts_Uplift,Labour_Uplift,Recharge_parts,Recharge_cost,Recharge_invoiced,combined_datetime,
                                 Notes,Recharge_text,type_id,Category_id,Product_id,Supplier_Name,Product_Descriptiom))
    conn.commit()
    cur.close()
    conn.close()
    
def open_costlines_page(PO_Number,Line_added):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""SELECT * FROM Order_Cost_Lines
                    LEFT JOIN PO_Types
                    ON Order_Cost_Lines.PO_Type_ID=PO_Types.PO_Type_ID
                    LEFT JOIN PO_Category 
                    ON Order_Cost_Lines.PO_Category_ID= PO_Category.PO_Category_ID
                    LEFT JOIN PO_Products
                    ON Order_Cost_Lines.PO_Product_ID= PO_Products.PO_Product_ID
                    AND Order_Cost_Lines.PO_Category_ID = PO_Products.PO_Category_ID 
                    WHERE PO_Number= ? AND Line_Number=?""",(PO_Number,Line_added))

    # Fetch all rows of the result set
     row = cur.fetchone()
     if row:
            incident = {
                "PO_Number": row[0],
                "Line_Number": row[1],
                "Line_Added": row[2],
                "Added_By": row[3],
                "Rts_code":row[4],
                "Rts_description":row[5],
                "Pf_depot":row[6],
                "Parts_cost":row[7],
                "labour_cost": row[8],
                "Recharge_parts": row[9],
                "Recharge_labour":row[10],
                "Recharge_invoiced":row[11],
                "Recharge_posted": row[12],
                "Notes":row[13],
                "Recharge_text": row[14],
                "Labour_Hours":row[18],
                "Labour_Rate": row[19],
                "Parts_Uplift":row[20],
                "Labour_Uplift":row[21],
                "Type_ID":row[-9],
                "Type_Desc":row[-8],
                "Category_ID":row[-5],
                "Cat_Desc":row[-4],
                "Product_ID":row[-2],
                "Product_Desc":row[-1]


            }
            return incident
    except Exception as e:
        print("Error:", e)
        return None
    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def get_combined_data():
    engine = create_engine("mssql+pyodbc://", creator=lambda: conn)

    query = """
    SELECT ih.*, ie.*, ipur.*,icos.*
    FROM Incident_Headder ih
    JOIN Incident_Events ie ON ih.I_Number = ie.I_Number
    JOIN Purchase_Order_Headder ipur ON ie.I_Number = ipur.Incident_Link
    JOIN Order_Cost_Lines icos ON ipur.PO_Number= icos.PO_Number
    """
    df = pd.read_sql_query(query, engine)
    conn.close()
    return df
def get_combined_incident_data():
    engine = create_engine("mssql+pyodbc://", creator=lambda: conn)

    query = """
    SELECT *
    FROM Incident_Headder 
    WHERE I_Created is NOT NULL
    """
    df = pd.read_sql_query(query, engine)
    return df
def get_combined_events_data():
    engine = create_engine("mssql+pyodbc://", creator=lambda: conn)

    query = """
    SELECT *
    FROM Incident_Events
    """
    df = pd.read_sql_query(query, engine)
    return df
def get_combined_purchase_data():
    engine = create_engine("mssql+pyodbc://", creator=lambda: conn)

    query = """
    SELECT *
    FROM Purchase_Order_Headder
    """
    df = pd.read_sql_query(query, engine)
    return df
def get_combined_cost_data():
    engine = create_engine("mssql+pyodbc://", creator=lambda: conn)

    query = """
    SELECT *
    FROM Order_Cost_Lines
    """
    df = pd.read_sql_query(query, engine)
    return df
def store_the_postincident_reports(Incident_Number,combined_datetime,Created_By,Incident_cat,
                                               Final_costed,Comments,category_post_value_to_store
                                               ,verdict_post_value_to_store):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()

    try:
        # Check if a record with the same Registration_No already exists
        cur.execute("SELECT COUNT(*) FROM Post_Incident_Reports WHERE I_number=?", (Incident_Number))
        record_count = cur.fetchone()[0]

        if record_count > 0:
            # If a record exists, update it
            cur.execute("""UPDATE Post_Incident_Reports
                        SET 
                        Report_Created = ? ,
                        Created_By=?,
                        Inc_Category_ID=?,
                        Linked_Orders_Final_Costed=?,
                        Comments=?,
                        Cat_ID=?,
                        Verdict_ID=?
                        WHERE I_Number=?""", 
                        (combined_datetime,Created_By,Incident_cat,
                        Final_costed,Comments,category_post_value_to_store,verdict_post_value_to_store,Incident_Number))
            print("Record updated successfully")

    
        else:
            cur.execute("""INSERT INTO Post_Incident_Reports(I_Number,Report_Created,Created_By,Inc_Category_ID,
                Linked_Orders_Final_Costed ,Comments,Cat_ID,Verdict_ID
                        ) 
                        VALUES (?,?,?,?,?,?,?,?)""", 
                        (Incident_Number,combined_datetime,Created_By,Incident_cat,
                                               Final_costed,Comments,category_post_value_to_store,verdict_post_value_to_store))
            print("Record inserted successfully")

           # Commit the transaction
        conn.commit()
    except Exception as e:
        print("Error:", e)
        conn.rollback()  # Rollback the transaction in case of error

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()
def fetch_postreports(Incident_Number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("""SELECT * FROM Post_Incident_Reports WHERE I_Number=?""",(Incident_Number))
    result = cur.fetchone()

    # Close cursor and database connection
    cur.close()

    return result
def fetch_postreportsnew(Inci_number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("""SELECT * FROM Post_Incident_Reports WHERE I_Number=?""",(Inci_number))
    result = cur.fetchone()

    # Close cursor and database connection
    cur.close()

    return result
def fetch_lastpost_reports_and_insert(Incident_Number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""SELECT * FROM Post_Incident_Reports WHERE I_Number=?""",(Incident_Number))
     row=cur.fetchone()

     if row:
            # Convert the row into a dictionary
            post_details = {
                "I_Number":row[0],
                "Report_Created":row[1],
                "Created_By":row[2],
                "Inc_Category_ID":row[3],
                "Linked_Orders":row[4],
                "Comments":row[5],
            }
            return [post_details] # Return as a list of dictionaries

     else:
            print("No post reports found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def fetch_lastpost_reports_and_inserttwo(Incident_Number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""SELECT * FROM Post_Incident_Reports 
                    LEFT JOIN I_Defect_Cats
                    ON Post_Incident_Reports.Cat_ID= I_Defect_Cats.Cat_ID 
                    LEFT JOIN PIR_Verdict 
                    ON Post_Incident_Reports.Verdict_ID= PIR_Verdict.Verdict_ID
                    WHERE I_Number=?""",(Incident_Number))
     row=cur.fetchone()

     if row:
            # Convert the row into a dictionary
            post_details = {
                "I_Number":row[0],
                "Report_Created":row[1],
                "Created_By":row[2],
                "Inc_Category_ID":row[3],
                "Linked_Orders":row[4],
                "Comments":row[5],
                "Category":row[-3],
                "Verdict":row[-1]
            }
            return post_details # Return as a list of dictionaries

     else:
            print("No post reports found in the database.")
            return None

    except Exception as e:
        print("Error:", e)
        return None

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()
def retrieve_costlines_for_approvalnumber(approval_number):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""SELECT * FROM Order_Cost_Lines
                    LEFT JOIN PO_Types
                    ON Order_Cost_Lines.PO_Type_ID=PO_Types.PO_Type_ID
                    LEFT JOIN PO_Category 
                    ON Order_Cost_Lines.PO_Category_ID= PO_Category.PO_Category_ID
                    LEFT JOIN PO_Products
                    ON Order_Cost_Lines.PO_Product_ID= PO_Products.PO_Product_ID
                    AND Order_Cost_Lines.PO_Category_ID = PO_Products.PO_Category_ID   
                    WHERE PO_Number=?""",(approval_number))
     rows = cur.fetchall()
     incidents = []
     for row in rows:
            incident = {
                "RTS_code": row[-8],
                "RTS_Desc": row[-4],
                "Product_Desc":row[-1],
                "Parts_Cost": row[7],
                "Labour_Cost": row[8],
                "Recharge_parts":row[9],
                "Recharge_labour":row[10]
            }
            incidents.append(incident) 
     return incidents 
    except Exception as e:
        print("Error:", e)
        return None
    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()
def fetch_verdict_details():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM PIR_VERDICT")
    rows=cur.fetchall()
    return rows
def adduser_or_justleave(current_user):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    # Check if the user exists
    cur.execute("SELECT * FROM Users WHERE Username = ?", (current_user,))
    user = cur.fetchone()

    if user:
        print("User already exists, no changes made.")
    else:
        # Add the user
        cur.execute(
            "INSERT INTO Users (Username, First_Used, Authority_Level) VALUES (?, ?, ?)",
            (current_user, datetime.datetime.now(), 0)
        )
        conn.commit()
        print("New user added to the database.")

    cur.close()
    conn.close()
def is_authority_level_sufficient(username):
 conn=pyodbc.connect(conn_str1)
 cur=conn.cursor()

 # Check the user's authority level
 cur.execute("SELECT Authority_level FROM users WHERE username = ?", (username,))
 user = cur.fetchone()

 if user:
        authority_level = user[0]
        if authority_level >= 8:
            print(f"User {username} has sufficient authority level ({authority_level}).")
            return True
        else:
            print(f"User {username} does not have sufficient authority level ({authority_level}).")
            return False
 
 cur.close()
 conn.close()    

def is_authority_level_sufficienttwo(username):
 conn=pyodbc.connect(conn_str1)
 cur=conn.cursor()

 # Check the user's authority level
 cur.execute("SELECT Authority_level FROM users WHERE username = ?", (username,))
 user = cur.fetchone()

 if user:
        authority_level = user[0]
        if authority_level >= 6:
            print(f"User {username} has sufficient authority level ({authority_level}).")
            return True
        else:
            print(f"User {username} does not have sufficient authority level ({authority_level}).")
            return False
 
 cur.close()
 conn.close()    
 
def Fetch_PO_Types():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM PO_Types WHERE Incident_Linked='Yes'")
    rows=cur.fetchall()
    return rows
def Fetch_PO_Types_noinci():
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM PO_Types WHERE Incident_Linked='No'")
    rows=cur.fetchall()
    return rows
def Fetch_Categories_By_Type(type_id):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM PO_Category WHERE PO_Type_ID=?",(type_id))
    rows=cur.fetchall()
    return rows
def Fetch_Products_By_Category(category_id):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("SELECT * FROM PO_Products WHERE PO_Category_ID=?",(category_id))
    rows=cur.fetchall()
    return rows
def store_the_costlines_withoutinci(SupplierName_withoutinci,PO_Number,SupplierNo,
                                                combined_datetime,Created_By,type_id,Category_id,
                                                Product_id,Pf_Depot,Parts,Notes,Product_Description):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    try:
     cur.execute("""INSERT INTO Purchase_Order_Headder(PO_Number,Incident_Link,Supplier_No
                 ,Supplier_Name) Values(?,?,?,?)""",(PO_Number,1,SupplierNo,SupplierName_withoutinci) )
     cur.execute("""INSERT INTO Order_Cost_Lines(PO_Number,Line_Number,Line_Added,Added_By,PO_Type_ID,
                 PO_Category_ID,PO_Product_ID,PF_Depot,Parts_Cost,Notes,PO_Product_Description)
                 VALUES(?,?,?,?,?,?,?,?,?,?)""",(PO_Number,generate_line_number(PO_Number),combined_datetime,
                                                Created_By,type_id,Category_id,Product_id,Pf_Depot,Parts
                                                ,Notes,Product_Description))
     print("Record Inserted Successfully")
     conn.commit()
    except Exception as e:
        print("Error:", e)
        conn.rollback()  # Rollback the transaction in case of error

    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def fetch_uplift_forparts(Depot_Name):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("""SELECT Parts_Uplift FROM PF_Depot_Details WHERE Depot_Name=?""",(Depot_Name))
    result=cur.fetchone()
    return result[0] if result else 0

def fetch_labourrate_forlabours(Depot_Name):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("""SELECT Internal_Labour_Rate FROM PF_Depot_Details WHERE Depot_Name=?""",(Depot_Name))
    result=cur.fetchone()
    return result[0] if result else 0

def fetch_labouruplift_forlabours(Depot_Name):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("""SELECT Ext_Labour_Uplift FROM PF_Depot_Details WHERE Depot_Name=?""",(Depot_Name))
    result=cur.fetchone()
    return result[0] if result else 0

def check_customer_specific(cust_id):
    conn=pyodbc.connect(conn_str1)
    cur=conn.cursor()
    cur.execute("""SELECT Customer_Notes FROM Customer_Specifics WHERE Customer_Number=?""",(cust_id))
    result=cur.fetchone()
    return result
def fetch_approval_numbers(incident_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    
    try:
        cur.execute("""
            SELECT PO_Number
            FROM Purchase_Order_Headder
            WHERE Incident_Link = ?
        """, (incident_number,))
        approval_numbers = [row.PO_Number for row in cur.fetchall()]
        return approval_numbers
    except Exception as e:
        print(f"Error fetching approval numbers: {e}")
        return []
    finally:
        cur.close()
        conn.close()
def fetching_selected_approvaldetails(approval_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    try:
     cur.execute("""SELECT * FROM Purchase_Order_Headder
                WHERE PO_Number= ?""",(approval_number))

    # Fetch all rows of the result set
     row = cur.fetchone()
     if row:
            incident = {
                "PO_Number": row[0],
                "Incident_Link": row[1],
                "PO_Created": row[2],
                "Created_By": row[3],
                "Supplier_No":row[4],
                "Order_Category":row[5],
                "Fleet_No":row[6],
                "Odometer":row[7],
                "Customer_PO": row[8],
                "Kofax_Scan_No": row[9],
                "Igloo_Invoice_No":row[10],
                "Supplier_Name":row[11],
                "Repaired": row[12]
            }
            return incident
    except Exception as e:
        print("Error:", e)
        return None
    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()

def fetching_the_last_approval(Reg_Number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    try:
     cur.execute("""SELECT TOP 1 Pu.*
                    FROM
                    Purchase_Order_Headder Pu
                    JOIN 
                    Incident_Headder Incident ON Pu.Incident_Link= Incident.I_Number
                    WHERE Registration_NO = ?
                    ORDER BY PO_Number DESC""",(Reg_Number))
     row = cur.fetchone()
     if row:
            incident = {
                "PO_Number": row[0],
                "Incident_Link": row[1],
                "PO_Created": row[2],
                "Created_By": row[3],
                "Supplier_No":row[4],
                "Order_Category":row[5],
                "Fleet_No":row[6],
                "Odometer":row[7],
                "Customer_PO": row[8],
                "Kofax_Scan_No": row[9],
                "Igloo_Invoice_No":row[10],
                "Supplier_Name":row[11],
                "Repaired": row[12]
            }
            return incident
    except Exception as e:
        print("Error:", e)
        return None
    finally:
        # Close the cursor and connection
        cur.close()
        conn.close()
def get_the_userdetails():
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    cur.execute("""SELECT * FROM Users""")
    rows=cur.fetchall()
    cur.close()
    conn.close()
    return rows
def check_events(I_number):
    conn = pyodbc.connect(conn_str1)
    cur = conn.cursor()
    cur.execute("""SELECT TOP 1* FROM Incident_Events WHERE I_Number=?""",(I_number))
    rows=cur.fetchone()
    cur.close()
    conn.close()
    # Return None if no rows are found
    if not rows:
        return None
    else:
        return rows[0]  # Return the first row if it exists




     











    








    
    
    

    



    



  
    
